<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ឧបករណ៍ Audio Ducking & Pitch Shift</title>
    <!-- PWA Metadata for Installability -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#161b22">
    <!-- The Manifest link will be injected by JavaScript below -->
    <link id="pwa-manifest-link" rel="manifest" href="">

    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for aesthetic appeal (Dark Theme) */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .card {
            background-color: #161b22;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            border: 1px solid #30363d;
        }
        .status-pill {
            transition: all 0.3s ease-in-out;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-weight: 600;
            text-align: center;
        }
        .status-idle { background-color: #21262d; color: #8b949e; }
        .status-ready { background-color: #1a4220; color: #94e3a2; }
        .status-ducking { background-color: #a87201; color: #f0f6fc; }
        .status-playing { background-color: #238636; color: #f0f6fc; }
        .status-recording { background-color: #9b2c2c; color: #f0f6fc; }
        input[type="file"]::file-selector-button {
            border: 1px solid #30363d; padding: 0.5rem 0.75rem; margin-right: 0.5rem;
            border-radius: 0.375rem; background-color: #21262d; color: #c9d1d9;
            cursor: pointer; transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover { background-color: #30363d; }
        .number-input { appearance: none; -moz-appearance: textfield; }
        .number-input::-webkit-outer-spin-button, .number-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .preset-btn { background-color: #30363d; color: #c9d1d9; }
        .preset-btn:hover { background-color: #444c56; }
        .control-group { border-radius: 0.5rem; padding: 0.75rem; background-color: #21262d; }
        .eq-slider::-webkit-slider-thumb {
            background-color: #4f46e5;
        }
        .eq-slider {
            -webkit-appearance: none; 
            height: 4px;
            background: #4b5563; /* Tailwind gray-600 */
            border-radius: 2px;
        }
        .eq-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4f46e5; /* Tailwind indigo-600 */
            cursor: pointer;
            border: 2px solid #1f2937; /* Tailwind gray-800 */
        }
        .eq-label {
            display: block;
            text-align: center;
            font-size: 0.75rem; /* text-xs */
            font-weight: 500;
            margin-top: 0.25rem;
            color: #9ca3af; /* Tailwind gray-400 */
        }
    </style>
</head>
<body>

    <div id="app" class="card p-6 md:p-10 max-w-4xl w-full rounded-xl">
        
        <!-- NEW TITLE AND DESCRIPTION ADDED HERE -->
        <h1 class="text-3xl font-bold text-white mb-2">ឧបករណ៍ Audio Ducking & Pitch Shift</h1>
        <p class="text-md text-gray-400 mb-6 border-b border-gray-700 pb-4">រៀបចំសំឡេងនិយាយ និងភ្លេងរបស់អ្នកដោយប្លង់ដែលមានរបៀបរៀបរយ។</p>

        <!-- --- 1. SOURCE INPUTS SECTION --- -->
        <h2 class="text-xl font-semibold text-indigo-400 mb-4 border-b border-gray-700 pb-2">១. ប្រភពសំឡេង (Source Inputs)</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <!-- Voice Input Card -->
            <div class="control-group">
                <label for="voice-file" class="block text-sm font-medium mb-2 text-white">សំឡេងនិយាយ (Voice Source)</label>
                <input type="file" id="voice-file" accept="audio/*" class="w-full text-sm text-gray-400">
                <button id="mic-button" class="w-full mt-2 px-4 py-2 text-sm font-semibold rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white transition-colors duration-200">
                    ប្រើ Mic
                </button>
                <p id="voice-status" class="text-xs text-gray-500 mt-2">រង់ចាំ...</p>
                
                <div id="voice-volume-container" class="mt-3">
                    <label for="voice-volume" class="block text-xs font-medium mb-1">កម្រិតសំឡេងនិយាយ (Voice Volume)</label>
                    <input type="range" id="voice-volume" min="0.0" max="2.0" value="1.0" step="0.01" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="voice-vol-val" class="text-xs text-gray-500"> (100%)</span>
                </div>
                
                <div id="voice-delay-container" class="mt-3">
                    <label for="voice-delay" class="block text-xs font-medium mb-1">រយៈពេលពន្យាពេលចាប់ផ្តើម (វិ.)</label>
                    <input type="number" id="voice-delay" min="0" max="300" value="0" step="0.5" class="w-full px-2 py-1 bg-gray-800 border border-gray-700 rounded-lg text-white text-sm number-input">
                    <span id="voice-delay-val" class="text-xs text-gray-500"> (0.0 វិនាទី)</span>
                </div>
            </div>
            
            <!-- Music Input Card -->
            <div class="control-group">
                <label for="music-file" class="block text-sm font-medium mb-2 text-white">ភ្លេងផ្ទៃខាងក្រោយ (Music)</label>
                <input type="file" id="music-file" accept="audio/*" class="w-full text-sm text-gray-400">
                <p id="music-status" class="text-xs text-gray-500 mt-2">រង់ចាំ...</p>

                <div class="mt-3">
                    <label for="music-volume" class="block text-xs font-medium mb-1">កម្រិតសំឡេងភ្លេងគោល (Master Music Volume)</label>
                    <input type="range" id="music-volume" min="-30" max="0" value="-10" step="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="music-vol-val" class="text-xs text-gray-500">(-10 dB)</span>
                </div>
            </div>
        </div>
        
        <!-- --- 2. EQUALIZER SECTION --- -->
        <div class="border-t border-gray-700 pt-4 mb-6">
            <h2 class="text-xl font-semibold text-indigo-400 mb-3 border-b border-gray-700 pb-2">២. ការកែសំឡេង Equalizer (EQ)</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                
                <!-- Voice EQ Controls -->
                <div class="control-group">
                    <h3 class="text-sm font-bold text-indigo-400 mb-3">សំឡេងនិយាយ (Voice EQ)</h3>
                    
                    <label for="voice-eq-preset" class="block text-xs font-medium mb-2">Preset របស់ EQ</label>
                    <select id="voice-eq-preset" class="w-full px-3 py-2 text-sm bg-gray-800 border border-gray-700 rounded-lg text-white mb-4">
                        <option value="flat">Flat (ធម្មតា)</option>
                        <option value="normal">Normal</option>
                        <option value="rock">Rock</option>
                        <option value="pop">Pop</option>
                        <option value="hiphop">Hip Hop</option>
                        <option value="classical">Classical</option>
                        <option value="dance">Dance</option>
                        <option value="jazz">Jazz</option>
                        <option value="heavymetal">Heavy Metal</option>
                        <option value="folk">Folk</option>
                        <option value="custom">Custom (កែតម្រូវដោយខ្លួនឯង)</option>
                    </select>

                    <div class="flex justify-between items-end gap-3">
                        <!-- Low -->
                        <div class="flex-1">
                            <input type="range" id="voice-eq-low" min="-12" max="12" value="0" step="1" class="w-full eq-slider">
                            <span class="eq-label">ទាប (150Hz)</span>
                        </div>
                        <!-- Mid -->
                        <div class="flex-1">
                            <input type="range" id="voice-eq-mid" min="-12" max="12" value="0" step="1" class="w-full eq-slider">
                            <span class="eq-label">កណ្តាល (1kHz)</span>
                        </div>
                        <!-- High -->
                        <div class="flex-1">
                            <input type="range" id="voice-eq-high" min="-12" max="12" value="0" step="1" class="w-full eq-slider">
                            <span class="eq-label">ខ្ពស់ (4kHz)</span>
                        </div>
                    </div>
                </div>

                <!-- Music EQ Controls -->
                <div class="control-group">
                    <h3 class="text-sm font-bold text-green-400 mb-3">ភ្លេងផ្ទៃខាងក្រោយ (Music EQ)</h3>
                    
                    <label for="music-eq-preset" class="block text-xs font-medium mb-2">Preset របស់ EQ</label>
                    <select id="music-eq-preset" class="w-full px-3 py-2 text-sm bg-gray-800 border border-gray-700 rounded-lg text-white mb-4">
                        <option value="flat">Flat (ធម្មតា)</option>
                        <option value="normal">Normal</option>
                        <option value="rock">Rock</option>
                        <option value="pop">Pop</option>
                        <option value="hiphop">Hip Hop</option>
                        <option value="classical">Classical</option>
                        <option value="dance">Dance</option>
                        <option value="jazz">Jazz</option>
                        <option value="heavymetal">Heavy Metal</option>
                        <option value="folk">Folk</option>
                        <option value="custom">Custom (កែតម្រូវដោយខ្លួនឯង)</option>
                    </select>

                    <div class="flex justify-between items-end gap-3">
                        <!-- Low -->
                        <div class="flex-1">
                            <input type="range" id="music-eq-low" min="-12" max="12" value="0" step="1" class="w-full eq-slider">
                            <span class="eq-label">ទាប (150Hz)</span>
                        </div>
                        <!-- Mid -->
                        <div class="flex-1">
                            <input type="range" id="music-eq-mid" min="-12" max="12" value="0" step="1" class="w-full eq-slider">
                            <span class="eq-label">កណ្តាល (1kHz)</span>
                        </div>
                        <!-- High -->
                        <div class="flex-1">
                            <input type="range" id="music-eq-high" min="-12" max="12" value="0" step="1" class="w-full eq-slider">
                            <span class="eq-label">ខ្ពស់ (4kHz)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- --- 3. DUCKING PARAMETERS SECTION (2-Column Grid for Neatness) --- -->
        <h2 class="text-xl font-semibold text-indigo-400 mb-4 border-t border-gray-700 pt-4 border-b pb-2">៣. ការកំណត់ Ducking (បន្ថយសំឡេង) និង លំហ (Echo)</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            
            <!-- Column 1: Threshold & Ducking Level -->
            <div class="space-y-4">
                <div class="control-group">
                    <label for="ducking-threshold" class="block text-sm font-medium mb-1">កម្រិតចាប់សំឡេងនិយាយ (Threshold)</label>
                    <input type="range" id="ducking-threshold" min="0.005" max="0.05" value="0.015" step="0.001" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="threshold-val" class="text-xs text-gray-500"> (0.015)</span>
                </div>
                
                <div class="control-group">
                    <label for="ducking-level" class="block text-sm font-medium mb-1">កម្រិតបន្ថយសំឡេងភ្លេង (ពេលនិយាយ)</label>
                    <input type="range" id="ducking-level" min="-60" max="-10" value="-25" step="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="ducking-level-val" class="text-xs text-gray-500">(-25 dB)</span>
                </div>
            </div>

            <!-- Column 2: Ramp Time & Echo Level -->
            <div class="space-y-4">
                <div class="control-group">
                    <label for="ramp-time" class="block text-sm font-medium mb-1">ល្បឿនឡើង/ចុះសំឡេង (Ramp Time)</label>
                    <input type="range" id="ramp-time" min="0.05" max="1.0" value="0.2" step="0.05" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="ramp-time-val" class="text-xs text-gray-500">(0.20 វិនាទី)</span>
                </div>
                
                <div class="control-group">
                    <label for="echo-level" class="block text-sm font-medium mb-1">កម្រិត Echo/Reverb របស់សំឡេងនិយាយ</label>
                    <input type="range" id="echo-level" min="0.0" max="1.0" value="0.3" step="0.05" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="echo-level-val" class="text-xs text-gray-500"> (30%)</span>
                </div>
            </div>
        </div>

        <!-- --- 4. PITCH SHIFT SECTION (Full Width) --- -->
        <div class="control-group mb-6 border-t border-gray-700 pt-4">
            <h2 class="text-xl font-semibold text-indigo-400 mb-3 border-b border-gray-700 pb-2">៤. ការកែសំឡេង Pitch Shift (ផ្លាស់ប្តូរសំនៀង)</h2>
            <div id="pitch-presets" class="flex flex-wrap gap-2 mb-3">
                <button data-pitch="male" class="preset-btn text-xs py-1 px-3 rounded-lg hover:ring-2 ring-blue-500">បុរស (Male)</button>
                <button data-pitch="female" class="preset-btn text-xs py-1 px-3 rounded-lg hover:ring-2 ring-pink-500">ស្រ្តី (Female)</button>
                <button data-pitch="child" class="preset-btn text-xs py-1 px-3 rounded-lg hover:ring-2 ring-yellow-500">ក្មេង (Child)</button>
                <button data-pitch="elderly" class="preset-btn text-xs py-1 px-3 rounded-lg hover:ring-2 ring-purple-500">ចាស់ (Elderly)</button>
                <button data-pitch="reset" class="preset-btn text-xs py-1 px-3 rounded-lg hover:ring-2 ring-gray-500">ធម្មតា (Reset)</button>
            </div>
            <input type="range" id="pitch-input" min="-12" max="12" value="0" step="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            <span id="pitch-val" class="text-xs text-gray-500 mt-1 block"> (0 Semitones - ធម្មតា)</span>
        </div>

        <!-- --- 5. STATUS & PROGRESS --- -->
        <div class="flex justify-center items-center mb-6 border-t border-gray-700 pt-4">
            <span id="status-display" class="status-pill status-idle w-full">
                សូមផ្ទុកឯកសារ
            </span>
        </div>

        <div class="space-y-3 mb-8">
            <div id="music-progress-container">
                <label class="block text-sm font-medium flex justify-between">
                    <span>ភ្លេងផ្ទៃខាងក្រោយ</span>
                    <span id="music-time" class="text-xs text-gray-400">0:00 / 0:00</span>
                </label>
                <div class="h-2 w-full bg-gray-600 rounded-full overflow-hidden">
                    <div id="music-progress-bar" class="h-2 bg-green-500 transition-all duration-100 ease-linear" style="width: 0%;"></div>
                </div>
            </div>
            <div id="voice-progress-container">
                <label class="block text-sm font-medium flex justify-between">
                    <span>សំឡេងនិយាយ</span>
                    <span id="voice-time" class="text-xs text-gray-400">0:00 / 0:00</span>
                </label>
                <div class="h-2 w-full bg-gray-600 rounded-full overflow-hidden">
                    <div class="h-2 w-full bg-gray-600 rounded-full overflow-hidden">
                        <div id="voice-progress-bar" class="h-2 bg-blue-500 transition-all duration-100 ease-linear" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
        </div>


        <!-- --- 6. ACTION BUTTONS --- -->
        <button id="toggle-button" class="w-full py-3 px-4 text-lg font-semibold rounded-xl bg-gray-600 text-gray-400 cursor-not-allowed" disabled>
            រង់ចាំឯកសារ...
        </button>

        <div id="recording-controls" class="mt-4 flex space-x-4">
            <button id="record-button" class="flex-1 py-3 px-4 font-semibold rounded-xl bg-red-800 hover:bg-red-700 text-white transition-colors duration-200 shadow-md shadow-red-900/50" disabled>
                <span id="record-text">កត់ត្រា (Record)</span>
            </button>
            <button id="download-button" class="flex-1 py-3 px-4 font-semibold rounded-xl bg-blue-600 hover:bg-blue-700 text-white transition-colors duration-200 shadow-md shadow-blue-900/50" disabled>
                ទាញយក (Download)
            </button>
        </div>
        
    </div>

    <script>
        // Get references to DOM elements
        const toggleButton = document.getElementById('toggle-button');
        const recordButton = document.getElementById('record-button');
        const downloadButton = document.getElementById('download-button');
        const statusDisplay = document.getElementById('status-display');
        const voiceFileInput = document.getElementById('voice-file');
        const musicFileInput = document.getElementById('music-file');
        const micButton = document.getElementById('mic-button'); 
        const voiceStatus = document.getElementById('voice-status');
        const musicStatus = document.getElementById('music-status');
        const voiceDelayInput = document.getElementById('voice-delay');
        const voiceDelayVal = document.getElementById('voice-delay-val');
        const voiceDelayContainer = document.getElementById('voice-delay-container');
        
        // Volume and Ducking Controls
        const voiceVolumeInput = document.getElementById('voice-volume');
        const voiceVolVal = document.getElementById('voice-vol-val');
        const musicVolumeInput = document.getElementById('music-volume');
        const musicVolVal = document.getElementById('music-vol-val');
        const thresholdInput = document.getElementById('ducking-threshold');
        const thresholdVal = document.getElementById('threshold-val');
        const duckingLevelInput = document.getElementById('ducking-level');
        const duckingLevelVal = document.getElementById('ducking-level-val');
        const rampTimeInput = document.getElementById('ramp-time');
        const rampTimeVal = document.getElementById('ramp-time-val');
        const echoLevelInput = document.getElementById('echo-level'); 
        const echoLevelVal = document.getElementById('echo-level-val'); 
        
        // Pitch Controls
        const pitchInput = document.getElementById('pitch-input');
        const pitchVal = document.getElementById('pitch-val');
        const presetButtons = document.querySelectorAll('.preset-btn'); 

        // EQ Controls
        const voiceEQPreset = document.getElementById('voice-eq-preset');
        const voiceEQLow = document.getElementById('voice-eq-low');
        const voiceEQMid = document.getElementById('voice-eq-mid');
        const voiceEQHigh = document.getElementById('voice-eq-high');

        const musicEQPreset = document.getElementById('music-eq-preset');
        const musicEQLow = document.getElementById('music-eq-low');
        const musicEQMid = document.getElementById('music-eq-mid');
        const musicEQHigh = document.getElementById('music-eq-high');


        // Progress Bar References
        const musicProgressBar = document.getElementById('music-progress-bar'); 
        const voiceProgressBar = document.getElementById('voice-progress-bar'); 
        const musicTimeDisplay = document.getElementById('music-time'); 
        const voiceTimeDisplay = document.getElementById('voice-time'); 

        // --- PWA Setup Logic ---
        
        function setupPWA() {
            const manifestData = {
                "name": "Audio Ducking & Pitch Tool",
                "short_name": "Ducking Tool",
                "description": "ឧបករណ៍ Audio Ducking និង Pitch Shift សម្រាប់ការផលិតសំឡេង",
                "start_url": "./audio_ducking_tool.html", 
                "display": "standalone",
                "background_color": "#0d1117",
                "theme_color": "#161b22",
                "icons": [
                    {
                        "src": "https://placehold.co/192x192/161b22/c9d1d9?text=DA",
                        "sizes": "192x192",
                        "type": "image/png"
                    },
                    {
                        "src": "https://placehold.co/512x512/161b22/c9d1d9?text=DA",
                        "sizes": "512x512",
                        "type": "image/png"
                    }
                ]
            };
            try {
                const manifestBlob = new Blob([JSON.stringify(manifestData)], { type: 'application/json' });
                const manifestUrl = URL.createObjectURL(manifestBlob);
                document.getElementById('pwa-manifest-link').href = manifestUrl;
                console.log('PWA Manifest URL successfully created and linked.');
            } catch (e) {
                console.warn("PWA Manifest injection failed, possibly due to unsupported Blob URL in environment.", e);
            }
            if ('serviceWorker' in navigator) {
                 console.log("Service Worker registration skipped due to environment security limitations.");
            }
        }

        window.addEventListener('load', setupPWA);


        // --- Audio State Variables ---
        let isRunning = false;
        let audioContext;
        let voiceBuffer = null; 
        let isMicActive = false; 
        let micStream = null; 
        let musicBuffer = null;
        
        let voiceSource = null;
        let musicSource = null;
        let analyserNode = null;
        let musicGainNode = null;
        let voiceGainNode = null; 
        let pitchFilterNode = null; 
        let audioLoopId; 
        
        // --- Echo/Reverb Nodes ---
        let echoDelayNode = null;
        let echoFeedbackGainNode = null;
        let echoWetGainNode = null;
        const DEFAULT_ECHO_DELAY = 0.4; 
        const DEFAULT_FEEDBACK = 0.5; 

        // --- EQ Nodes ---
        // 3-band EQ for Voice (LowShelf, Peaking, HighShelf)
        let voiceEQNodes = []; 
        // 3-band EQ for Music (LowShelf, Peaking, HighShelf)
        let musicEQNodes = []; 
        
        // --- Recording Variables ---
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let destinationStream = null; 
        let startTime = 0;
        let recordingStartTime = 0; 

        // Ducking parameters (initial values from UI)
        let VOICE_START_DELAY = parseFloat(voiceDelayInput.value); 
        let NORMAL_VOICE_VOLUME = parseFloat(voiceVolumeInput.value); 
        let NORMAL_MUSIC_VOLUME = parseFloat(musicVolumeInput.value); 
        let DUCKING_THRESHOLD = parseFloat(thresholdInput.value); 
        let DUCKED_MUSIC_VOLUME = parseFloat(duckingLevelInput.value); 
        let CURRENT_RAMP_TIME = parseFloat(rampTimeInput.value);
        let CURRENT_ECHO_LEVEL = parseFloat(echoLevelInput.value); 
        let CURRENT_PITCH_SHIFT = parseFloat(pitchInput.value); 
        
        // --- EQ Preset Data (Gain in dB for Low/Mid/High) ---
        const EQ_PRESETS = {
            flat: [0, 0, 0],
            normal: [3, 0, 1],
            rock: [5, -5, 5],
            pop: [-2, 4, 2],
            hiphop: [8, -4, 3],
            classical: [-3, 2, 4],
            dance: [6, 0, 3],
            jazz: [2, 0, 4],
            heavymetal: [4, -6, 6],
            folk: [0, 3, -2],
            custom: null // Use current slider values
        };

        // --- Utility Functions ---

        function dbToGain(db) {
            return Math.pow(10, db / 20);
        }
        
        function formatTime(seconds) {
            seconds = Math.max(0, seconds); 
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function applyPitchSimulation(pitchValue) {
            if (!pitchFilterNode || !audioContext) return;
            pitchFilterNode.type = 'peaking';
            pitchFilterNode.Q.setValueAtTime(1.0, audioContext.currentTime); 
            let targetGain = 0; 
            let targetFreq = 1000;
            if (pitchValue < 0) {
                targetFreq = 150 + (pitchValue * -10); 
                targetGain = Math.abs(pitchValue) * 0.5; 
                pitchFilterNode.Q.setValueAtTime(0.8, audioContext.currentTime); 
            } else if (pitchValue > 0) {
                targetFreq = 1500 + (pitchValue * 200);
                targetGain = pitchValue * 0.5; 
                pitchFilterNode.Q.setValueAtTime(1.5, audioContext.currentTime); 
            } else {
                targetFreq = 1000; 
                targetGain = 0;
            }
            targetGain = Math.min(6, targetGain); 
            pitchFilterNode.frequency.linearRampToValueAtTime(targetFreq, audioContext.currentTime + 0.1);
            pitchFilterNode.gain.linearRampToValueAtTime(targetGain, audioContext.currentTime + 0.1);
        }
        
        function applyEQSettings(eqNodes, lowGain, midGain, highGain) {
            if (eqNodes.length < 3) return;
            const now = audioContext.currentTime;
            
            // Node 0: Low Shelf (150 Hz)
            eqNodes[0].gain.linearRampToValueAtTime(lowGain, now + 0.05);

            // Node 1: Mid Peaking (1000 Hz)
            eqNodes[1].gain.linearRampToValueAtTime(midGain, now + 0.05);

            // Node 2: High Shelf (4000 Hz)
            eqNodes[2].gain.linearRampToValueAtTime(highGain, now + 0.05);
        }

        function handleEQUpdate(sourceType) {
            const isVoice = sourceType === 'voice';
            const presetSelect = isVoice ? voiceEQPreset : musicEQPreset;
            const lowInput = isVoice ? voiceEQLow : musicEQLow;
            const midInput = isVoice ? voiceEQMid : musicEQMid;
            const highInput = isVoice ? voiceEQHigh : musicEQHigh;
            const eqNodes = isVoice ? voiceEQNodes : musicEQNodes;

            const selectedPreset = presetSelect.value;

            if (selectedPreset === 'custom') {
                lowInput.disabled = false;
                midInput.disabled = false;
                highInput.disabled = false;

                const low = parseFloat(lowInput.value);
                const mid = parseFloat(midInput.value);
                const high = parseFloat(highInput.value);
                
                if (isRunning) applyEQSettings(eqNodes, low, mid, high);

            } else {
                const [low, mid, high] = EQ_PRESETS[selectedPreset];
                
                lowInput.value = low;
                midInput.value = mid;
                highInput.value = high;
                
                lowInput.disabled = true;
                midInput.disabled = true;
                highInput.disabled = true;

                if (isRunning) applyEQSettings(eqNodes, low, mid, high);
            }
        }

        function updateUIVolumes() {
            VOICE_START_DELAY = parseFloat(voiceDelayInput.value);
            NORMAL_VOICE_VOLUME = parseFloat(voiceVolumeInput.value);
            NORMAL_MUSIC_VOLUME = parseFloat(musicVolumeInput.value); 
            DUCKING_THRESHOLD = parseFloat(thresholdInput.value);
            DUCKED_MUSIC_VOLUME = parseFloat(duckingLevelInput.value);
            CURRENT_RAMP_TIME = parseFloat(rampTimeInput.value);
            CURRENT_ECHO_LEVEL = parseFloat(echoLevelInput.value);
            CURRENT_PITCH_SHIFT = parseFloat(pitchInput.value); 

            voiceDelayVal.textContent = ` (${VOICE_START_DELAY.toFixed(1)} វិនាទី)`;
            voiceVolVal.textContent = ` (${(NORMAL_VOICE_VOLUME * 100).toFixed(0)}%)`; 
            musicVolVal.textContent = `(${NORMAL_MUSIC_VOLUME} dB)`; 
            thresholdVal.textContent = ` (${DUCKING_THRESHOLD.toFixed(3)})`;
            duckingLevelVal.textContent = `(${DUCKED_MUSIC_VOLUME} dB)`;
            rampTimeVal.textContent = `(${CURRENT_RAMP_TIME.toFixed(2)} វិនាទី)`;
            echoLevelVal.textContent = ` (${(CURRENT_ECHO_LEVEL * 100).toFixed(0)}%)`;

            const pitchStatus = CURRENT_PITCH_SHIFT === 0 ? 'ធម្មតា' : CURRENT_PITCH_SHIFT > 0 ? 'ខ្ពស់' : 'ទាប';
            pitchVal.textContent = ` (${CURRENT_PITCH_SHIFT} Semitones - ${pitchStatus})`;

            if (voiceGainNode) { 
                 voiceGainNode.gain.linearRampToValueAtTime(NORMAL_VOICE_VOLUME, audioContext.currentTime + 0.05);
            }
            if (musicGainNode) {
                const targetGain = dbToGain(NORMAL_MUSIC_VOLUME);
                const currentTime = audioContext.currentTime;
                if (!isDucking && isRunning) {
                     musicGainNode.gain.linearRampToValueAtTime(targetGain, currentTime + 0.1);
                }
            }
            if (echoWetGainNode) {
                echoWetGainNode.gain.setValueAtTime(CURRENT_ECHO_LEVEL, audioContext.currentTime);
            }
            if (pitchFilterNode) {
                applyPitchSimulation(CURRENT_PITCH_SHIFT);
            }

            // Apply EQ changes
            handleEQUpdate('voice');
            handleEQUpdate('music');
        }

        // --- Event Listeners ---
        voiceDelayInput.addEventListener('input', updateUIVolumes); 
        voiceVolumeInput.addEventListener('input', updateUIVolumes); 
        musicVolumeInput.addEventListener('input', updateUIVolumes); 
        thresholdInput.addEventListener('input', updateUIVolumes);
        duckingLevelInput.addEventListener('input', updateUIVolumes);
        rampTimeInput.addEventListener('input', updateUIVolumes);
        echoLevelInput.addEventListener('input', updateUIVolumes); 
        pitchInput.addEventListener('input', updateUIVolumes); 

        // EQ Event Listeners
        voiceEQPreset.addEventListener('change', () => handleEQUpdate('voice'));
        voiceEQLow.addEventListener('input', () => { voiceEQPreset.value = 'custom'; handleEQUpdate('voice'); });
        voiceEQMid.addEventListener('input', () => { voiceEQPreset.value = 'custom'; handleEQUpdate('voice'); });
        voiceEQHigh.addEventListener('input', () => { voiceEQPreset.value = 'custom'; handleEQUpdate('voice'); });

        musicEQPreset.addEventListener('change', () => handleEQUpdate('music'));
        musicEQLow.addEventListener('input', () => { musicEQPreset.value = 'custom'; handleEQUpdate('music'); });
        musicEQMid.addEventListener('input', () => { musicEQPreset.value = 'custom'; handleEQUpdate('music'); });
        musicEQHigh.addEventListener('input', () => { musicEQPreset.value = 'custom'; handleEQUpdate('music'); });


        presetButtons.forEach(button => {
            button.addEventListener('click', () => {
                const preset = button.getAttribute('data-pitch');
                let pitchValue = 0;
                switch(preset) {
                    case 'male': pitchValue = -6; break;
                    case 'female': pitchValue = 2; break;
                    case 'child': pitchValue = 8; break;
                    case 'elderly': pitchValue = -10; break;
                    case 'reset': default: pitchValue = 0; break;
                }
                pitchInput.value = pitchValue;
                updateUIVolumes();
            });
        });
        
        // Initial UI update to set values and disable Custom EQ sliders
        handleEQUpdate('voice');
        handleEQUpdate('music');
        updateUIVolumes(); 

        // --- Microphone Setup ---

        async function setupMic() {
            if (isMicActive) return;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        autoGainControl: false, 
                        noiseSuppression: false, 
                        echoCancellation: false 
                    }
                });
                micStream = stream;
                isMicActive = true;
                voiceBuffer = null; 
                voiceFileInput.disabled = true;
                voiceDelayContainer.classList.add('hidden'); 
                micButton.textContent = 'បិទ Mic';
                micButton.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                micButton.classList.add('bg-gray-600', 'hover:bg-gray-700');
                voiceStatus.textContent = "Voice: ពី Microphone (Live)";
                voiceStatus.classList.add('text-green-500');
            } catch (error) {
                console.error("Microphone access denied or error:", error);
                voiceStatus.textContent = "បរាជ័យក្នុងការប្រើ Mic";
                voiceStatus.classList.remove('text-green-500');
                isMicActive = false;
            }
            updateReadyState();
        }

        function stopMic() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
            }
            isMicActive = false;
            micStream = null;
            voiceFileInput.disabled = false;
            voiceDelayContainer.classList.remove('hidden'); 
            micButton.textContent = 'ប្រើ Mic';
            micButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            micButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            voiceStatus.textContent = "រង់ចាំ...";
            voiceStatus.classList.remove('text-green-500');
            updateReadyState();
        }

        // --- File Loading and Decoding ---

        function updateReadyState() {
            const isReady = musicBuffer && (voiceBuffer || isMicActive); 
            if (isReady) {
                toggleButton.disabled = false;
                toggleButton.textContent = 'ចាប់ផ្តើម Audio Ducking';
                toggleButton.className = 'w-full py-3 px-4 text-lg font-semibold rounded-xl bg-green-600 hover:bg-green-700 text-white transition-colors duration-200 shadow-md shadow-green-900/50';
                recordButton.disabled = false;
                statusDisplay.className = 'status-pill status-ready w-full';
                statusDisplay.textContent = 'ឯកសារទាំងពីរបានផ្ទុករួចរាល់';
                if (musicBuffer) musicTimeDisplay.textContent = `0:00 / ${formatTime(musicBuffer.duration)}`;
                if (voiceBuffer) {
                    voiceTimeDisplay.textContent = `0:00 / ${formatTime(voiceBuffer.duration)}`;
                } else {
                    voiceTimeDisplay.textContent = `Live Mic`; 
                }
            } else {
                toggleButton.disabled = true;
                toggleButton.textContent = 'រង់ចាំឯកសារ...';
                toggleButton.className = 'w-full py-3 px-4 text-lg font-semibold rounded-xl bg-gray-600 text-gray-400 cursor-not-allowed';
                recordButton.disabled = true;
                statusDisplay.className = 'status-pill status-idle w-full';
                statusDisplay.textContent = 'សូមផ្ទុកឯកសារភ្លេង និងប្រភពសំឡេងនិយាយ';
                if (!isMicActive && !voiceBuffer) {
                    voiceStatus.textContent = "រង់ចាំ...";
                    voiceStatus.classList.remove('text-green-500');
                }
            }
            downloadButton.disabled = recordedChunks.length === 0;
            downloadButton.textContent = recordedChunks.length > 0 ? 'ទាញយកលទ្ធផល' : 'ទាញយក (Download)';
        }

        async function loadFile(file, statusElement) {
            if (!file) {
                if (statusElement === voiceStatus) voiceBuffer = null;
                if (statusElement === musicStatus) musicBuffer = null;
                statusElement.textContent = "មិនទាន់មានឯកសារ";
                statusElement.classList.remove('text-green-500');
                updateReadyState();
                return;
            }
            statusElement.textContent = `កំពុងផ្ទុកឯកសារ៖ ${file.name}...`;
            statusElement.classList.remove('text-green-500');
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const arrayBuffer = e.target.result;
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    if (statusElement === voiceStatus) {
                        voiceBuffer = audioBuffer;
                        statusElement.textContent = `Voice: បានផ្ទុក (${(audioBuffer.duration).toFixed(1)} វិ. )`;
                        if (isMicActive) stopMic(); 
                    } else {
                        musicBuffer = audioBuffer;
                        statusElement.textContent = `Music: បានផ្ទុក (${(audioBuffer.duration).toFixed(1)} វិ. )`;
                    }
                    statusElement.classList.add('text-green-500');
                } catch (error) {
                    console.error("Error decoding audio data:", error);
                    statusElement.textContent = `បរាជ័យក្នុងការ decode៖ ${file.name}`;
                    if (statusElement === voiceStatus) voiceBuffer = null; 
                    if (statusElement === musicStatus) musicBuffer = null; 
                }
                updateReadyState();
            };
            reader.onerror = (error) => {
                console.error("Error reading file:", error);
                statusElement.textContent = `បរាជ័យក្នុងការអានឯកសារ៖ ${file.name}`;
                if (statusElement === voiceStatus) voiceBuffer = null; 
                if (statusElement === musicStatus) musicBuffer = null; 
                updateReadyState();
            };
            reader.readAsArrayBuffer(file);
        }

        voiceFileInput.addEventListener('change', (e) => {
            if (isMicActive) stopMic(); 
            loadFile(e.target.files[0], voiceStatus);
        });
        musicFileInput.addEventListener('change', (e) => loadFile(e.target.files[0], musicStatus));

        micButton.addEventListener('click', () => {
            if (isMicActive) {
                stopMic();
            } else {
                setupMic();
                voiceFileInput.value = ''; 
            }
        });

        // --- Audio Graph Setup and Processing ---

        function createEQNodes(bandFrequencies) {
            const nodes = [];
            // Node 0: Low Shelf (150 Hz)
            const lowShelf = audioContext.createBiquadFilter();
            lowShelf.type = 'lowshelf';
            lowShelf.frequency.setValueAtTime(bandFrequencies[0], audioContext.currentTime);
            nodes.push(lowShelf);
            
            // Node 1: Mid Peaking (1000 Hz)
            const peaking = audioContext.createBiquadFilter();
            peaking.type = 'peaking';
            peaking.frequency.setValueAtTime(bandFrequencies[1], audioContext.currentTime);
            peaking.Q.setValueAtTime(1.0, audioContext.currentTime); // Fixed Q for simplicity
            nodes.push(peaking);

            // Node 2: High Shelf (4000 Hz)
            const highShelf = audioContext.createBiquadFilter();
            highShelf.type = 'highshelf';
            highShelf.frequency.setValueAtTime(bandFrequencies[2], audioContext.currentTime);
            nodes.push(highShelf);
            
            return nodes;
        }

        function setupAudioGraph() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            destinationStream = audioContext.createMediaStreamDestination();
            
            // --- 1. Music Track Setup ---
            musicSource = audioContext.createBufferSource();
            musicSource.buffer = musicBuffer;
            musicSource.loop = true; 

            musicGainNode = audioContext.createGain();
            musicGainNode.gain.setValueAtTime(dbToGain(NORMAL_MUSIC_VOLUME), audioContext.currentTime);

            // Create Music EQ Nodes (Low, Mid, High frequencies)
            musicEQNodes = createEQNodes([150, 1000, 4000]); 

            // Connection: Music Source -> Music Gain -> Music EQ (3 Nodes in series) -> Destination
            musicSource.connect(musicGainNode);
            let musicNode = musicGainNode;
            
            musicEQNodes.forEach((node) => {
                musicNode.connect(node);
                musicNode = node;
            });
            
            musicNode.connect(audioContext.destination);
            musicNode.connect(destinationStream);
            
            // Reapply EQ settings on node creation
            handleEQUpdate('music'); 

            // --- 2. Voice Track Setup ---
            if (isMicActive && micStream) {
                voiceSource = audioContext.createMediaStreamSource(micStream);
            } else if (voiceBuffer) {
                voiceSource = audioContext.createBufferSource();
                voiceSource.buffer = voiceBuffer;
                voiceSource.onended = () => {
                    console.log("Voice track finished. Music and processing continue until manual stop.");
                };
            } else {
                return;
            }
            
            voiceGainNode = audioContext.createGain();
            voiceGainNode.gain.setValueAtTime(NORMAL_VOICE_VOLUME, audioContext.currentTime); 

            // Create Voice EQ Nodes
            voiceEQNodes = createEQNodes([150, 1000, 4000]); 
            
            // Voice EQ Preset application
            handleEQUpdate('voice'); 

            // 3. Pitch Filter (Peaking Filter for simulation)
            pitchFilterNode = audioContext.createBiquadFilter();
            applyPitchSimulation(CURRENT_PITCH_SHIFT); 
            
            // 4. Analyser (Attached to the voice signal BEFORE Echo)
            analyserNode = audioContext.createAnalyser();
            analyserNode.fftSize = 512;
            
            // Voice Path: Source -> Voice Gain -> Voice EQ (series) -> Pitch Filter -> Analyser
            voiceSource.connect(voiceGainNode); 
            
            let voiceNode = voiceGainNode;
            voiceEQNodes.forEach((node) => {
                voiceNode.connect(node);
                voiceNode = node;
            });

            voiceNode.connect(pitchFilterNode); 
            pitchFilterNode.connect(analyserNode);

            // 5. Echo/Reverb Setup (WET signal)
            echoDelayNode = audioContext.createDelay(1.0); 
            echoDelayNode.delayTime.setValueAtTime(DEFAULT_ECHO_DELAY, audioContext.currentTime);
            echoFeedbackGainNode = audioContext.createGain();
            echoFeedbackGainNode.gain.setValueAtTime(DEFAULT_FEEDBACK, audioContext.currentTime);
            echoWetGainNode = audioContext.createGain();
            echoWetGainNode.gain.setValueAtTime(CURRENT_ECHO_LEVEL, audioContext.currentTime);

            // Connect Echo Path: Pitch Filter -> Delay -> Feedback Loop -> Wet Gain -> Destination
            pitchFilterNode.connect(echoDelayNode); 
            echoDelayNode.connect(echoFeedbackGainNode);
            echoFeedbackGainNode.connect(echoDelayNode);
            echoDelayNode.connect(echoWetGainNode);
            echoWetGainNode.connect(audioContext.destination);
            echoWetGainNode.connect(destinationStream); 

            // Connect DRY Voice Signal: Analyser -> Destination
            analyserNode.connect(audioContext.destination);
            analyserNode.connect(destinationStream);
        }

        let isDucking = false;
        
        function processAudio() {
            if (!analyserNode) return;

            const bufferLength = analyserNode.fftSize;
            const dataArray = new Float32Array(bufferLength);
            analyserNode.getFloatTimeDomainData(dataArray);

            let sumOfSquares = 0;
            for (let i = 0; i < bufferLength; i++) {
                sumOfSquares += dataArray[i] * dataArray[i];
            }
            const rms = Math.sqrt(sumOfSquares / bufferLength);

            const now = audioContext.currentTime;
            
            // --- PROGRESS TRACKING LOGIC ---
            if (audioContext.state === 'running' && musicBuffer && startTime !== 0) {
                const currentTime = audioContext.currentTime - startTime;
                
                // Music Progress (Looping)
                const musicDuration = musicBuffer.duration;
                const currentMusicTime = currentTime % musicDuration; 
                const musicProgressPercent = (currentMusicTime / musicDuration) * 100;
                musicProgressBar.style.width = `${musicProgressPercent.toFixed(1)}%`;
                musicTimeDisplay.textContent = `${formatTime(currentMusicTime)} / ${formatTime(musicDuration)}`;

                // Voice Progress (Only for File Buffer)
                if (voiceBuffer && !isMicActive) {
                    const voiceDuration = voiceBuffer.duration;
                    const delay = VOICE_START_DELAY;
                    let currentVoiceTime = 0;
                    let voiceProgressPercent = 0;
                    if (currentTime < delay) {
                        currentVoiceTime = 0;
                        voiceProgressPercent = 0;
                        const remainingDelay = delay - currentTime;
                        if (!isRecording) {
                            statusDisplay.textContent = `កំពុងលេង (សំឡេងនិយាយចាប់ផ្តើមក្នុង ${formatTime(remainingDelay)})`;
                        }
                    } else if (currentTime >= delay && currentTime < delay + voiceDuration) {
                        currentVoiceTime = currentTime - delay;
                        voiceProgressPercent = (currentVoiceTime / voiceDuration) * 100;
                    } else {
                        currentVoiceTime = voiceDuration;
                        voiceProgressPercent = 100;
                    }
                    voiceProgressBar.style.width = `${voiceProgressPercent.toFixed(1)}%`;
                    voiceTimeDisplay.textContent = `${formatTime(currentVoiceTime)} / ${formatTime(voiceDuration)}`;
                } else {
                    voiceProgressBar.style.width = '100%'; 
                    voiceTimeDisplay.textContent = `Live Mic`; 
                }
            }
            // --- END PROGRESS TRACKING ---

            // 1. Ducking Logic
            const voiceReadyToDuck = isMicActive || (audioContext.currentTime - startTime >= VOICE_START_DELAY);

            if (voiceReadyToDuck) { 
                const rampTime = CURRENT_RAMP_TIME; 
                let recordingTimeText = '';
                if (isRecording) {
                    const elapsed = audioContext.currentTime - recordingStartTime;
                    recordingTimeText = ` (${formatTime(elapsed)})`;
                }
                
                if (rms > DUCKING_THRESHOLD) {
                    // Voice detected: Duck the music
                    if (!isDucking) {
                        musicGainNode.gain.linearRampToValueAtTime(dbToGain(DUCKED_MUSIC_VOLUME), now + rampTime);
                        statusDisplay.className = `status-pill ${isRecording ? 'status-recording' : 'status-ducking'} w-full`;
                        statusDisplay.textContent = `កំពុងបន្ថយសំឡេង (និយាយ...) ${isRecording ? '[កត់ត្រា]' : ''}${recordingTimeText}`;
                        isDucking = true;
                    }
                } else {
                    // No voice detected: Bring music back up
                    if (isDucking) {
                        musicGainNode.gain.linearRampToValueAtTime(dbToGain(NORMAL_MUSIC_VOLUME), now + rampTime);
                        isDucking = false;
                    }
                    
                    if (!isDucking || isRecording) {
                         statusDisplay.className = `status-pill ${isRecording ? 'status-recording' : 'status-playing'} w-full`;
                         statusDisplay.textContent = `កំពុងលេង (លឺធម្មតា) ${isRecording ? '[កត់ត្រា]' : ''}${recordingTimeText}`;
                    }
                }
            }
            
            audioLoopId = requestAnimationFrame(processAudio);
        }

        // --- Recording Functions (Unchanged) ---

        function startRecording() {
            if (!destinationStream) {
                console.error("Cannot start recording before playback begins (destination stream not initialized).");
                return;
            }
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(destinationStream.stream, { 
                mimeType: 'audio/webm;codecs=opus' 
            });
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            mediaRecorder.onstop = () => {
                isRecording = false;
                recordingStartTime = 0; 
                updateReadyState();
                if (!isRunning) {
                     statusDisplay.className = 'status-pill status-ready w-full';
                     statusDisplay.textContent = 'បានបញ្ឈប់ - រួចរាល់សម្រាប់ទាញយក';
                }
                document.getElementById('record-text').textContent = 'កត់ត្រា (Record)';
            };
            mediaRecorder.start();
            isRecording = true;
            recordingStartTime = audioContext.currentTime; 
            document.getElementById('record-text').textContent = 'កំពុងកត់ត្រា...';
            updateReadyState();
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
        }

        function downloadRecording() {
            if (recordedChunks.length === 0) {
                console.error("No recorded audio data to download.");
                return;
            }
            const blob = new Blob(recordedChunks, { type: 'audio/webm;codecs=opus' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            a.href = url;
            a.download = `audio_ducking_output_${new Date().toISOString()}.webm`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // --- Start/Stop Functions (Unchanged) ---

        function startDucking() {
            if (!musicBuffer || (!voiceBuffer && !isMicActive)) {
                console.error("Music file must be loaded, and a voice source (file or mic) selected.");
                return;
            }
            try {
                if (audioContext && audioContext.state !== 'running') {
                    audioContext.resume();
                }
                setupAudioGraph();
                startTime = audioContext.currentTime;
                musicSource.start(startTime);
                if (voiceBuffer && !isMicActive) {
                    const voiceStartTime = startTime + VOICE_START_DELAY;
                    voiceSource.start(voiceStartTime);
                }
                audioLoopId = requestAnimationFrame(processAudio);
                isRunning = true;
                toggleButton.textContent = 'បញ្ឈប់ Audio Ducking';
                toggleButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                toggleButton.classList.add('bg-red-600', 'hover:bg-red-700');
                recordButton.disabled = false;
                statusDisplay.className = 'status-pill status-playing w-full';
                statusDisplay.textContent = 'កំពុងលេង (លឺធម្មតា)';
            } catch (error) {
                console.error("Error starting audio playback:", error);
                statusDisplay.className = 'status-pill bg-red-800 text-white w-full';
                statusDisplay.textContent = 'បរាជ័យ៖ មានកំហុសក្នុងការលេងសំឡេង។';
            }
        }

        function stopDucking() {
            cancelAnimationFrame(audioLoopId);
            
            if (voiceSource && !isMicActive) { 
                try { voiceSource.stop(); } catch (e) { /* Already stopped */ }
            }
            if (voiceSource) { voiceSource.disconnect(); }
            if (musicSource) {
                try { musicSource.stop(); } catch (e) { /* Already stopped */ }
                musicSource.disconnect();
            }
            
            // Disconnect all nodes
            if (analyserNode) analyserNode.disconnect();
            if (musicGainNode) musicGainNode.disconnect();
            if (voiceGainNode) voiceGainNode.disconnect(); 
            if (pitchFilterNode) pitchFilterNode.disconnect();
            if (echoDelayNode) echoDelayNode.disconnect();
            if (echoFeedbackGainNode) echoFeedbackGainNode.disconnect();
            if (echoWetGainNode) echoWetGainNode.disconnect();
            if (destinationStream) destinationStream.disconnect();

            [...voiceEQNodes, ...musicEQNodes].forEach(node => node.disconnect());
            voiceEQNodes = [];
            musicEQNodes = [];

            if (isRecording) {
                stopRecording();
            }
            
            if (isMicActive) {
                stopMic(); 
            }
            
            isRunning = false;
            startTime = 0; 
            updateReadyState(); 
            
            musicProgressBar.style.width = '0%';
            voiceProgressBar.style.width = '0%';
            if (musicBuffer) musicTimeDisplay.textContent = `0:00 / ${formatTime(musicBuffer.duration)}`;
            if (voiceBuffer) voiceTimeDisplay.textContent = `0:00 / ${formatTime(voiceBuffer.duration)}`;
            else if (isMicActive) voiceTimeDisplay.textContent = `Live Mic`;
        }

        toggleButton.addEventListener('click', () => {
            if (isRunning) {
                stopDucking();
            } else {
                startDucking();
            }
        });

        recordButton.addEventListener('click', () => {
            if (!isRunning) {
                startDucking();
                setTimeout(startRecording, 50); 
            } else {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            }
        });

        downloadButton.addEventListener('click', downloadRecording);
        
    </script>
</body>
</html>
