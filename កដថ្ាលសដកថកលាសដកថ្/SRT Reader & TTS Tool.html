import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, Volume2, FileText, Trash2, Download, SkipForward, Upload, FileUp, Languages, Clock, Mic, Loader2 } from 'lucide-react';

const firebaseConfig = JSON.parse(__firebase_config);
const appId = typeof __app_id !== 'undefined' ? __app_id : 'srt-reader-tts';

const VOICES = [
  { id: 'Kore', name: 'Kore (ស្រទន់ - ស្រី)' },
  { id: 'Zephyr', name: 'Zephyr (បុរស)' },
  { id: 'Puck', name: 'Puck (កំប្លែង)' },
  { id: 'Charon', name: 'Charon (ចាស់ទុំ)' }
];

export default function App() {
  const [srtInput, setSrtInput] = useState('');
  const [parsedItems, setParsedItems] = useState([]);
  const [selectedVoice, setSelectedVoice] = useState('Kore');
  const [isProcessing, setIsProcessing] = useState(false);
  const [currentProcessIndex, setCurrentProcessIndex] = useState(-1);
  const [mergedAudioUrl, setMergedAudioUrl] = useState(null);
  const audioRef = useRef(null);
  const fileInputRef = useRef(null);

  const timeToSeconds = (timeStr) => {
    if (!timeStr) return 0;
    const [hms, ms] = timeStr.split(',');
    const [h, m, s] = hms.split(':').map(Number);
    return h * 3600 + m * 60 + s + parseInt(ms) / 1000;
  };

  const parseSRT = (data) => {
    const regex = /(\d+)\r?\n(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})\r?\n([\s\S]*?)(?=\r?\n\r?\n|\r?\n*$)/g;
    const items = [];
    let match;
    while ((match = regex.exec(data)) !== null) {
      items.push({
        id: match[1],
        startTime: timeToSeconds(match[2]),
        endTime: timeToSeconds(match[3]),
        startStr: match[2],
        endStr: match[3],
        text: match[4].replace(/\r?\n/g, ' ').trim(),
      });
    }
    if (items.length > 0) {
      setParsedItems(items);
      setMergedAudioUrl(null);
    } else {
      alert("ទម្រង់ឯកសារ SRT មិនត្រឹមត្រូវ!");
    }
  };

  const handleFileUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const content = e.target.result;
        setSrtInput(content);
        parseSRT(content);
      };
      reader.readAsText(file);
    }
  };

  // Improved fetch with retry logic (Exponential Backoff)
  const fetchWithRetry = async (text, duration, voice, retries = 5) => {
    const apiKey = "";
    const prompt = `អានអត្ថបទនេះជាភាសាខ្មែរក្នុងរយៈពេល ${duration} វិនាទី៖ "${text}"`;
    
    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              responseModalities: ["AUDIO"],
              speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voice } } }
            }
          })
        });

        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        
        const result = await response.json();
        const inlineData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData;
        
        if (inlineData && inlineData.data) {
          return inlineData;
        }
        
        throw new Error("No audio data in response");
      } catch (err) {
        if (i === retries - 1) throw err;
        const delay = Math.pow(2, i) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  };

  const fetchAudioSegment = async (text, duration, voice) => {
    const inlineData = await fetchWithRetry(text, duration, voice);
    const audioData = inlineData.data;
    const sampleRateStr = inlineData.mimeType.match(/rate=(\d+)/)?.[1] || "24000";
    const sampleRate = parseInt(sampleRateStr);
    
    const binaryString = atob(audioData);
    const len = binaryString.length;
    const bytes = new Int16Array(len / 2);
    for (let i = 0; i < len; i += 2) {
      bytes[i / 2] = (binaryString.charCodeAt(i + 1) << 8) | binaryString.charCodeAt(i);
    }
    return { bytes, sampleRate };
  };

  const createSilenceBuffer = (seconds, sampleRate) => {
    return new Int16Array(Math.floor(seconds * sampleRate));
  };

  const pcmToWav = (pcmData, sampleRate) => {
    const buffer = new ArrayBuffer(44 + pcmData.length * 2);
    const view = new DataView(buffer);
    const writeString = (offset, string) => {
      for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
    };
    writeString(0, 'RIFF');
    view.setUint32(4, 32 + pcmData.length * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, pcmData.length * 2, true);
    let offset = 44;
    for (let i = 0; i < pcmData.length; i++, offset += 2) view.setInt16(offset, pcmData[i], true);
    return new Blob([buffer], { type: 'audio/wav' });
  };

  const processFullAudio = async () => {
    if (parsedItems.length === 0) return;
    setIsProcessing(true);
    setMergedAudioUrl(null);
    
    let allAudioChunks = [];
    let currentTimeline = 0;
    const targetSampleRate = 24000; 

    try {
      for (let i = 0; i < parsedItems.length; i++) {
        const item = parsedItems[i];
        setCurrentProcessIndex(i);

        // 1. Add Silence before
        if (item.startTime > currentTimeline) {
          const silenceDuration = item.startTime - currentTimeline;
          allAudioChunks.push(createSilenceBuffer(silenceDuration, targetSampleRate));
        }

        // 2. Fetch Audio
        const duration = Math.max(0.1, item.endTime - item.startTime);
        const segment = await fetchAudioSegment(item.text, duration, selectedVoice);
        allAudioChunks.push(segment.bytes);

        currentTimeline = item.endTime;
      }

      const totalLength = allAudioChunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const mergedBuffer = new Int16Array(totalLength);
      let offset = 0;
      allAudioChunks.forEach(chunk => {
        mergedBuffer.set(chunk, offset);
        offset += chunk.length;
      });

      const wavBlob = pcmToWav(mergedBuffer, targetSampleRate);
      setMergedAudioUrl(URL.createObjectURL(wavBlob));
    } catch (error) {
      console.error("Processing Error:", error);
      alert("កំហុសក្នុងការទាញយកសម្លេង៖ " + error.message);
    } finally {
      setIsProcessing(false);
      setCurrentProcessIndex(-1);
    }
  };

  return (
    <div className="min-h-screen bg-slate-50 p-4 md:p-8 font-sans text-slate-900">
      <div className="max-w-4xl mx-auto space-y-6">
        
        {/* Header */}
        <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-200 flex flex-col md:flex-row md:items-center justify-between gap-4">
          <div className="flex items-center gap-4">
            <div className="bg-indigo-600 p-3 rounded-2xl text-white shadow-lg shadow-indigo-200">
              <Mic className="w-8 h-8" />
            </div>
            <div>
              <h1 className="text-2xl font-black text-slate-800">SRT Studio Recorder</h1>
              <p className="text-slate-500 text-sm font-medium">បង្កើតសម្លេងរួមបញ្ចូលគ្នាតាមកាលវិភាគ SRT</p>
            </div>
          </div>
          
          <div className="flex items-center gap-3">
            <select 
              value={selectedVoice}
              onChange={(e) => setSelectedVoice(e.target.value)}
              className="px-4 py-2.5 rounded-xl border border-slate-200 bg-white text-sm font-bold shadow-sm focus:ring-2 focus:ring-indigo-500 outline-none"
            >
              {VOICES.map(v => <option key={v.id} value={v.id}>{v.name}</option>)}
            </select>
          </div>
        </div>

        {/* Action Bar */}
        {parsedItems.length > 0 && (
          <div className="bg-indigo-900 p-6 rounded-3xl shadow-xl flex flex-col md:flex-row items-center justify-between gap-6">
            <div className="text-white">
              <p className="text-indigo-200 text-xs font-bold uppercase tracking-widest">ស្ថានភាពបច្ចុប្បន្ន</p>
              <h2 className="text-lg font-bold">
                {isProcessing ? `កំពុងដំណើរការជួរទី ${currentProcessIndex + 1}...` : mergedAudioUrl ? 'ផលិតសម្លេងរួមជោគជ័យ!' : 'ត្រៀមខ្លួនរួចរាល់'}
              </h2>
            </div>
            
            <div className="flex gap-3">
              {!mergedAudioUrl ? (
                <button
                  onClick={processFullAudio}
                  disabled={isProcessing}
                  className="px-8 py-3 bg-white text-indigo-900 font-black rounded-2xl hover:bg-indigo-50 transition-all shadow-lg flex items-center gap-3 disabled:opacity-50"
                >
                  {isProcessing ? <Loader2 className="w-5 h-5 animate-spin" /> : <Mic className="w-5 h-5" />}
                  ចាប់ផ្តើមផលិតសម្លេងរួម
                </button>
              ) : (
                <div className="flex gap-2 text-white">
                  <button
                    onClick={() => audioRef.current.play()}
                    className="px-6 py-3 bg-green-500 text-white font-black rounded-2xl hover:bg-green-600 transition-all flex items-center gap-2"
                  >
                    <Play className="w-5 h-5" /> ស្តាប់
                  </button>
                  <a
                    href={mergedAudioUrl}
                    download="full_khmer_audio.wav"
                    className="px-6 py-3 bg-white text-indigo-900 font-black rounded-2xl hover:bg-indigo-50 transition-all flex items-center gap-2 shadow-lg"
                  >
                    <Download className="w-5 h-5" /> ទាញយក
                  </a>
                  <button 
                    onClick={() => {setMergedAudioUrl(null); setParsedItems([]);}}
                    className="p-3 bg-indigo-800 text-white rounded-2xl hover:bg-indigo-700 transition-all"
                  >
                    <Trash2 className="w-5 h-5" />
                  </button>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Upload Area */}
        {parsedItems.length === 0 && (
          <div className="space-y-4">
            <div 
              className="bg-white p-16 rounded-[40px] border-4 border-dashed border-slate-200 hover:border-indigo-400 hover:bg-indigo-50/20 transition-all flex flex-col items-center justify-center gap-6 cursor-pointer"
              onClick={() => fileInputRef.current.click()}
            >
              <div className="p-6 bg-indigo-100 rounded-[30px] text-indigo-600">
                <FileUp className="w-12 h-12" />
              </div>
              <div className="text-center">
                <h3 className="text-2xl font-black text-slate-800">បញ្ចូលឯកសារ SRT</h3>
                <p className="text-slate-500 mt-2 font-medium">ចុចទីនេះដើម្បីជ្រើសរើសឯកសារពីក្នុងម៉ាស៊ីន</p>
              </div>
              <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept=".srt" className="hidden" />
            </div>
            
            <div className="bg-white p-8 rounded-3xl border border-slate-200 shadow-sm">
                <textarea
                    value={srtInput}
                    onChange={(e) => setSrtInput(e.target.value)}
                    className="w-full h-40 p-4 bg-slate-50 rounded-2xl border border-slate-200 font-mono text-sm outline-none"
                    placeholder="1\n00:00:01,000 --> 00:00:04,000\nសួស្តីបងប្អូន..."
                />
                <button
                    onClick={() => parseSRT(srtInput)}
                    className="w-full mt-4 py-4 bg-slate-900 text-white font-black rounded-2xl hover:bg-black transition-all"
                >
                    វិភាគ SRT
                </button>
            </div>
          </div>
        )}

        {/* List Items */}
        {parsedItems.length > 0 && !mergedAudioUrl && (
          <div className="grid gap-3 max-h-[400px] overflow-y-auto pr-2">
            {parsedItems.map((item, index) => (
              <div 
                key={index}
                className={`bg-white p-4 rounded-2xl border-2 transition-all ${
                  currentProcessIndex === index ? 'border-indigo-500 bg-indigo-50' : 'border-white'
                } shadow-sm`}
              >
                <div className="flex gap-4">
                  <div className="text-[10px] font-black text-slate-400">#{item.id}</div>
                  <div className="flex-1">
                    <p className="text-xs font-mono text-slate-400">{item.startStr} - {item.endStr}</p>
                    <p className="text-slate-800 font-bold">{item.text}</p>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}

        <audio ref={audioRef} className="hidden" />
      </div>
    </div>
  );
}
