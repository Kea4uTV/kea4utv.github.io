<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>កម្មវិធីចាក់តន្ត្រី និងបង្ហាញរូបភាពតាមចង្វាក់</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for Khmer -->
    <link href="https://fonts.googleapis.com/css2?family=Battambang&family=Bayon&family=Freehand&family=Kdam+Thmor&family=Moul&family=Noto+Sans+Khmer:wght@100..900&family=Preahvihear&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center; /* Center the main wrapper */
            align-items: flex-start; /* Align wrapper to top */
            min-height: 100vh;
            margin: 0;
            overflow-y: auto; /* Allow vertical scrolling for the whole page if needed */
            padding: 2rem; /* Padding around the whole content */
        }

        .main-wrapper {
            display: flex;
            flex-direction: row; /* Controls and visualizer side-by-side */
            gap: 2rem; /* Space between the two main sections */
            width: 100%;
            max-width: 1200px; /* Max width for the entire application layout */
            align-items: flex-start; /* Align items to the top within the wrapper */
        }

        .controls-panel { /* Renamed from .container for clarity */
            background-color: #2d3748;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            padding: 2.5rem;
            width: 100%;
            max-width: 400px; /* Fixed max-width for controls */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            max-height: calc(100vh - 4rem); /* Limit height for scrolling controls */
            overflow-y: auto; /* Allow internal scrolling for controls */
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        .visualizer-area {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            flex-grow: 1; /* Allow visualizer area to take remaining space */
            width: 100%; /* Important for flex-grow to work properly */
            max-width: 800px; /* Max width for the visualizer content */
            align-items: center; /* Center items within visualizer area */
        }

        .canvas-container {
            width: 100%; /* Take full width of its parent (.visualizer-area) */
            background-color: #1a202c;
            border-radius: 0.75rem;
            border: 2px solid #4a5568;
            position: relative; /* For aspect ratio padding trick */
            overflow: hidden;
        }
        /* Aspect ratio classes */
        .aspect-ratio-16-9 { padding-bottom: 56.25%; /* 9 / 16 * 100 */ }
        .aspect-ratio-9-16 { padding-bottom: 177.77%; /* 16 / 9 * 100 */ }
        .aspect-ratio-1-1 { padding-bottom: 100%; }
        /* Explicit sizes for recording qualities */
        .fixed-size {
            padding-bottom: 0 !important; /* Override aspect ratio padding */
        }


        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            width: 100%;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
        .btn {
            background-color: #4299e1; /* Blue button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            font-weight: bold;
            border: none;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .btn:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-red {
            background-color: #e53e3e; /* Red button for recording */
        }
        .btn-red:hover {
            background-color: #c53030;
        }
        .btn-green {
            background-color: #38a169; /* Green button for stopping */
        }
        .btn-green:hover {
            background-color: #2f855a;
        }
        .volume-slider, .aspect-ratio-select, .image-size-slider, .visualizer-intensity-slider, .seek-slider,
        .canvas-filter-select, .text-color-input, .text-size-input, .text-position-select, .background-size-slider, .logo-position-select,
        .background-motion-type-select, .background-motion-speed-slider, .font-url-input, .font-select, .logo-size-slider, .text-animation-type-select, .background-alignment-select,
        .time-input, .margin-input, .transform-slider, .text-shadow-blur-input {
            width: 150px;
            -webkit-appearance: none;
            height: 8px;
            background: #4a5568;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
            padding: 0.5rem; /* Add padding for select */
            border: none;
            color: #e2e8f0;
        }
        .volume-slider:hover, .aspect-ratio-select:hover, .image-size-slider:hover, .visualizer-intensity-slider:hover, .seek-slider:hover,
        .canvas-filter-select:hover, .text-color-input:hover, .text-size-input:hover, .text-position-select:hover, .background-size-slider:hover, .logo-position-select:hover,
        .background-motion-type-select:hover, .background-motion-speed-slider:hover, .font-url-input:hover, .font-select:hover, .logo-size-slider:hover, .text-animation-type-select:hover,
        .time-input:hover, .margin-input:hover, .transform-slider:hover, .text-shadow-blur-input:hover {
            opacity: 1;
        }
        .volume-slider::-webkit-slider-thumb, .image-size-slider::-webkit-slider-thumb, .visualizer-intensity-slider::-webkit-slider-thumb, .seek-slider::-webkit-slider-thumb, .background-size-slider::-webkit-slider-thumb, .background-motion-speed-slider::-webkit-slider-thumb, .logo-size-slider::-webkit-slider-thumb, .time-input::-webkit-slider-thumb, .transform-slider::-webkit-slider-thumb, .text-shadow-blur-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
        .volume-slider::-moz-range-thumb, .image-size-slider::-moz-range-thumb, .visualizer-intensity-slider::-moz-range-thumb, .seek-slider::-moz-range-thumb, .background-size-slider::-moz-range-thumb, .background-motion-speed-slider::-moz-range-thumb, .logo-size-slider::-moz-range-thumb, .time-input::-moz-range-thumb, .transform-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
        .aspect-ratio-select, .canvas-filter-select, .text-position-select, .logo-position-select, .background-motion-type-select, .font-select, .text-animation-type-select, .background-alignment-select {
            background-color: #4a5568;
            cursor: pointer;
            width: auto; /* Adjust width based on content */
        }
        .text-color-input {
            height: 38px; /* Match height of select/slider */
            padding: 0.25rem;
            width: 80px; /* Adjust width for color picker */
        }
        .text-size-input {
            width: 100px;
        }
        .text-input, .font-url-input, .time-input, .margin-input {
            background-color: #4a5568;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            width: 100%;
            max-width: 250px;
        }
        .time-input {
            width: 60px; /* Smaller width for time inputs */
            text-align: center;
        }
        .margin-input {
            width: 70px; /* Smaller width for margin inputs */
            text-align: center;
        }
        .transform-slider {
            width: 100px;
        }
        .seek-slider {
            width: 100%; /* Make seek slider full width */
            margin-top: 1rem;
        }
        .time-display {
            font-size: 0.9rem;
            color: #a0aec0;
            margin-top: 0.5rem;
            width: 100%;
            text-align: center;
        }
        .image-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 0.5rem;
            object-fit: contain;
            border: 2px solid #4a5568;
            display: none; /* Hidden by default */
        }
        .message-box {
            background-color: #38a169; /* Green for success */
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            text-align: center;
            display: none; /* Hidden by default */
            width: 100%;
        }
        .message-box.error {
            background-color: #e53e3e; /* Red for error */
        }
        .message-box.info {
            background-color: #4299e1; /* Blue for info */
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .visualizer-checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        /* Initial hidden state for controls */
        .controls-hidden {
            display: none !important;
        }

        /* Modal Overlay Styles */
        #accessModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top of everything */
        }

        /* Modal Content Styles */
        #accessControl {
            background-color: #2d3748; /* Same as controls-panel background */
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            padding: 2.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 90%;
            max-width: 400px; /* Fixed width for the modal content */
            text-align: center;
        }

        /* Responsive adjustments for small screens */
        @media (max-width: 1024px) {
            .main-wrapper {
                flex-direction: column; /* Stack vertically on smaller screens */
                align-items: center; /* Center items when stacked */
                gap: 1rem;
            }
            .controls-panel, .visualizer-area {
                max-width: 95%; /* Allow both to be wider on mobile */
                max-height: none; /* Remove max height when stacked */
                overflow-y: visible; /* Allow content to push height */
            }
            body {
                padding: 1rem; /* Reduce padding for mobile */
            }
        }
        /* Styling for individual text layer controls */
        .text-layer-controls {
            background-color: #3a475a; /* Slightly different background for clarity */
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .text-layer-controls .flex {
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .text-layer-controls .btn-remove {
            background-color: #e53e3e;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-self: flex-end; /* Align remove button to the right */
        }
        /* Styling for individual image layer controls */
        .image-layer-controls {
            background-color: #3a475a; /* Same as text layer for consistency */
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .image-layer-controls .flex {
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .image-layer-controls .btn-remove {
            background-color: #e53e3e;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-self: flex-end;
        }
        .image-layer-controls .image-file-input {
            width: 100%; /* Ensure file input wrapper takes full width */
        }
        .image-layer-controls .image-preview-thumbnail {
            max-width: 100px;
            max-height: 100px;
            border-radius: 0.25rem;
            object-fit: contain;
            border: 1px solid #4a5568;
            margin-top: 0.5rem;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Access Control Modal Overlay -->
    <div id="accessModalOverlay">
        <div id="accessControl" class="w-full flex flex-col items-center gap-4">
            <p class="text-lg text-center">សូមបញ្ចូលលេខសម្គាល់ដើម្បីបន្ត</p>
            <input type="password" id="secretIdInput" class="text-input" placeholder="បញ្ចូលលេខសម្គាល់...">
            <button id="verifyIdBtn" class="btn">ផ្ទៀងផ្ទាត់</button>
            <div id="messageBox" class="message-box"></div> <!-- Message box inside modal -->
        </div>
    </div>

    <div class="main-wrapper">
        <div class="controls-panel">
            <h1 class="text-3xl font-bold text-center mb-4">កម្មវិធីចាក់តន្ត្រី និងបង្ហាញរូបភាពតាមចង្វាក់</h1>

            <!-- All other controls, initially hidden -->
            <div id="appControls" class="w-full flex flex-col items-center gap-1.5 controls-hidden">
                <div class="controls">
                    <div class="file-input-wrapper">
                        <button class="btn">ជ្រើសរើសឯកសារតន្ត្រី</button>
                        <input type="file" id="audioFile" accept="audio/*">
                    </div>
                    <div class="control-group">
                        <label for="aspectRatioSelect" class="text-sm">ទំហំបង្ហាញ:</label>
                        <select id="aspectRatioSelect" class="aspect-ratio-select">
                            <option value="16-9">YouTube (16:9)</option>
                            <option value="9-16">TikTok/Reels (9:16)</option>
                            <option value="1-1">Instagram (1:1)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="recordingQualitySelect" class="text-sm">គុណភាពវីដេអូថត:</label>
                        <select id="recordingQualitySelect" class="recording-quality-select">
                            <option value="auto">ស្វ័យប្រវត្តិ (តាមទំហំបង្ហាញ)</option>
                            <option value="1920x1080">1080p (1920x1080)</option>
                            <option value="1280x720">720p (1280x720)</option>
                            <option value="1080x1920">Vertical (1080x1920)</option>
                            <option value="1080x1080">Square (1080x1080)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="text-sm">ប្រភេទចលនា:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមប្រភេទចលនា</summary>
                            <div id="visualizerTypeControls" class="visualizer-checkbox-group mt-2">
                                <label><input type="checkbox" class="visualizer-checkbox" value="bars"> របារប្រេកង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="circle-pulse"> រង្វង់លោត</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="wave"> រលក</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="radial-bars"> របាររង្វង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="particle-swarm"> ហ្វូងភាគល្អិត</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="line-spectrum"> បន្ទាត់វិសាលគម</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="frequency-circle"> រង្វង់ប្រេកង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="falling-particles"> ភាគល្អិតធ្លាក់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="rising-particles"> ភាគល្អិតឡើងលើ</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="leftward-particles"> ភាគល្អិតទៅឆ្វេង</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="rightward-particles"> ភាគល្អិតទៅស្តាំ</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="colorful-particles"> ភាគល្អិតចម្រុះពណ៌</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="connecting-lines"> បន្ទាត់តភ្ជាប់</label>
                            </div>
                        </details>
                    </div>
                    <div class="control-group">
                        <label for="visualizerIntensitySlider" class="text-sm">កម្រិតចលនា:</label>
                        <input type="range" id="visualizerIntensitySlider" min="0.0" max="2.0" step="0.1" value="1.0" class="visualizer-intensity-slider">
                    </div>
                </div>

                <div class="w-full flex flex-col items-center">
                    <!-- Audio player controls moved here -->
                    <div class="flex flex-wrap justify-center gap-2 mb-2">
                        <button id="playPauseBtn" class="btn">ចាក់/ផ្អាក</button>
                        <div class="control-group">
                            <label for="volumeSlider" class="text-sm">កម្រិតសំឡេង:</label>
                            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.7" class="volume-slider">
                        </div>
                    </div>
                    <input type="range" id="seekSlider" min="0" max="0" value="0" step="0.01" class="seek-slider">
                    <div id="timeDisplay" class="time-display">0:00 / 0:00</div>
                </div>

                <div class="controls mt-4">
                    <div class="control-group">
                        <label for="backgroundFile" class="text-sm">ផ្ទៃខាងក្រោយ:</label>
                        <input type="file" id="backgroundFile" accept="image/*">
                        <div class="checkbox-group">
                            <input type="checkbox" id="autoBackgroundSizeCheckbox" checked>
                            <label for="autoBackgroundSizeCheckbox" class="text-sm">ស្វ័យប្រវត្តិ</label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="backgroundSizeSlider" class="text-sm">ទំហំផ្ទៃខាងក្រោយ:</label>
                        <input type="range" id="backgroundSizeSlider" min="0.1" max="2.0" step="0.05" value="1.0" class="background-size-slider">
                    </div>
                    <div class="control-group">
                        <label for="backgroundAlignmentSelect" class="text-sm">ទីតាំងផ្ទៃខាងក្រោយ:</label>
                        <select id="backgroundAlignmentSelect" class="background-alignment-select">
                            <option value="center">កណ្តាល</option>
                            <option value="top-left">លើ-ឆ្វេង</option>
                            <option value="top-center">លើ-កណ្តាល</option>
                            <option value="top-right">លើ-ស្តាំ</option>
                            <option value="center-left">កណ្តាល-ឆ្វេង</option>
                            <option value="center-right">កណ្តាល-ស្តាំ</option>
                            <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                            <option value="bottom-center">ក្រោម-កណ្តាល</option>
                            <option value="bottom-right">ក្រោម-ស្តាំ</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="backgroundMotionTypeSelect" class="text-sm">ចលនាផ្ទៃខាងក្រោយ:</label>
                        <select id="backgroundMotionTypeSelect" class="background-motion-type-select">
                            <option value="none">គ្មាន</option>
                            <option value="zoom">ពង្រីក/បង្រួម</option>
                            <option value="pan-horizontal">រំកិលផ្ដេក</option>
                            <option value="pan-vertical">រំកិលបញ្ឈរ</option>
                            <option value="rotate">បង្វិល</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="backgroundMotionSpeedSlider" class="text-sm">ល្បឿនចលនាផ្ទៃខាងក្រោយ:</label>
                        <input type="range" id="backgroundMotionSpeedSlider" min="0.0" max="1.0" step="0.05" value="0.5" class="background-motion-speed-slider">
                    </div>
                    <div class="control-group">
                        <label for="canvasFilterSelect" class="text-sm">តម្រងរូបភាព:</label>
                        <select id="canvasFilterSelect" class="canvas-filter-select">
                            <option value="none">គ្មាន</option>
                            <option value="grayscale(100%)">សខ្មៅ</option>
                            <option value="sepia(100%)">សេពៀ</option>
                            <option value="invert(100%)">បញ្ច្រាសពណ៌</option>
                            <option value="blur(5px)">ព្រិល</option>
                        </select>
                    </div>
                    
                    <!-- Image Layers Container -->
                    <div class="control-group w-full">
                        <label class="text-sm">គ្រប់គ្រងរូបភាព:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមគ្រប់គ្រងរូបភាព</summary>
                            <div id="imageLayersContainer" class="w-full mt-2">
                                <!-- Image input templates will be added here by JS -->
                            </div>
                            <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                                <button id="addImageLayerBtn" class="btn">បន្ថែមរូបភាពថ្មី</button>
                            </div>
                        </details>
                    </div>

                    <!-- Text Layers Container -->
                    <div class="control-group w-full">
                        <label class="text-sm">គ្រប់គ្រងអត្ថបទ:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមគ្រប់គ្រងអត្ថបទ</summary>
                            <div id="textLayersContainer" class="w-full mt-2">
                                <!-- Text input templates will be added here by JS -->
                            </div>
                            <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                                <button id="addTextLayerBtn" class="btn">បន្ថែមអត្ថបទថ្មី</button>
                                <button id="addSubtitleLayerBtn" class="btn">បន្ថែម Subtitle ថ្មី</button>
                            </div>
                        </details>
                    </div>

                    <div class="control-group">
                        <label for="logoFile" class="text-sm">Logo:</label>
                        <input type="file" id="logoFile" accept="image/*">
                    </div>
                    <div class="control-group">
                        <label for="logoPositionSelect" class="text-sm">ទីតាំង Logo:</label>
                        <select id="logoPositionSelect" class="logo-position-select">
                            <option value="top-left">លើ-ឆ្វេង</option>
                            <option value="top-right">លើ-ស្តាំ</option>
                            <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                            <option value="bottom-right">ក្រោម-ស្តាំ</option>
                            <option value="center">កណ្តាល</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="logoSizeSlider" class="text-sm">ទំហំ Logo:</label>
                        <input type="range" id="logoSizeSlider" min="10" max="200" step="5" value="50" class="logo-size-slider">
                        <div class="checkbox-group">
                            <input type="checkbox" id="autoLogoSizeCheckbox" checked>
                            <label for="autoLogoSizeCheckbox" class="text-sm">ស្វ័យប្រវត្តិ</label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="fontUrlInput" class="text-sm">ផ្ទុក Font ពី URL (Google Fonts):</label>
                        <input type="text" id="fontUrlInput" class="font-url-input" placeholder="ឧ. https://fonts.googleapis.com/css2?family=Noto+Sans+Khmer&display=swap">
                        <button id="loadFontUrlBtn" class="btn">ផ្ទុក Font URL</button>
                    </div>
                    <div class="control-group">
                        <label for="fontFileInput" class="text-sm">ផ្ទុក Font ពីឧបករណ៍ (.ttf, .otf, .woff):</label>
                        <input type="file" id="fontFileInput" accept=".ttf,.otf,.woff,.woff2">
                        <input type="text" id="customFontNameInput" class="text-input" placeholder="ឈ្មោះ Font (ឧ. MyCustomFont)">
                        <button id="loadFontFileBtn" class="btn">ផ្ទុក Font ឯកសារ</button>
                    </div>
                    <div class="control-group">
                        <label class="text-sm">ជ្រើសរើស Font:</label>
                        <select id="fontSelect" class="font-select">
                            <!-- Options will be populated by JS -->
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div class="visualizer-area">
            <img id="imagePreview" class="image-preview" alt="រូបភាពដែលបានជ្រើសរើស">

            <div id="canvasContainer" class="canvas-container aspect-ratio-16-9">
                <canvas id="visualizerCanvas"></canvas>
            </div>

            <div class="controls mt-4">
                <button id="fullscreenBtn" class="btn">ពេញអេក្រង់</button>
                <button id="startRecordBtn" class="btn btn-red">ចាប់ផ្តើមថត</button>
                <button id="stopRecordBtn" class="btn btn-green" disabled>បញ្ឈប់ការថត</button>
                <a id="downloadVideoLink" class="btn hidden" download="visualizer_video.webm">ទាញយកវីដេអូ</a>
                <div class="checkbox-group mt-2">
                    <input type="checkbox" id="recordWithoutFilterCheckbox">
                    <label for="recordWithoutFilterCheckbox" class="text-sm">ថតដោយគ្មានតម្រងរូបភាព</label>
                </div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer" controls class="hidden"></audio>

    <!-- Hidden Text Layer Template -->
    <template id="textLayerTemplate">
        <div class="text-layer-controls">
            <button class="btn btn-red btn-remove">លុប</button>
            <textarea class="text-input" rows="2" placeholder="បញ្ចូលអត្ថបទ..."></textarea>
            <div class="flex">
                <input type="color" value="#ffffff" class="text-color-input">
                <input type="number" min="10" max="100" value="30" class="text-size-input">
                <select class="text-position-select">
                    <option value="bottom-center">ក្រោម-កណ្តាល</option>
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វ្វេង</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                    <option value="center">កណ្តាល</option>
                </select>
            </div>
            <div class="checkbox-group">
                <label><input type="checkbox" class="text-bold-checkbox"> អក្សរដិត</label>
                <label><input type="checkbox" class="text-shadow-checkbox"> ស្រមោលអក្សរ</label>
                <label><input type="checkbox" class="text-blur-checkbox"> អក្សរព្រាល</label>
            </div>
            <div class="control-group">
                <label class="text-sm">ចលនាអត្ថបទ:</label>
                <select class="text-animation-type-select">
                    <option value="none">គ្មាន</option>
                    <option value="pulse">លោតតាមភ្លេង</option>
                    <option value="fade">ព្រាលតាមភ្លេង</option>
                    <option value="slide-horizontal">រំកិលផ្ដេកតាមភ្លេង</option>
                    <option value="slide-vertical">រំកិលបញ្ឈរតាមភ្លេង</option>
                </select>
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលចាប់ផ្តើម:</label>
                <input type="number" min="0" value="0" class="time-input text-start-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input text-start-sec">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលបញ្ចប់:</label>
                <input type="number" min="0" value="0" class="time-input text-end-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input text-end-sec">
            </div>
            <div class="control-group">
                <label class="text-sm">ពណ៌គ្រោង:</label>
                <input type="color" value="#000000" class="text-outline-color-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ទទឹងគ្រោង:</label>
                <input type="number" min="0" max="10" step="0.5" value="0" class="transform-slider text-outline-width-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ពណ៌ស្រមោល:</label>
                <input type="color" value="#000000" class="text-shadow-color-input">
            </div>
            <div class="control-group">
                <label class="text-sm">កម្រិតព្រាលស្រមោល:</label>
                <input type="number" min="0" max="20" step="1" value="2" class="transform-slider text-shadow-blur-input">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">រឹមឆ្វេង:</label>
                <input type="number" value="0" class="margin-input text-margin-left-input">
                <label class="text-sm">រឹមស្តាំ:</label>
                <input type="number" value="0" class="margin-input text-margin-right-input">
            </div>
            <div class="control-group">
                <label class="text-sm">រឹមបញ្ឈរ:</label>
                <input type="number" value="0" class="margin-input text-margin-vertical-input">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">មាត្រដ្ឋាន X:</label>
                <input type="number" min="0.1" max="5.0" step="0.1" value="1.0" class="transform-slider text-scale-x-input">
                <label class="text-sm">មាត្រដ្ឋាន Y:</label>
                <input type="number" min="0.1" max="5.0" step="0.1" value="1.0" class="transform-slider text-scale-y-input">
            </div>
            <div class="control-group">
                <label class="text-sm">បង្វិល (ដឺក្រេ):</label>
                <input type="number" min="-180" max="180" value="0" class="transform-slider text-rotation-input">
            </div>
            <div class="control-group">
                <label class="text-sm">គម្លាតអក្សរ:</label>
                <input type="number" min="-10" max="20" step="0.5" value="0" class="transform-slider text-spacing-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ជ្រើសរើស Font:</label>
                <select class="font-select">
                    <!-- Options will be populated by JS -->
                </select>
            </div>
        </div>
    </template>

    <!-- Hidden Image Layer Template -->
    <template id="imageLayerTemplate">
        <div class="image-layer-controls">
            <button class="btn btn-red btn-remove">លុប</button>
            <div class="file-input-wrapper">
                <button class="btn">ជ្រើសរើសរូបភាព</button>
                <input type="file" accept="image/*" class="image-file-input">
            </div>
            <img class="image-preview-thumbnail" alt="រូបភាពតូច">
            <div class="control-group">
                <label class="text-sm">ទំហំរូបភាព:</label>
                <input type="range" min="0.1" max="2.0" step="0.05" value="1.0" class="image-size-slider">
                <div class="checkbox-group">
                    <input type="checkbox" checked class="auto-image-size-checkbox">
                    <label class="text-sm">ស្វ័យប្រវត្តិ</label>
                </div>
            </div>
            <div class="control-group">
                <label class="text-sm">ទីតាំងរូបភាព:</label>
                <select class="image-position-select">
                    <option value="center">កណ្តាល</option>
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-center">លើ-កណ្តាល</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="center-left">កណ្តាល-ឆ្វេង</option>
                    <option value="center-right">កណ្តាល-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                    <option value="bottom-center">ក្រោម-កណ្តាល</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                </select>
            </div>
            <div class="checkbox-group">
                <label><input type="checkbox" class="image-pulse-checkbox"> ចលនាលោតរូបភាព</label>
            </div>
        </div>
    </template>

    <script>
        // --- Security Measures (Client-Side Only) ---
        // Disable right-click context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            // No redirect here, just prevent default
        });

        // Disable F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C, Ctrl+U
        document.addEventListener('keydown', function(e) {
            // F12 key
            if (e.key === 'F12') {
                e.preventDefault();
            }

            // Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C (Developer Tools shortcuts)
            if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) {
                e.preventDefault();
            }

            // Ctrl+U (View Page Source)
            if (e.ctrlKey && e.key === 'u') {
                e.preventDefault();
            }
        });

        // This attempts to handle view-source: but is not foolproof as browser behavior varies.
        // It's client-side JS, so if someone types view-source: in the URL bar, the JS might not even run.
        // The primary defense is the keydown and contextmenu listeners.
        // Removed redirect for view-source as it causes issues with local files.

        // --- End Security Measures ---


        // Get DOM elements
        const audioFile = document.getElementById('audioFile');
        const backgroundFile = document.getElementById('backgroundFile');
        const logoFile = document.getElementById('logoFile');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const audioPlayer = document.getElementById('audioPlayer');
        const visualizerCanvas = document.getElementById('visualizerCanvas');
        const messageBox = document.getElementById('messageBox');
        const aspectRatioSelect = document.getElementById('aspectRatioSelect');
        const recordingQualitySelect = document.getElementById('recordingQualitySelect'); // New recording quality select
        const canvasContainer = document.getElementById('canvasContainer');
        const startRecordBtn = document.getElementById('startRecordBtn');
        const stopRecordBtn = document.getElementById('stopRecordBtn');
        const downloadVideoLink = document.getElementById('downloadVideoLink');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const visualizerTypeControls = document.getElementById('visualizerTypeControls'); // Changed to div
        const visualizerCheckboxes = document.querySelectorAll('.visualizer-checkbox'); // Get all checkboxes
        const visualizerIntensitySlider = document.getElementById('visualizerIntensitySlider');
        const seekSlider = document.getElementById('seekSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const autoBackgroundSizeCheckbox = document.getElementById('autoBackgroundSizeCheckbox');
        const canvasFilterSelect = document.getElementById('canvasFilterSelect');
        const backgroundSizeSlider = document.getElementById('backgroundSizeSlider');
        const logoPositionSelect = document.getElementById('logoPositionSelect');
        const backgroundMotionTypeSelect = document.getElementById('backgroundMotionTypeSelect');
        const backgroundMotionSpeedSlider = document.getElementById('backgroundMotionSpeedSlider');
        const fontUrlInput = document.getElementById('fontUrlInput');
        const loadFontUrlBtn = document.getElementById('loadFontUrlBtn');
        const fontFileInput = document.getElementById('fontFileInput');
        const customFontNameInput = document.getElementById('customFontNameInput');
        const loadFontFileBtn = document.getElementById('loadFontFileBtn');
        const fontSelect = document.getElementById('fontSelect'); // Global font select
        const logoSizeSlider = document.getElementById('logoSizeSlider'); // New logo size slider
        const autoLogoSizeCheckbox = document.getElementById('autoLogoSizeCheckbox'); // New auto logo size checkbox
        const recordWithoutFilterCheckbox = document.getElementById('recordWithoutFilterCheckbox'); // New record without filter checkbox

        // Access Control Elements
        const accessModalOverlay = document.getElementById('accessModalOverlay'); // New: Modal overlay
        const secretIdInput = document.getElementById('secretIdInput');
        const verifyIdBtn = document.getElementById('verifyIdBtn');
        const appControlsDiv = document.getElementById('appControls');

        // Text Layer Management Elements
        const textLayersContainer = document.getElementById('textLayersContainer');
        const addTextLayerBtn = document.getElementById('addTextLayerBtn');
        const addSubtitleLayerBtn = document.getElementById('addSubtitleLayerBtn'); // New subtitle button
        const textLayerTemplate = document.getElementById('textLayerTemplate');

        // Image Layer Management Elements
        const imageLayersContainer = document.getElementById('imageLayersContainer'); // New container for image layers
        const addImageLayerBtn = document.getElementById('addImageLayerBtn'); // New add image button
        const imageLayerTemplate = document.getElementById('imageLayerTemplate'); // New image layer template

        // New background alignment select
        const backgroundAlignmentSelect = document.getElementById('backgroundAlignmentSelect');

        // Global variable to track if recordingQualitySelect is changing aspectRatioSelect to prevent loop
        let isSettingAspectRatioByQuality = false;

        // Canvas context
        const ctx = visualizerCanvas.getContext('2d');

        // Audio context and analyser
        let audioContext;
        let analyser;
        let source;
        let gainNode; // New: GainNode for audio routing
        let bufferLength;
        let dataArray;
        let animationFrameId;
        let audioDestinationNode;

        // Image objects
        let bgImg = new Image();
        let isBgImageLoaded = false;
        let logoImg = new Image();
        let isLogoLoaded = false;

        // Media Recorder variables
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        // Global variable for background pan/rotate animation
        let backgroundPanOffset = { x: 0, y: 0 };
        let backgroundRotation = 0;
        let lastFrameTime = 0;

        // Global array to store the order of selected visualizers
        let activeVisualizerOrder = []; // Stores objects like { type: 'bars', timestamp: Date.now() }

        // Particle Class (generic for all particle visualizers)
        class Particle {
            constructor(x, y, size, color, speedX = 0, speedY = 0) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.speedX = speedX;
                this.speedY = speedY;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // Separate particle arrays for each particle visualizer type
        const maxParticlesPerVisualizer = 100;
        let fallingParticles = [];
        let risingParticles = [];
        let leftwardParticles = [];
        let rightwardParticles = [];
        let colorfulParticles = []; // These will be falling particles with dynamic colors

        // Array to hold all text layer objects
        let textLayers = [];
        // Array to hold all image layer objects
        let imageLayers = [];


        // Predefined list of fonts for the dropdowns
        const defaultFontOptions = [
            { value: 'Inter, sans-serif', text: 'Inter (លំនាំដើម)' },
            { value: 'Arial, sans-serif', text: 'Arial' },
            { value: 'Verdana, sans-serif', text: 'Verdana' },
            { value: 'Times New Roman, serif', text: 'Times New Roman' },
            { value: 'Noto Sans Khmer', text: 'Noto Sans Khmer' },
            { value: 'Battambang', text: 'Battambang' },
            { value: 'Bayon', text: 'Bayon' },
            { value: 'Freehand', text: 'Freehand' },
            { value: 'Kdam Thmor', text: 'Kdam Thmor' },
            { value: 'Moul', text: 'Moul' },
            { value: 'Preahvihear', text: 'Preahvihear' }
        ];


        // Helper to initialize particles for a given array
        function initializeParticleArray(arr, canvasWidth, canvasHeight, baseColor) {
            if (arr.length === 0) {
                for (let i = 0; i < maxParticlesPerVisualizer; i++) {
                    const particleColor = baseColor || `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`; // Explicitly define color
                    arr.push(new Particle(Math.random() * canvasWidth, Math.random() * canvasHeight, Math.random() * 3 + 1, particleColor));
                }
            }
        }

        // Function to format time (e.g., 150 seconds -> 2:30)
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        // Function to show messages
        function showMessage(message, isError = false, isInfo = false) {
            // Use the messageBox within the modal for access control messages
            const targetMessageBox = accessModalOverlay.classList.contains('controls-hidden') ? messageBox : accessModalOverlay.querySelector('#messageBox');
            
            targetMessageBox.textContent = message;
            targetMessageBox.className = 'message-box'; // Reset classes
            if (isError) {
                targetMessageBox.classList.add('error');
            } else if (isInfo) {
                targetMessageBox.classList.add('info');
            } else {
                targetMessageBox.classList.add('success'); // Default for success
            }
            targetMessageBox.style.display = 'block';
            setTimeout(() => {
                targetMessageBox.style.display = 'none';
            }, 3000); // Hide after 3 seconds
        }

        // Initialize AudioContext when user interacts
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256; // Fast Fourier Transform size
                bufferLength = analyser.frequencyBinCount; // Number of data points
                dataArray = new Uint8Array(bufferLength); // Array to hold frequency data

                source = audioContext.createMediaElementSource(audioPlayer);
                gainNode = audioContext.createGain(); // Create a gain node
                source.connect(gainNode); // Connect source to gain node
                gainNode.connect(analyser); // Connect gain node to analyser
                analyser.connect(audioContext.destination); // Connect analyser to speakers
            }
        }

        // Function to load font from URL (e.g., Google Fonts)
        async function loadFontFromUrl(url) {
            if (!url) {
                showMessage('សូមបញ្ចូល URL Font ឱ្យបានត្រឹមត្រូវ។', true);
                return;
            }
            try {
                // Check if the font is already loaded or being loaded
                const existingLink = document.querySelector(`link[href="${url}"]`);
                if (existingLink) {
                    showMessage('Font នេះត្រូវបានផ្ទុកពីមុនមកហើយ។', false, true);
                    return;
                }

                const link = document.createElement('link');
                link.href = url;
                link.rel = 'stylesheet';
                document.head.appendChild(link);

                // Attempt to get font family name from Google Fonts URL
                const match = url.match(/family=([^&:]+)/);
                let fontName = 'Unknown Font';
                if (match && match[1]) {
                    fontName = decodeURIComponent(match[1].replace(/\+/g, ' '));
                }

                // Wait for the font to be loaded
                await document.fonts.load(`1em "${fontName}"`);
                // Add to global font options and update all existing font selects
                addFontToAllSelects(fontName, fontName);
                showMessage(`Font "${fontName}" ត្រូវបានផ្ទុកដោយជោគជ័យពី URL។`);
                drawVisualizer(); // Redraw with new font
            } catch (error) {
                showMessage(`បរាជ័យក្នុងការផ្ទុក Font ពី URL: ${error.message}`, true);
                console.error('Font loading error:', error);
            }
        }

        // Function to load font from local file
        async function loadFontFromFile(file, fontName) {
            if (!file) {
                showMessage('សូមជ្រើសរើសឯកសារ Font។', true);
                return;
            }
            if (!fontName || fontName.trim() === '') {
                showMessage('សូមបញ្ចូលឈ្មោះសម្រាប់ Font ផ្ទាល់ខ្លួន។', true);
                return;
            }
            try {
                const font = new FontFace(fontName, `url(${URL.createObjectURL(file)})`);
                await font.load();
                document.fonts.add(font);
                // Add to global font options and update all existing font selects
                addFontToAllSelects(fontName, fontName);
                showMessage(`Font "${fontName}" ត្រូវបានផ្ទុកដោយជោគជោគជ័យពីឯកសារ។`);
                drawVisualizer(); // Redraw with new font
            } catch (error) {
                showMessage(`បរាជ័យក្នុងការផ្ទុក Font ពីឯកសារ: ${error.message}`, true);
                console.error('Font loading error:', error);
            }
        }

        // Helper function to add a font option to all font select dropdowns
        function addFontToAllSelects(value, text) {
            const fontSelects = document.querySelectorAll('.font-select');
            fontSelects.forEach(select => {
                // Check if option already exists to prevent duplicates
                if (!Array.from(select.options).some(option => option.value === value)) {
                    const newOption = new Option(text, value);
                    select.add(newOption);
                }
            });
        }


        // Handle audio file selection
        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                audioPlayer.src = fileURL;
                audioPlayer.load(); // Load the audio
                showMessage(`ឯកសារតន្ត្រី "${file.name}" ត្រូវបានផ្ទុក។`);
                initAudioContext(); // Initialize audio context on file load
                playPauseBtn.textContent = 'ចាក់'; // Reset button text
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        // Ensure visualizer starts only after audio context resumes
                        drawVisualizer();
                    });
                } else {
                    drawVisualizer();
                }
                downloadVideoLink.classList.add('hidden'); // Hide download link on new audio
            } else {
                showMessage('សូមជ្រើសរើសឯកសារតន្ត្រី។', true);
            }
        });

        // Update seek slider max and time display when audio metadata is loaded
        audioPlayer.addEventListener('loadedmetadata', () => {
            seekSlider.max = audioPlayer.duration;
            timeDisplay.textContent = `0:00 / ${formatTime(audioPlayer.duration)}`;
        });

        // Update seek slider and time display as audio plays
        audioPlayer.addEventListener('timeupdate', () => {
            if (!seekSlider.dragging) { // Only update if user isn't dragging the slider
                seekSlider.value = audioPlayer.currentTime;
            }
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
        });

        // Seek slider functionality
        seekSlider.addEventListener('input', () => {
            audioPlayer.currentTime = seekSlider.value;
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
        });

        // Handle background file selection
        backgroundFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    bgImg.src = e.target.result;
                    bgImg.onload = () => {
                        isBgImageLoaded = true;
                        showMessage(`រូបភាពផ្ទៃខាងក្រោយ "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer(); // Redraw canvas with new background
                    };
                    bgImg.onerror = () => {
                        isBgImageLoaded = false;
                        showMessage('មិនអាចផ្ទុករូបភាពផ្ទៃខាងក្រោយបានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសរូបភាពផ្ទៃខាងក្រោយ។', true);
            }
        });

        // Handle logo file selection
        logoFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    logoImg.src = e.target.result;
                    logoImg.onload = () => {
                        isLogoLoaded = true;
                        showMessage(`ឯកសារ Logo "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer(); // Redraw canvas with new logo
                    };
                    logoImg.onerror = () => {
                        isLogoLoaded = false;
                        showMessage('មិនអាចផ្ទុក Logo បានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Logo។', true);
            }
        });

        // Play/Pause button functionality
        playPauseBtn.addEventListener('click', () => {
            if (!audioPlayer.src) {
                showMessage('សូមផ្ទុកឯកសារតន្ត្រីជាមុនសិន។', true);
                return;
            }

            initAudioContext(); // Ensure context is initialized and resumed

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    if (audioPlayer.paused) {
                        audioPlayer.play();
                        playPauseBtn.textContent = 'ផ្អាក';
                        drawVisualizer(); // Start visualization
                    } else {
                        audioPlayer.pause();
                        playPauseBtn.textContent = 'ចាក់';
                        cancelAnimationFrame(animationFrameId); // Stop visualization
                    }
                }).catch(e => showMessage(`បរាជ័យក្នុងការបន្ត AudioContext: ${e.message}`, true));
            } else {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                    playPauseBtn.textContent = 'ផ្អាក';
                    drawVisualizer(); // Start visualization
                } else {
                    audioPlayer.pause();
                    playPauseBtn.textContent = 'ចាក់';
                    cancelAnimationFrame(animationFrameId); // Stop visualization
                }
            }
        });

        // Volume control
        volumeSlider.addEventListener('input', () => {
            audioPlayer.volume = volumeSlider.value;
        });

        // Background Size control
        backgroundSizeSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new background size
        });

        // Auto Background Size checkbox control
        autoBackgroundSizeCheckbox.addEventListener('change', () => {
            backgroundSizeSlider.disabled = autoBackgroundSizeCheckbox.checked;
            drawVisualizer(); // Redraw canvas with new background sizing mode
        });

        // Background Alignment control
        backgroundAlignmentSelect.addEventListener('change', () => {
            drawVisualizer(); // Redraw canvas with new background alignment
            showMessage(`ទីតាំងផ្ទៃខាងក្រោយត្រូវបានផ្លាស់ប្តូរទៅជា "${backgroundAlignmentSelect.options[backgroundAlignmentSelect.selectedIndex].text}"។`, false, true);
        });

        // Background Motion Type control
        backgroundMotionTypeSelect.addEventListener('change', () => {
            // Reset motion state when type changes
            backgroundPanOffset = { x: 0, y: 0 };
            backgroundRotation = 0;
            drawVisualizer(); // Redraw canvas with new motion type
            showMessage(`ចលនាផ្ទៃខាងក្រោយត្រូវបានផ្លាស់ប្តូរទៅជា "${backgroundMotionTypeSelect.options[backgroundMotionTypeSelect.selectedIndex].text}"។`, false, true);
        });

        // Background Motion Speed control
        backgroundMotionSpeedSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new motion speed
        });

        // Visualizer Intensity control
        visualizerIntensitySlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new intensity
        });

        // Aspect Ratio selection
        aspectRatioSelect.addEventListener('change', (event) => {
            const selectedRatio = event.target.value;
            if (isSettingAspectRatioByQuality) { // Prevent infinite loop
                return;
            }
            // If aspect ratio is manually changed, revert quality to auto
            recordingQualitySelect.value = 'auto';
            updateCanvasSize();
            showMessage(`ទំហំបង្ហាញត្រូវបានផ្លាស់ប្តូរទៅ ${selectedRatio.replace('-', ':')}។`, false, true);
        });

        // Recording Quality selection
        recordingQualitySelect.addEventListener('change', (event) => {
            const selectedQuality = event.target.value;
            if (selectedQuality !== 'auto') {
                isSettingAspectRatioByQuality = true; // Set flag
                // Automatically set aspect ratio based on selected resolution
                switch (selectedQuality) {
                    case '1920x1080':
                    case '1280x720':
                        aspectRatioSelect.value = '16-9';
                        break;
                    case '1080x1920':
                        aspectRatioSelect.value = '9-16';
                        break;
                    case '1080x1080':
                        aspectRatioSelect.value = '1-1';
                        break;
                }
                isSettingAspectRatioByQuality = false; // Reset flag
            }
            updateCanvasSize();
            showMessage(`គុណភាពវីដេអូថតត្រូវបានផ្លាស់ប្តូរទៅជា "${recordingQualitySelect.options[recordingQualitySelect.selectedIndex].text}"។`, false, true);
        });


        // Visualizer Type checkboxes change
        visualizerCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const visualizerType = checkbox.value;
                if (checkbox.checked) {
                    // Add or move to end if re-selected
                    activeVisualizerOrder = activeVisualizerOrder.filter(item => item.type !== visualizerType); // Remove if exists
                    activeVisualizerOrder.push({ type: visualizerType, timestamp: Date.now() });
                } else {
                    // Remove if unchecked
                    activeVisualizerOrder = activeVisualizerOrder.filter(item => item.type !== visualizerType);
                    // Clear particles for specific visualizer types when unchecked
                    switch (visualizerType) {
                        case 'falling-particles': fallingParticles.length = 0; break;
                        case 'rising-particles': risingParticles.length = 0; break;
                        case 'leftward-particles': leftwardParticles.length = 0; break;
                        case 'rightward-particles': rightwardParticles.length = 0; break;
                        case 'colorful-particles': colorfulParticles.length = 0; break;
                    }
                }
                drawVisualizer(); // Redraw canvas with new visualizer type order
                const selectedTypes = activeVisualizerOrder.map(item => {
                    // Find the label text for the visualizerType
                    const labelElement = document.querySelector(`.visualizer-checkbox[value="${item.type}"]`).parentNode;
                    return labelElement ? labelElement.textContent.trim() : item.type;
                }).join(', ');

                if (selectedTypes) {
                    showMessage(`ប្រភេទចលនាត្រូវបានផ្លាស់ប្តូរទៅជា: ${selectedTypes}។`, false, true);
                } else {
                    showMessage('ចលនាទាំងអស់ត្រូវបានបិទ។', false, true);
                }
            });
        });


        // Canvas Filter selection
        canvasFilterSelect.addEventListener('change', () => {
            drawVisualizer(); // Redraw canvas with new filter
            showMessage(`តម្រងរូបភាពត្រូវបានផ្លាស់ប្តូរទៅជា "${canvasFilterSelect.options[canvasFilterSelect.selectedIndex].text}"។`, false, true);
        });

        // Logo Position selection
        logoPositionSelect.addEventListener('change', drawVisualizer);

        // Logo Size control
        logoSizeSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new logo size
        });

        // Auto Logo Size checkbox control
        autoLogoSizeCheckbox.addEventListener('change', () => {
            logoSizeSlider.disabled = autoLogoSizeCheckbox.checked;
            drawVisualizer(); // Redraw canvas with new logo sizing mode
        });

        // Font URL loading
        loadFontUrlBtn.addEventListener('click', () => {
            loadFontFromUrl(fontUrlInput.value);
        });

        // Font File loading
        loadFontFileBtn.addEventListener('click', () => {
            if (fontFileInput.files.length > 0) {
                loadFontFromFile(fontFileInput.files[0], customFontNameInput.value);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Font ដើម្បីផ្ទុក។', true);
            }
        });

        // Font selection change
        // This is the global fontSelect, now it's only for loading new fonts, not for direct selection
        // Individual text layers have their own font selects.
        // fontSelect.addEventListener('change', drawVisualizer); // Removed this listener as it's no longer global control


        // Fullscreen functionality
        fullscreenBtn.addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
                showMessage('ចេញពីរបៀបពេញអេក្រង់។', false, true);
            } else {
                // Request fullscreen for the canvas container to make the visualizer area fullscreen
                canvasContainer.requestFullscreen().then(() => {
                    showMessage('ចូលទៅរបៀបពេញអេក្រង់។', false, true);
                }).catch(err => {
                    showMessage(`មិនអាចចូលទៅរបៀបពេញអេក្រង់បានទេ: ${err.message}`, true);
                });
            }
        });

        // Update button text and canvas size on fullscreen change
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                fullscreenBtn.textContent = 'ចេញពីពេញអេក្រង់';
            } else {
                fullscreenBtn.textContent = 'ពេញអេក្រង់';
            }
            updateCanvasSize(); // Update canvas size after fullscreen change
        });


        // Function to update canvas size based on its container
        function updateCanvasSize() {
            const selectedQuality = recordingQualitySelect.value;
            const selectedAspectRatio = aspectRatioSelect.value; // Get current aspect ratio from dropdown

            // Remove all existing aspect ratio classes
            canvasContainer.classList.remove('aspect-ratio-16-9', 'aspect-ratio-9-16', 'aspect-ratio-1-1');
            canvasContainer.classList.remove('fixed-size'); // Remove fixed-size class if it was applied

            if (selectedQuality === 'auto') {
                // Revert to responsive behavior based on aspect ratio
                canvasContainer.style.width = ''; // Clear fixed width
                canvasContainer.style.height = ''; // Clear fixed height
                canvasContainer.classList.add(`aspect-ratio-${selectedAspectRatio}`); // Re-apply aspect ratio class

                // Set canvas dimensions to match the responsive container's current display size
                visualizerCanvas.width = canvasContainer.offsetWidth;
                visualizerCanvas.height = canvasContainer.offsetHeight;

            } else {
                // Fixed resolution selected
                let width, height;
                switch (selectedQuality) {
                    case '1920x1080': width = 1920; height = 1080; break;
                    case '1280x720': width = 1280; height = 720; break;
                    case '1080x1920': width = 1080; height = 1920; break;
                    case '1080x1080': width = 1080; height = 1080; break;
                    default: // Fallback to current responsive size if somehow an invalid fixed quality is selected
                        width = canvasContainer.offsetWidth;
                        height = canvasContainer.offsetHeight;
                        break;
                }

                // Set canvas to exact pixel dimensions for recording
                visualizerCanvas.width = width;
                visualizerCanvas.height = height;

                // Set container to match canvas size, overriding responsive padding
                canvasContainer.style.width = `${width}px`;
                canvasContainer.style.height = `${height}px`;
                canvasContainer.classList.add('fixed-size'); // Add a class to ensure padding-bottom is 0
            }
            drawVisualizer(); // Redraw content after resizing
        }

        // --- Text Layer Management Functions ---
        let textLayerCounter = 0; // To give unique IDs to text layers

        function createAndAddTextLayer(initialContent = '', isSubtitle = false) {
            const templateClone = textLayerTemplate.content.cloneNode(true);
            const textLayerDiv = templateClone.querySelector('.text-layer-controls');
            const id = textLayerCounter++; // Use id for unique identification
            textLayerDiv.dataset.id = id; // Store id in dataset for easy lookup

            const textArea = textLayerDiv.querySelector('textarea');
            const colorInput = textLayerDiv.querySelector('input[type="color"]');
            const sizeInput = textLayerDiv.querySelector('input[type="number"]');
            const positionSelect = textLayerDiv.querySelector('select.text-position-select');
            const boldCheckbox = textLayerDiv.querySelector('.text-bold-checkbox');
            const shadowCheckbox = textLayerDiv.querySelector('.text-shadow-checkbox');
            const blurCheckbox = textLayerDiv.querySelector('.text-blur-checkbox');
            const animationTypeSelect = textLayerDiv.querySelector('.text-animation-type-select');
            const removeBtn = textLayerDiv.querySelector('.btn-remove');
            const startMinInput = textLayerDiv.querySelector('.text-start-min');
            const startSecInput = textLayerDiv.querySelector('.text-start-sec');
            const endMinInput = textLayerDiv.querySelector('.text-end-min');
            const endSecInput = textLayerDiv.querySelector('.text-end-sec');

            // New text styling inputs
            const textOutlineColorInput = textLayerDiv.querySelector('.text-outline-color-input');
            const textOutlineWidthInput = textLayerDiv.querySelector('.text-outline-width-input');
            const textShadowColorInput = textLayerDiv.querySelector('.text-shadow-color-input');
            const textShadowBlurInput = textLayerDiv.querySelector('.text-shadow-blur-input'); // New shadow blur input
            const textMarginLeftInput = textLayerDiv.querySelector('.text-margin-left-input');
            const textMarginRightInput = textLayerDiv.querySelector('.text-margin-right-input');
            const textMarginVerticalInput = textLayerDiv.querySelector('.text-margin-vertical-input');
            const textScaleXInput = textLayerDiv.querySelector('.text-scale-x-input');
            const textScaleYInput = textLayerDiv.querySelector('.text-scale-y-input');
            const textRotationInput = textLayerDiv.querySelector('.text-rotation-input');
            const textSpacingInput = textLayerDiv.querySelector('.text-spacing-input');
            const textFontSelect = textLayerDiv.querySelector('select.font-select'); // Get font select for this layer


            // Initialize text layer object
            const newTextLayer = {
                id: id, // Assign unique ID
                content: initialContent,
                color: colorInput.value,
                size: parseInt(sizeInput.value),
                position: positionSelect.value,
                bold: boldCheckbox.checked,
                shadow: shadowCheckbox.checked,
                blur: blurCheckbox.checked,
                animationType: animationTypeSelect.value,
                startTimeMinutes: parseInt(startMinInput.value),
                startTimeSeconds: parseInt(startSecInput.value),
                endTimeMinutes: parseInt(endMinInput.value),
                endTimeSeconds: parseInt(endSecInput.value),
                // New properties
                outlineColor: textOutlineColorInput.value,
                outlineWidth: parseFloat(textOutlineWidthInput.value),
                shadowColor: textShadowColorInput.value,
                shadowBlur: parseFloat(textShadowBlurInput.value), // Initialize new shadow blur
                marginLeft: parseFloat(textMarginLeftInput.value),
                marginRight: parseFloat(textMarginRightInput.value),
                marginVertical: parseFloat(textMarginVerticalInput.value),
                scaleX: parseFloat(textScaleXInput.value),
                scaleY: parseFloat(textScaleYInput.value),
                rotation: parseFloat(textRotationInput.value),
                spacing: parseFloat(textSpacingInput.value),
                fontFamily: defaultFontOptions[0].value, // Default to first font option
                // Animation state variables (will be updated in drawVisualizer)
                currentOffsetX: 0,
                currentOffsetY: 0,
                currentAlpha: 1,
                currentScale: 1
            };

            // Apply subtitle presets if requested
            if (isSubtitle) {
                newTextLayer.content = initialContent;
                newTextLayer.color = '#ffffff';
                newTextLayer.size = 40;
                newTextLayer.position = 'bottom-center';
                newTextLayer.bold = true;
                newTextLayer.shadow = true;
                newTextLayer.shadowColor = 'rgba(0,0,0,0.8)';
                newTextLayer.shadowBlur = 5; // Preset blur for subtitle
                newTextLayer.outlineWidth = 2;
                newTextLayer.outlineColor = '#000000';
                newTextLayer.animationType = 'none'; // Subtitles usually don't animate by default
                newTextLayer.blur = false;
                newTextLayer.marginVertical = -20; // Slightly move up for subtitle effect
                newTextLayer.fontFamily = 'Noto Sans Khmer'; // Default font for subtitle

                // Update controls to reflect presets
                textArea.value = newTextLayer.content;
                colorInput.value = newTextLayer.color;
                sizeInput.value = newTextLayer.size;
                positionSelect.value = newTextLayer.position;
                boldCheckbox.checked = newTextLayer.bold;
                shadowCheckbox.checked = newTextLayer.shadow;
                blurCheckbox.checked = newTextLayer.blur;
                animationTypeSelect.value = newTextLayer.animationType;
                textOutlineColorInput.value = newTextLayer.outlineColor;
                textOutlineWidthInput.value = newTextLayer.outlineWidth;
                textShadowColorInput.value = newTextLayer.shadowColor;
                textShadowBlurInput.value = newTextLayer.shadowBlur; // Set preset blur value
                textMarginVerticalInput.value = newTextLayer.marginVertical;
            }

            textLayers.push(newTextLayer);

            // Populate font select options for this new layer
            textFontSelect.innerHTML = ''; // Clear existing options
            defaultFontOptions.forEach(font => {
                const option = new Option(font.text, font.value);
                textFontSelect.add(option);
            });
            textFontSelect.value = newTextLayer.fontFamily; // Set the selected font

            // Set initial values from object to controls
            textArea.value = initialContent;

            // Attach event listeners
            textArea.addEventListener('input', () => {
                newTextLayer.content = textArea.value;
                drawVisualizer();
            });
            colorInput.addEventListener('input', () => {
                newTextLayer.color = colorInput.value;
                drawVisualizer();
            });
            sizeInput.addEventListener('input', () => {
                newTextLayer.size = parseInt(sizeInput.value);
                drawVisualizer();
            });
            positionSelect.addEventListener('change', () => {
                newTextLayer.position = positionSelect.value;
                drawVisualizer();
            });
            boldCheckbox.addEventListener('change', () => {
                newTextLayer.bold = boldCheckbox.checked;
                drawVisualizer();
            });
            shadowCheckbox.addEventListener('change', () => {
                newTextLayer.shadow = shadowCheckbox.checked;
                drawVisualizer();
            });
            blurCheckbox.addEventListener('change', () => {
                newTextLayer.blur = blurCheckbox.checked;
                drawVisualizer();
            });
            animationTypeSelect.addEventListener('change', () => {
                newTextLayer.animationType = animationTypeSelect.value;
                drawVisualizer();
            });
            startMinInput.addEventListener('input', () => {
                newTextLayer.startTimeMinutes = parseInt(startMinInput.value) || 0;
                drawVisualizer();
            });
            startSecInput.addEventListener('input', () => {
                newTextLayer.startTimeSeconds = parseInt(startSecInput.value) || 0;
                drawVisualizer();
            });
            endMinInput.addEventListener('input', () => {
                newTextLayer.endTimeMinutes = parseInt(endMinInput.value) || 0;
                drawVisualizer();
            });
            endSecInput.addEventListener('input', () => {
                newTextLayer.endTimeSeconds = parseInt(endSecInput.value) || 0;
                drawVisualizer();
            });
            removeBtn.addEventListener('click', () => {
                removeTextLayer(id); // Use id for removal
            });

            // New event listeners for text styling and transformations
            textOutlineColorInput.addEventListener('input', () => { newTextLayer.outlineColor = textOutlineColorInput.value; drawVisualizer(); });
            textOutlineWidthInput.addEventListener('input', () => { newTextLayer.outlineWidth = parseFloat(textOutlineWidthInput.value); drawVisualizer(); });
            textShadowColorInput.addEventListener('input', () => { newTextLayer.shadowColor = textShadowColorInput.value; drawVisualizer(); });
            textShadowBlurInput.addEventListener('input', () => { newTextLayer.shadowBlur = parseFloat(textShadowBlurInput.value); drawVisualizer(); }); // Event listener for new shadow blur
            textMarginLeftInput.addEventListener('input', () => { newTextLayer.marginLeft = parseFloat(textMarginLeftInput.value); drawVisualizer(); });
            textMarginRightInput.addEventListener('input', () => { newTextLayer.marginRight = parseFloat(textMarginRightInput.value); drawVisualizer(); });
            textMarginVerticalInput.addEventListener('input', () => { newTextLayer.marginVertical = parseFloat(textMarginVerticalInput.value); drawVisualizer(); });
            textScaleXInput.addEventListener('input', () => { newTextLayer.scaleX = parseFloat(textScaleXInput.value); drawVisualizer(); });
            textScaleYInput.addEventListener('input', () => { newTextLayer.scaleY = parseFloat(textScaleYInput.value); drawVisualizer(); });
            textRotationInput.addEventListener('input', () => { newTextLayer.rotation = parseFloat(textRotationInput.value); drawVisualizer(); });
            textSpacingInput.addEventListener('input', () => { newTextLayer.spacing = parseFloat(textSpacingInput.value); drawVisualizer(); });
            textFontSelect.addEventListener('change', () => { // Event listener for individual font select
                newTextLayer.fontFamily = textFontSelect.value;
                drawVisualizer();
            });


            textLayersContainer.appendChild(textLayerDiv);
            drawVisualizer(); // Redraw to show new text layer
        }

        function removeTextLayer(idToRemove) {
            // Find the actual DOM element for the text layer
            const elementToRemove = textLayersContainer.querySelector(`[data-id="${idToRemove}"]`);
            if (elementToRemove) {
                // Find the corresponding object in the textLayers array and remove it
                const foundIndex = textLayers.findIndex(layer => layer.id === idToRemove);
                
                if (foundIndex > -1) {
                    textLayers.splice(foundIndex, 1); // Remove from data array
                }
                
                elementToRemove.remove(); // Remove from DOM
                showMessage('អត្ថបទត្រូវបានលុប។', false, true);
                drawVisualizer(); // Redraw after removal
            }
        }

        addTextLayerBtn.addEventListener('click', () => {
            createAndAddTextLayer(''); // Add a new empty text layer
        });

        addSubtitleLayerBtn.addEventListener('click', () => {
            createAndAddTextLayer('បញ្ចូល Subtitle នៅទីនេះ', true); // Add a new subtitle layer with presets
        });


        // --- Image Layer Management Functions ---
        let imageLayerCounter = 0; // To give unique IDs to image layers

        function createAndAddImageLayer() {
            const templateClone = imageLayerTemplate.content.cloneNode(true);
            const imageLayerDiv = templateClone.querySelector('.image-layer-controls');
            const id = imageLayerCounter++; // Use id for unique identification
            imageLayerDiv.dataset.id = id;

            const imageFileInput = imageLayerDiv.querySelector('.image-file-input');
            const imagePreviewThumbnail = imageLayerDiv.querySelector('.image-preview-thumbnail');
            const imageSizeSlider = imageLayerDiv.querySelector('.image-size-slider');
            const autoImageSizeCheckbox = imageLayerDiv.querySelector('.auto-image-size-checkbox');
            const imagePositionSelect = imageLayerDiv.querySelector('.image-position-select');
            const imagePulseCheckbox = imageLayerDiv.querySelector('.image-pulse-checkbox');
            const removeBtn = imageLayerDiv.querySelector('.btn-remove');

            const newImageLayer = {
                id: id,
                img: new Image(),
                isLoaded: false,
                src: '',
                size: parseFloat(imageSizeSlider.value),
                autoSize: autoImageSizeCheckbox.checked,
                position: imagePositionSelect.value,
                pulse: imagePulseCheckbox.checked
            };
            imageLayers.push(newImageLayer);

            // Set initial state of controls
            imageSizeSlider.disabled = newImageLayer.autoSize;

            // Event Listeners
            imageFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        newImageLayer.src = e.target.result;
                        newImageLayer.img.src = e.target.result;
                        newImageLayer.img.onload = () => {
                            newImageLayer.isLoaded = true;
                            imagePreviewThumbnail.src = newImageLayer.src;
                            drawVisualizer();
                            showMessage(`រូបភាព "${file.name}" ត្រូវបានផ្ទុក។`);
                        };
                        newImageLayer.img.onerror = () => {
                            newImageLayer.isLoaded = false;
                            showMessage('មិនអាចផ្ទុករូបភាពបានទេ។', true);
                        };
                    };
                    reader.readAsDataURL(file);
                } else {
                    newImageLayer.isLoaded = false;
                    imagePreviewThumbnail.src = '';
                    showMessage('សូមជ្រើសរើសរូបភាព។', true);
                }
            });

            imageSizeSlider.addEventListener('input', () => {
                newImageLayer.size = parseFloat(imageSizeSlider.value);
                drawVisualizer();
            });

            autoImageSizeCheckbox.addEventListener('change', () => {
                newImageLayer.autoSize = autoImageSizeCheckbox.checked;
                imageSizeSlider.disabled = newImageLayer.autoSize;
                drawVisualizer();
            });

            imagePositionSelect.addEventListener('change', () => {
                newImageLayer.position = imagePositionSelect.value;
                drawVisualizer();
            });

            imagePulseCheckbox.addEventListener('change', () => {
                newImageLayer.pulse = imagePulseCheckbox.checked;
                drawVisualizer();
            });

            removeBtn.addEventListener('click', () => {
                removeImageLayer(id); // Use id for removal
            });

            imageLayersContainer.appendChild(imageLayerDiv);
            drawVisualizer();
        }

        function removeImageLayer(idToRemove) {
            const elementToRemove = imageLayersContainer.querySelector(`[data-id="${idToRemove}"]`);
            if (elementToRemove) {
                const foundIndex = imageLayers.findIndex(layer => layer.id === idToRemove);
                if (foundIndex > -1) {
                    imageLayers.splice(foundIndex, 1);
                }
                elementToRemove.remove();
                showMessage('រូបភាពត្រូវបានលុប។', false, true);
                drawVisualizer();
            }
        }

        addImageLayerBtn.addEventListener('click', () => {
            createAndAddImageLayer();
        });


        // --- Drawing Functions for each Visualizer Type ---
        function drawImageLayer(ctx, canvasWidth, canvasHeight, activeMusicScaleFactor, imageLayer) {
            if (!imageLayer.isLoaded) return;

            ctx.save();

            let initialDrawWidth, initialDrawHeight;
            if (imageLayer.autoSize) {
                const imgAspectRatio = imageLayer.img.width / imageLayer.img.height;
                const canvasAspectRatio = canvasWidth / canvasHeight;
                if (imgAspectRatio > canvasAspectRatio) {
                    initialDrawWidth = canvasWidth;
                    initialDrawHeight = canvasWidth / imgAspectRatio;
                } else {
                    initialDrawHeight = canvasHeight;
                    initialDrawWidth = canvasHeight * imgAspectRatio;
                }
            } else {
                initialDrawWidth = imageLayer.img.width * imageLayer.size;
                initialDrawHeight = imageLayer.img.height * imageLayer.size;
                const imgAspectRatio = imageLayer.img.width / imageLayer.img.height;
                if (initialDrawWidth > canvasWidth || initialDrawHeight > canvasHeight) {
                    if (imgAspectRatio > canvasWidth / canvasHeight) {
                        initialDrawWidth = canvasWidth;
                        initialDrawHeight = canvasWidth / imgAspectRatio;
                    } else {
                        initialDrawHeight = canvasHeight;
                        initialDrawWidth = canvasHeight * imgAspectRatio;
                    }
                }
            }

            let finalDrawWidth = initialDrawWidth;
            let finalDrawHeight = initialDrawHeight;

            if (imageLayer.pulse) {
                const minScaleLimit = 0.5;
                const maxScaleLimit = 2.0;
                finalDrawWidth = initialDrawWidth * activeMusicScaleFactor;
                finalDrawHeight = initialDrawHeight * activeMusicScaleFactor;
                finalDrawWidth = Math.max(initialDrawWidth * minScaleLimit, Math.min(initialDrawWidth * maxScaleLimit, finalDrawWidth));
                finalDrawHeight = Math.max(initialDrawHeight * minScaleLimit, Math.min(initialDrawHeight * maxScaleLimit, finalDrawHeight));
            }

            let drawX, drawY;
            switch(imageLayer.position) {
                case 'bottom-center':
                    drawX = (canvasWidth - finalDrawWidth) / 2;
                    drawY = canvasHeight - finalDrawHeight;
                    break;
                case 'top-center':
                    drawX = (canvasWidth - finalDrawWidth) / 2;
                    drawY = 0;
                    break;
                case 'center-left':
                    drawX = 0;
                    drawY = (canvasHeight - finalDrawHeight) / 2;
                    break;
                case 'center-right':
                    drawX = canvasWidth - finalDrawWidth;
                    drawY = (canvasHeight - finalDrawHeight) / 2;
                    break;
                case 'top-left':
                    drawX = 0;
                    drawY = 0;
                    break;
                case 'top-right':
                    drawX = canvasWidth - finalDrawWidth;
                    drawY = 0;
                    break;
                case 'bottom-left':
                    drawX = 0;
                    drawY = canvasHeight - finalDrawHeight;
                    break;
                case 'bottom-right':
                    drawX = canvasWidth - finalDrawWidth;
                    drawY = canvasHeight - finalDrawHeight;
                    break;
                case 'center':
                default:
                    drawX = (canvasWidth - finalDrawWidth) / 2;
                    drawY = (canvasHeight - finalDrawHeight) / 2;
                    break;
            }

            ctx.drawImage(imageLayer.img, drawX, drawY, finalDrawWidth, finalDrawHeight);
            ctx.restore();
        }


        function drawBars(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMusicScaleFactor) {
            const barWidth = (canvasWidth / bufferLength) * 2.5;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i] * activeMusicScaleFactor * 1.5;
                ctx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                ctx.fillRect(x, canvasHeight - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function drawCirclePulse(ctx, canvasWidth, canvasHeight, activeMusicScaleFactor, average, visualizerIntensity) {
            ctx.save();
            ctx.beginPath();
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const baseRadius = Math.min(canvasWidth, canvasHeight) * 0.2;
            const pulseRadius = baseRadius * activeMusicScaleFactor;
            ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(66, 153, 225, ${0.5 + (average / 255) * 0.5 * visualizerIntensity})`;
            ctx.fill();
            ctx.closePath();
            ctx.restore();
        }

        function drawWave(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMidScaleFactor) {
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = '#4299e1';
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            const sliceWidth = canvasWidth * 1.0 / bufferLength;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = canvasHeight / 2 + v * (canvasHeight / 4) * activeMidScaleFactor;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                x += sliceWidth;
            }
            ctx.lineTo(canvasWidth, canvasHeight / 2);
            ctx.stroke();
            ctx.restore();
        }

        function drawRadialBars(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeBassScaleFactor) {
            ctx.save();
            ctx.translate(canvasWidth / 2, canvasHeight / 2);
            const radius = Math.min(canvasWidth, canvasHeight) * 0.2;
            const barCount = bufferLength / 2;
            const barAngle = (Math.PI * 2) / barCount;
            for (let i = 0; i < barCount; i++) {
                const barHeight = dataArray[i] * activeBassScaleFactor * 0.8;
                ctx.rotate(barAngle);
                ctx.fillStyle = `hsl(${i * (360 / barCount)}, 100%, 50%)`;
                ctx.fillRect(radius, 0, 5, -barHeight);
            }
            ctx.restore();
        }

        function drawParticleSwarm(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray) {
            initializeParticleArray(fallingParticles, canvasWidth, canvasHeight);

            const baseSpeed = 1; // Minimum speed
            const musicInfluence = (average / 255) * 10 * visualizerIntensity; // Max influence from music

            for (let i = 0; i < fallingParticles.length; i++) {
                const particle = fallingParticles[i];
                particle.speedY = baseSpeed + (dataArray[Math.floor(i / fallingParticles.length * bufferLength)] / 255) * musicInfluence;
                particle.speedX = 0; // No horizontal movement for falling

                particle.update();
                if (particle.y > canvasHeight) {
                    particle.y = 0;
                    particle.x = Math.random() * canvasWidth;
                }
                particle.draw(ctx);
            }
        }

        // Rising Particles visualization
        function drawRisingParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray) {
            initializeParticleArray(risingParticles, canvasWidth, canvasHeight);

            const baseSpeed = 1; // Minimum speed
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < risingParticles.length; i++) {
                const particle = risingParticles[i];
                particle.speedY = -(baseSpeed + (dataArray[Math.floor(i / risingParticles.length * bufferLength)] / 255) * musicInfluence); // Move upwards
                particle.speedX = 0;

                particle.update();
                if (particle.y < 0) {
                    particle.y = canvasHeight;
                    particle.x = Math.random() * canvasWidth;
                }
                particle.draw(ctx);
            }
        }

        // Leftward Particles visualization
        function drawLeftwardParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray) {
            initializeParticleArray(leftwardParticles, canvasWidth, canvasHeight);

            const baseSpeed = 1; // Minimum speed
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < leftwardParticles.length; i++) {
                const particle = leftwardParticles[i];
                particle.speedX = -(baseSpeed + (dataArray[Math.floor(i / leftwardParticles.length * bufferLength)] / 255) * musicInfluence); // Move leftwards
                particle.speedY = 0;

                particle.update();
                if (particle.x < 0) {
                    particle.x = canvasWidth;
                    particle.y = Math.random() * canvasHeight;
                }
                particle.draw(ctx);
            }
        }

        // Rightward Particles visualization
        function drawRightwardParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray) {
            initializeParticleArray(rightwardParticles, canvasWidth, canvasHeight);

            const baseSpeed = 1; // Minimum speed
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < rightwardParticles.length; i++) {
                const particle = rightwardParticles[i];
                particle.speedX = baseSpeed + (dataArray[Math.floor(i / rightwardParticles.length * bufferLength)] / 255) * musicInfluence; // Move rightwards
                particle.speedY = 0;

                particle.update();
                if (particle.x > canvasWidth) {
                    particle.x = 0;
                    particle.y = Math.random() * canvasHeight;
                }
                particle.draw(ctx);
            }
        }

        // Colorful Particles visualization (falling by default, but with dynamic colors)
        function drawColorfulParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray) {
            initializeParticleArray(colorfulParticles, canvasWidth, canvasHeight);

            const baseSpeed = 1;
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < colorfulParticles.length; i++) {
                const particle = colorfulParticles[i];
                particle.speedY = baseSpeed + (dataArray[Math.floor(i / colorfulParticles.length * bufferLength)] / 255) * musicInfluence; // Falling motion
                particle.speedX = 0;

                // Update particle color based on frequency data
                const hue = (dataArray[Math.floor(i / colorfulParticles.length * bufferLength)] / 255) * 360;
                particle.color = `hsl(${hue}, 100%, 70%)`; // Dynamic color

                particle.update();
                if (particle.y > canvasHeight) {
                    particle.y = 0;
                    particle.x = Math.random() * canvasWidth;
                }
                particle.draw(ctx);
            }
        }


        function drawConnectingLines(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMusicScaleFactor, visualizerIntensity, average) {
            ctx.save();
            ctx.strokeStyle = `rgba(66, 153, 225, ${0.5 + (average / 255) * 0.5 * visualizerIntensity})`;
            ctx.lineWidth = 1;
            const sliceWidth = canvasWidth * 1.0 / bufferLength;
            const points = [];
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 255.0;
                const x = i * sliceWidth;
                const y = canvasHeight / 2 + (v - 0.5) * canvasHeight * 0.4 * activeMusicScaleFactor;
                points.push({ x, y });
            }
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    const dist = Math.sqrt(Math.pow(points[i].x - points[j].x, 2) + Math.pow(points[i].y - points[j].y, 2));
                    if (dist < 150) {
                        ctx.beginPath();
                        ctx.moveTo(points[i].x, points[i].y);
                        ctx.lineTo(points[j].x, points[j].y);
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();
        }


        // Main drawVisualizer function
        function drawVisualizer(currentTime) {
            // Request next frame if not recording, or if recording is active
            // Ensure mediaRecorder is defined before checking its state
            if (!isRecording || (isRecording && mediaRecorder && mediaRecorder.state === 'recording')) {
                animationFrameId = requestAnimationFrame(drawVisualizer);
            } else if (isRecording && mediaRecorder && mediaRecorder.state === 'inactive') {
                // If recording just stopped, don't request next frame
                cancelAnimationFrame(animationFrameId);
                return;
            }


            // Calculate delta time for smooth animation
            if (!lastFrameTime) lastFrameTime = currentTime;
            const deltaTime = (currentTime - lastFrameTime) / 1000; // in seconds
            lastFrameTime = currentTime;

            if (!analyser || !dataArray) {
                return; // Ensure analyser is initialized
            }

            analyser.getByteFrequencyData(dataArray); // Get frequency data

            const canvasWidth = visualizerCanvas.width;
            const canvasHeight = visualizerCanvas.height;

            // Determine filter to apply: 'none' if recording without filter, otherwise selected filter
            let currentFilterToApply = canvasFilterSelect.value;
            if (isRecording && recordWithoutFilterCheckbox.checked) {
                currentFilterToApply = 'none';
            }
            ctx.filter = currentFilterToApply;

            // Clear canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Draw background image if loaded
            if (isBgImageLoaded) {
                ctx.save(); // Save context before transforming background

                const motionType = backgroundMotionTypeSelect.value;
                const motionSpeed = parseFloat(backgroundMotionSpeedSlider.value);

                // Calculate common audio properties (average amplitude) for background motion
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                let average = sum / bufferLength;
                let activeMusicScaleFactor = 1 + ((average / 255) * 0.4 * parseFloat(visualizerIntensitySlider.value));

                let drawWidth, drawHeight, drawX, drawY;

                if (autoBackgroundSizeCheckbox.checked) {
                    // "Cover" behavior for background (auto)
                    const imgAspectRatio = bgImg.width / bgImg.height;
                    const canvasAspectRatio = canvasWidth / canvasHeight;

                    let sx = 0, sy = 0, sWidth = bgImg.width, sHeight = bgImg.height;
                    let dx = 0, dy = 0, dWidth = canvasWidth, dHeight = canvasHeight;

                    if (imgAspectRatio > canvasAspectRatio) {
                        // Image is wider than canvas, need to crop width
                        sWidth = bgImg.height * canvasAspectRatio;
                        sx = (bgImg.width - sWidth) / 2;
                    } else {
                        // Image is taller than canvas, need to crop height
                        sHeight = bgImg.width / canvasAspectRatio;
                        sy = (bgImg.height - sHeight) / 2;
                    }

                    drawWidth = dWidth;
                    drawHeight = dHeight;
                    drawX = dx;
                    drawY = dy;

                    // Apply zoom motion
                    if (motionType === 'zoom') {
                        const zoomFactor = 1 + (activeMusicScaleFactor - 1) * motionSpeed * 2; // More pronounced zoom
                        drawWidth *= zoomFactor;
                        drawHeight *= zoomFactor;
                        drawX = (canvasWidth - drawWidth) / 2;
                        drawY = (canvasHeight - drawHeight) / 2;
                    }

                    // Apply transformations for pan/rotate
                    if (motionType === 'pan-horizontal') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor; // Pixels per second
                        backgroundPanOffset.x = (backgroundPanOffset.x + panSpeed * deltaTime) % drawWidth;
                        ctx.translate(backgroundPanOffset.x, 0);
                    } else if (motionType === 'pan-vertical') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor; // Pixels per second
                        backgroundPanOffset.y = (backgroundPanOffset.y + panSpeed * deltaTime) % drawHeight;
                        ctx.translate(0, backgroundPanOffset.y);
                    } else if (motionType === 'rotate') {
                        const rotationSpeed = Math.PI / 4 * motionSpeed * activeMusicScaleFactor; // Radians per second
                        backgroundRotation = (backgroundRotation + rotationSpeed * deltaTime) % (Math.PI * 2);
                        ctx.translate(canvasWidth / 2, canvasHeight / 2);
                        ctx.rotate(backgroundRotation);
                        ctx.translate(-canvasWidth / 2, -canvasHeight / 2);
                    }

                    ctx.drawImage(bgImg, sx, sy, sWidth, sHeight, drawX, drawY, drawWidth, drawHeight);

                } else {
                    // Manual size control with slider
                    const backgroundScale = parseFloat(backgroundSizeSlider.value);
                    let initialDrawWidth = bgImg.width * backgroundScale;
                    let initialDrawHeight = bgImg.height * backgroundScale;

                    // Apply zoom motion
                    if (motionType === 'zoom') {
                        const zoomFactor = 1 + (activeMusicScaleFactor - 1) * motionSpeed * 2;
                        initialDrawWidth *= zoomFactor;
                        initialDrawHeight *= zoomFactor;
                    }

                    // Determine position based on backgroundAlignmentSelect
                    const alignment = backgroundAlignmentSelect.value;
                    switch (alignment) {
                        case 'top-left':
                            drawX = 0;
                            drawY = 0;
                            break;
                        case 'top-center':
                            drawX = (canvasWidth - initialDrawWidth) / 2;
                            drawY = 0;
                            break;
                        case 'top-right':
                            drawX = canvasWidth - initialDrawWidth;
                            drawY = 0;
                            break;
                        case 'center-left':
                            drawX = 0;
                            drawY = (canvasHeight - initialDrawHeight) / 2;
                            break;
                        case 'center':
                            drawX = (canvasWidth - initialDrawWidth) / 2;
                            drawY = (canvasHeight - initialDrawHeight) / 2;
                            break;
                        case 'center-right':
                            drawX = canvasWidth - initialDrawWidth;
                            drawY = (canvasHeight - initialDrawHeight) / 2;
                            break;
                        case 'bottom-left':
                            drawX = 0;
                            drawY = canvasHeight - initialDrawHeight;
                            break;
                        case 'bottom-center':
                            drawX = (canvasWidth - initialDrawWidth) / 2;
                            drawY = canvasHeight - initialDrawHeight;
                            break;
                        case 'bottom-right':
                            drawX = canvasWidth - initialDrawWidth;
                            drawY = canvasHeight - initialDrawHeight;
                            break;
                        default: // Fallback to center
                            drawX = (canvasWidth - initialDrawWidth) / 2;
                            drawY = (canvasHeight - initialDrawHeight) / 2;
                            break;
                    }

                    // Apply transformations for pan/rotate
                    if (motionType === 'pan-horizontal') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor;
                        backgroundPanOffset.x = (backgroundPanOffset.x + panSpeed * deltaTime) % initialDrawWidth;
                        ctx.translate(drawX + backgroundPanOffset.x, drawY); // Apply offset relative to aligned position
                        drawX = 0; // Reset drawX as it's handled by translate
                        drawY = 0; // Reset drawY as it's handled by translate
                    } else if (motionType === 'pan-vertical') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor;
                        backgroundPanOffset.y = (backgroundPanOffset.y + panSpeed * deltaTime) % initialDrawHeight;
                        ctx.translate(drawX, drawY + backgroundPanOffset.y); // Apply offset relative to aligned position
                        drawY = 0; // Reset drawY
                        drawX = 0; // Reset drawX
                    } else if (motionType === 'rotate') {
                        const rotationSpeed = Math.PI / 4 * motionSpeed * activeMusicScaleFactor;
                        backgroundRotation = (backgroundRotation + rotationSpeed * deltaTime) % (Math.PI * 2);
                        ctx.translate(canvasWidth / 2, canvasHeight / 2);
                        ctx.rotate(backgroundRotation);
                        ctx.translate(-canvasWidth / 2, -canvasHeight / 2);
                    }

                    ctx.drawImage(bgImg, drawX, drawY, initialDrawWidth, initialDrawHeight);
                }
                ctx.restore(); // Restore context after transforming background
            } else {
                // Fallback to solid background color if no image
                ctx.fillStyle = '#1a202c'; // Dark background for canvas
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }


            // Calculate common audio properties (average amplitude)
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            let average = sum / bufferLength;

            // Calculate averages for different frequency bands (simulating instrument/voice reaction)
            let bassSum = 0;
            for (let i = 0; i < bufferLength * 0.25; i++) { // Roughly 0-25% for bass
                bassSum += dataArray[i];
            }
            let bassAverage = bassSum / (bufferLength * 0.25);

            let midSum = 0;
            for (let i = bufferLength * 0.25; i < bufferLength * 0.75; i++) { // Roughly 25-75% for mids/vocals
                midSum += dataArray[i];
            }
            let midAverage = midSum / (bufferLength * 0.5);

            let trebleSum = 0;
            for (let i = bufferLength * 0.75; i < bufferLength; i++) { // Roughly 75-100% for treble
                trebleSum += dataArray[i];
            }
            let trebleAverage = trebleSum / (bufferLength * 0.25);


            // Base music scale factor (0.8 to 1.2) - uses overall average
            let baseMusicScaleFactor = 1 + (average / 255) * 0.4;

            // Apply intensity from slider
            const visualizerIntensity = parseFloat(visualizerIntensitySlider.value);
            let activeMusicScaleFactor = 1 + ((baseMusicScaleFactor - 1) * visualizerIntensity);
            let activeBassScaleFactor = 1 + ((bassAverage / 255) * 0.4 * visualizerIntensity);
            let activeMidScaleFactor = 1 + ((midAverage / 255) * 0.4 * visualizerIntensity);
            let activeTrebleScaleFactor = 1 + ((trebleAverage / 255) * 0.4 * visualizerIntensity);


            // --- Drawing Logic based on active Visualizer Types ---
            // Iterate through activeVisualizerOrder to draw visualizers
            activeVisualizerOrder.forEach(item => {
                switch (item.type) {
                    case 'bars':
                        drawBars(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMusicScaleFactor);
                        break;
                    case 'circle-pulse':
                        drawCirclePulse(ctx, canvasWidth, canvasHeight, activeMusicScaleFactor, average, visualizerIntensity);
                        break;
                    case 'wave':
                        drawWave(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMidScaleFactor);
                        break;
                    case 'radial-bars':
                        drawRadialBars(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeBassScaleFactor);
                        break;
                    case 'particle-swarm':
                        drawParticleSwarm(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray);
                        break;
                    case 'line-spectrum':
                        drawLineSpectrum(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeTrebleScaleFactor, trebleAverage);
                        break;
                    case 'frequency-circle':
                        drawFrequencyCircle(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMusicScaleFactor);
                        break;
                    case 'falling-particles':
                        drawFallingParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray);
                        break;
                    case 'rising-particles':
                        drawRisingParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray);
                        break;
                    case 'leftward-particles':
                        drawLeftwardParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray);
                        break;
                    case 'rightward-particles':
                        drawRightwardParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray);
                        break;
                    case 'colorful-particles':
                        drawColorfulParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray);
                        break;
                    case 'connecting-lines':
                        drawConnectingLines(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMusicScaleFactor, visualizerIntensity, average);
                        break;
                }
            });

            // --- Draw Image Layers (on top of visualizers) ---
            imageLayers.forEach(imageLayer => {
                drawImageLayer(ctx, canvasWidth, canvasHeight, activeMusicScaleFactor, imageLayer);
            });


            // --- Draw Logo (on top of visualizer) ---
            if (isLogoLoaded) {
                ctx.save();
                let logoDrawSize;
                if (autoLogoSizeCheckbox.checked) {
                    logoDrawSize = 50; // Default auto size
                } else {
                    logoDrawSize = parseFloat(logoSizeSlider.value);
                }

                const padding = 10;
                let logoX, logoY;

                switch (logoPositionSelect.value) {
                    case 'top-left':
                        logoX = padding;
                        logoY = padding;
                        break;
                    case 'top-right':
                        logoX = canvasWidth - logoDrawSize - padding;
                        logoY = padding;
                        break;
                    case 'bottom-left':
                        logoX = padding;
                        logoY = canvasHeight - logoDrawSize - padding;
                        break;
                    case 'bottom-right':
                        logoX = canvasWidth - logoDrawSize - padding;
                        logoY = canvasHeight - logoDrawSize - padding;
                        break;
                    case 'center':
                        logoX = (canvasWidth - logoDrawSize) / 2;
                        logoY = (canvasHeight - logoDrawSize) / 2;
                        break;
                    default: // Default to top-left if somehow value is not found
                        logoX = padding;
                        logoY = padding;
                        break;
                }
                ctx.drawImage(logoImg, logoX, logoY, logoDrawSize, logoDrawSize);
                ctx.restore();
            }

            // --- Draw Custom Text Layers (on top of everything) ---
            textLayers.forEach(textLayer => {
                const text = textLayer.content;
                if (!text) return; // Don't draw empty text layers

                // Calculate start and end times in seconds
                const layerStartTime = (textLayer.startTimeMinutes * 60) + textLayer.startTimeSeconds;
                const layerEndTime = (textLayer.endTimeMinutes * 60) + textLayer.endTimeSeconds;

                // Check if current audio time is within the layer's active time
                const currentAudioTime = audioPlayer.currentTime;
                const shouldDisplay = (currentAudioTime >= layerStartTime) && 
                                      (layerEndTime === 0 || currentAudioTime < layerEndTime);

                if (!shouldDisplay) return; // Skip drawing if not within time range

                ctx.save();
                ctx.fillStyle = textLayer.color;
                
                let fontStyle = '';
                if (textLayer.bold) {
                    fontStyle += 'bold ';
                }
                // Use textLayer.fontFamily directly
                ctx.font = `${fontStyle}${textLayer.size}px "${textLayer.fontFamily.split(',')[0].trim()}", ${textLayer.fontFamily.split(',').slice(1).join(',').trim() || 'sans-serif'}`;
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let textX = canvasWidth / 2;
                let textY = canvasHeight / 2;
                const textPadding = 20; // Padding from edges

                // Base position
                switch (textLayer.position) {
                    case 'top-left':
                        textX = textPadding;
                        textY = textPadding;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        break;
                    case 'top-right':
                        textX = canvasWidth - textPadding;
                        textY = textPadding;
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        break;
                    case 'bottom-left':
                        textX = textPadding;
                        textY = canvasHeight - textPadding;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        break;
                    case 'bottom-right':
                        textX = canvasWidth - textPadding;
                        textY = canvasHeight - textPadding;
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        break;
                    case 'bottom-center':
                        textX = canvasWidth / 2;
                        textY = canvasHeight - textPadding;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        break;
                    case 'center':
                    default:
                        textX = canvasWidth / 2;
                        textY = canvasHeight / 2;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        break;
                }

                // Apply margins
                textX += textLayer.marginLeft;
                textX -= textLayer.marginRight;
                textY += textLayer.marginVertical;


                // Apply text animation
                const textAnimationType = textLayer.animationType;
                const textAnimationIntensity = visualizerIntensity; // Use general visualizer intensity for text animation

                let animatedScale = textLayer.scaleX; // Use textLayer's scaleX as base
                let animatedAlpha = 1;
                let animatedOffsetX = 0;
                let animatedOffsetY = 0;

                switch (textAnimationType) {
                    case 'pulse':
                        animatedScale = textLayer.scaleX * (1 + (activeMusicScaleFactor - 1) * textAnimationIntensity);
                        break;
                    case 'fade':
                        animatedAlpha = 0.5 + (average / 255) * 0.5 * textAnimationIntensity;
                        break;
                    case 'slide-horizontal':
                        animatedOffsetX = (average / 255 - 0.5) * canvasWidth * 0.1 * textAnimationIntensity; // Slide left/right
                        break;
                    case 'slide-vertical':
                        animatedOffsetY = (average / 255 - 0.5) * canvasHeight * 0.1 * textAnimationIntensity; // Slide up/down
                        break;
                }

                // Apply animation transforms
                ctx.translate(textX + animatedOffsetX, textY + animatedOffsetY);
                ctx.scale(animatedScale, textLayer.scaleY * animatedScale); // Apply individual scaleY and animatedScale
                ctx.globalAlpha = animatedAlpha; // Apply fade effect
                ctx.rotate(textLayer.rotation * Math.PI / 180); // Apply rotation in radians

                // Apply text shadow
                if (textLayer.shadow) {
                    ctx.shadowColor = textLayer.shadowColor; // Use specific shadow color
                    ctx.shadowBlur = textLayer.shadowBlur; // Use specific shadow blur amount
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                } else {
                    ctx.shadowColor = 'transparent'; // No shadow
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Apply text outline
                if (textLayer.outlineWidth > 0) {
                    ctx.strokeStyle = textLayer.outlineColor;
                    ctx.lineWidth = textLayer.outlineWidth;
                    ctx.lineJoin = 'round'; // For sharp corners
                }

                // Apply text blur (ctx.filter applies to everything drawn after, so apply it here for text only)
                if (textLayer.blur) {
                    const blurAmount = textLayer.shadowBlur; // Use shadowBlur for text blur effect
                    ctx.filter = `blur(${blurAmount}px)`;
                } else {
                    ctx.filter = 'none';
                }

                // Draw text at the translated origin (which is now the desired position)
                const lines = text.split('\n');
                const lineHeight = textLayer.size * 1.2; // 120% of font size for line height
                const totalTextHeight = lines.length * lineHeight;
                let currentLineY = -totalTextHeight / 2 + lineHeight / 2; // Start Y for centered block

                // Adjust initial Y based on textBaseline
                if (ctx.textBaseline === 'top') {
                    currentLineY = lineHeight / 2;
                } else if (ctx.textBaseline === 'bottom') {
                    currentLineY = -totalTextHeight + lineHeight / 2;
                }
                // For 'middle' it's already centered by currentLineY calculation above

                lines.forEach(line => {
                    // Apply letter spacing
                    if (textLayer.spacing !== 0) {
                        let currentX = 0;
                        // For center/right alignment, calculate initial X offset
                        if (ctx.textAlign === 'center') {
                            const textWidth = ctx.measureText(line).width;
                            currentX = -textWidth / 2;
                        } else if (ctx.textAlign === 'right') {
                            const textWidth = ctx.measureText(line).width;
                            currentX = -textWidth;
                        }

                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            ctx.fillText(char, currentX, currentLineY);
                            if (textLayer.outlineWidth > 0) {
                                ctx.strokeText(char, currentX, currentLineY);
                            }
                            currentX += ctx.measureText(char).width + textLayer.spacing;
                        }
                    } else {
                        ctx.fillText(line, 0, currentLineY);
                        if (textLayer.outlineWidth > 0) {
                            ctx.strokeText(line, 0, currentLineY);
                        }
                    }
                    currentLineY += lineHeight;
                });

                ctx.restore(); // Restore context to remove transforms, globalAlpha, and filters
            });

            // Reset filter for next frame to avoid accumulation issues, only if not currently recording *with* a filter
            // This line ensures the filter is reset for the *display* if recording without filter is active
            // but the filter is still applied during recording by the `currentFilterToApply` variable.
            if (!(isRecording && recordWithoutFilterCheckbox.checked)) {
                ctx.filter = 'none';
            }
        }

        // Recording functionality
        startRecordBtn.addEventListener('click', () => {
            console.log('Start Record button clicked.');
            if (!audioPlayer.src) {
                showMessage('សូមផ្ទុកឯកសារតន្ត្រីជាមុមសិន។', true);
                console.log('Error: Audio source not loaded.');
                return;
            }
            // Check if any visualizer type is selected if an image is needed
            const activeVisualizerTypes = Array.from(visualizerCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
            const needsImage = imageLayers.some(layer => layer.isLoaded && layer.pulse); // Check if any loaded image layer has pulse enabled

            if (needsImage && imageLayers.length === 0) { // If pulse is enabled but no images loaded
                showMessage('សូមផ្ទុករូបភាពជាមុនសិន ប្រសិនបើអ្នកជ្រើសរើសចលនារូបភាព។', true);
                console.log('Error: Image not loaded for image-pulse visualizer.');
                return;
            }

            // Ensure audio context is running
            initAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed.');
                }).catch(e => {
                    showMessage(`បរាជ័យក្នុងការបន្ត AudioContext: ${e.message}`, true);
                    console.error('Error resuming AudioContext:', e);
                });
            }

            // Start playing audio if paused
            if (audioPlayer.paused) {
                audioPlayer.play();
                playPauseBtn.textContent = 'ផ្អាក';
                console.log('Audio player started.');
            }

            // Create an audio destination for recording if it doesn't exist or is not connected
            if (!audioDestinationNode) {
                audioDestinationNode = audioContext.createMediaStreamDestination();
                // Connect the gainNode (which receives audio from source) to the audioDestinationNode
                gainNode.connect(audioDestinationNode); // Connect gainNode here
                console.log('AudioDestinationNode created and connected to gainNode.');
            }

            // Capture stream from canvas
            const canvasStream = visualizerCanvas.captureStream(30); // 30 frames per second
            console.log('Canvas stream captured:', canvasStream);

            // Get audio track from the audio destination
            const audioTrack = audioDestinationNode.stream.getAudioTracks()[0];
            console.log('Audio track from destination:', audioTrack);

            if (audioTrack) {
                canvasStream.addTrack(audioTrack); // Add audio track to the video stream
                console.log('Audio track added to canvas stream.');
            } else {
                showMessage('មិនអាចចាប់យកសម្លេងបានទេ។ ត្រូវប្រាកតថាឯកសារតន្ត្រីត្រូវបានផ្ទុក។', true);
                console.error('Error: Audio track not found in audio destination stream.');
                // Disconnect audioDestinationNode if it was created but no track found
                if (audioDestinationNode) {
                    gainNode.disconnect(audioDestinationNode); // Disconnect gainNode
                    audioDestinationNode = null;
                }
                isRecording = false; // Reset recording flag on error
                return;
            }

            // Set isRecording flag to true AFTER all streams are prepared
            isRecording = true;
            console.log('isRecording set to true.');

            // Start visualization (this will now apply filter conditionally based on recordWithoutFilterCheckbox)
            drawVisualizer();
            console.log('drawVisualizer started for recording.');

            // Create MediaRecorder with the combined stream
            recordedChunks = [];
            // Updated mimeType to include opus for audio (a common and good audio codec for WebM)
            mediaRecorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm; codecs=vp8,opus' });
            console.log('MediaRecorder created:', mediaRecorder);

            mediaRecorder.ondataavailable = (event) => {
                console.log('ondataavailable event fired:', event.data.size, 'bytes');
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                console.log('onstop event fired. Recorded chunks:', recordedChunks.length);
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                downloadVideoLink.href = url;
                downloadVideoLink.classList.remove('hidden');
                downloadVideoLink.textContent = 'ទាញយកវីដេអូ (WebM)';
                showMessage('ការថតត្រូវបានបញ្ចប់។ អ្នកអាចទាញយកវីដេអូបាន។', false, true);
                isRecording = false;
                startRecordBtn.disabled = false;
                stopRecordBtn.disabled = true;

                // Disconnect audio destination after recording stops
                if (audioDestinationNode) {
                    gainNode.disconnect(audioDestinationNode); // Disconnect gainNode
                    audioDestinationNode = null;
                }
                // Ensure filter is reset after recording stops, if it was forced to 'none'
                ctx.filter = canvasFilterSelect.value;
                console.log('Canvas filter reset to display value.');
            };

            mediaRecorder.start();
            console.log('MediaRecorder started.');
            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = false;
            downloadVideoLink.classList.add('hidden'); // Hide download link during recording
            showMessage('កំពុងថតវីដេអូ...', false, true);
        });

        stopRecordBtn.addEventListener('click', () => {
            console.log('Stop Record button clicked.');
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                cancelAnimationFrame(animationFrameId); // Stop visualization
                audioPlayer.pause(); // Pause audio
                playPauseBtn.textContent = 'ចាក់';
                showMessage('បញ្ឈប់ការថត។ កំពុងរៀបចំវីដេអូ...', false, true);
                console.log('MediaRecorder stopped. Audio paused. Visualization cancelled.');
            }
        });

        // Handle window resize to adjust canvas dimensions
        window.addEventListener('resize', () => {
            updateCanvasSize();
        });

        // --- Access Control Logic ---
        // Define the primary embedded code (e.g., "abcde" -> "12345")
        const _EMBEDDED_CODE_PRIMARY_ = "abcde";

        // Define the secondary embedded code (e.g., "zyxwv" -> "12345")
        // This MUST be the reverse-alphabet equivalent of _EMBEDDED_CODE_PRIMARY_
        // a <-> z, b <-> y, c <-> x, d <-> w, e <-> v
        const _EMBEDDED_CODE_SECONDARY_ = "zyxwv";

        // Function to derive a number from a character using a=1, b=2, ...
        function mapCharToNumberPrimary(char) {
            if (char >= 'a' && char <= 'z') {
                return (char.charCodeAt(0) - 'a'.charCodeAt(0) + 1).toString();
            }
            return ''; // Or handle invalid characters as needed
        }

        // Function to derive a number from a character using z=1, y=2, ...
        function mapCharToNumberSecondary(char) {
            if (char >= 'a' && char <= 'z') {
                return ('z'.charCodeAt(0) - char.charCodeAt(0) + 1).toString();
            }
            return ''; // Or handle invalid characters as needed
        }

        // Function to derive the full secret ID from an embedded code using a given mapping function
        function deriveSecretId(embeddedCode, mapFunction) {
            let derivedId = "";
            for (let i = 0; i < embeddedCode.length; i++) {
                derivedId += mapFunction(embeddedCode.charAt(i));
            }
            return derivedId;
        }

        // Derive the expected secret ID from the primary code
        const EXPECTED_SECRET_ID_FROM_PRIMARY = deriveSecretId(_EMBEDDED_CODE_PRIMARY_, mapCharToNumberPrimary);
        // Derive the expected secret ID from the secondary code
        const EXPECTED_SECRET_ID_FROM_SECONDARY = deriveSecretId(_EMBEDDED_CODE_SECONDARY_, mapCharToNumberSecondary);

        console.log("Derived Primary ID:", EXPECTED_SECRET_ID_FROM_PRIMARY);
        console.log("Derived Secondary ID:", EXPECTED_SECRET_ID_FROM_SECONDARY);


        function checkAccess() {
            // Always show the modal overlay and hide app controls until explicitly verified
            accessModalOverlay.classList.remove('controls-hidden'); // Ensure modal is visible
            appControlsDiv.classList.add('controls-hidden'); // Ensure app controls are hidden
            // No updateCanvasSize() here, as app controls are hidden and visualizer shouldn't start
        }

        verifyIdBtn.addEventListener('click', () => {
            const userInput = secretIdInput.value;

            // Perform the two-layer check
            if (userInput === EXPECTED_SECRET_ID_FROM_PRIMARY &&
                EXPECTED_SECRET_ID_FROM_PRIMARY === EXPECTED_SECRET_ID_FROM_SECONDARY &&
                userInput !== null && EXPECTED_SECRET_ID_FROM_PRIMARY !== null) {
                // Access granted for this session
                accessModalOverlay.classList.add('controls-hidden'); // Hide modal
                appControlsDiv.classList.remove('controls-hidden'); // Show main controls
                showMessage('ការចូលប្រើប្រាស់ត្រូវបានអនុញ្ញាត!', false, false);
                updateCanvasSize(); // Initialize visualizer after controls are visible
            } else {
                showMessage('លេខសម្គាល់មិនត្រឹមត្រូវទេ។ សូមព្យាយាមម្តងទៀត។', true, false);
            }
        });

        // Ensure initial canvas size is set correctly and aspect ratio applied
        window.onload = () => {
            checkAccess(); // Check access on load (this will now always show the modal initially)
            // Initial state for auto size checkboxes and sliders
            autoBackgroundSizeCheckbox.checked = true;
            backgroundSizeSlider.disabled = autoBackgroundSizeCheckbox.checked;

            autoLogoSizeCheckbox.checked = true; // Set auto logo size to checked by default
            logoSizeSlider.disabled = autoLogoSizeCheckbox.checked; // Disable logo size slider initially

            // Add one default text layer on load
            createAndAddTextLayer('បញ្ចូលអត្ថបទនៅទីនេះ');
            // Add one default image layer on load
            createAndAddImageLayer(); // Call to create the first image layer
        };

    </script>
</body>
</html>
