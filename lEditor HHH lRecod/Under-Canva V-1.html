<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>កម្មវិធីចាក់តន្ត្រី និងបង្ហាញរូបភាពតាមចង្វាក់</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for Khmer -->
    <link href="https://fonts.googleapis.com/css2?family=Battambang&family=Bayon&family=Freehand&family=Kdam+Thmor&family=Moul&family=Noto+Sans+Khmer:wght@100..900&family=Preahvihear&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center; /* Center the main wrapper */
            align-items: flex-start; /* Align wrapper to top */
            min-height: 100vh;
            margin: 0;
            overflow-y: auto; /* Allow vertical scrolling for the whole page if needed */
            padding: 2rem; /* Padding around the whole content */
        }

        .main-wrapper {
            display: flex;
            flex-direction: column; /* Controls and visualizer stacked vertically */
            gap: 2rem; /* Space between the two main sections */
            width: 100%;
            max-width: 1200px; /* Max width for the entire application layout */
            align-items: center; /* Center items when stacked */
        }

        .controls-panel {
            background-color: #2d3748;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            padding: 2.5rem;
            width: 100%;
            max-width: 400px; /* Fixed max-width for controls */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            max-height: calc(100vh - 4rem); /* Limit height for scrolling controls */
            overflow-y: auto; /* Allow internal scrolling for controls */
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        .visualizer-area {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            flex-grow: 1; /* Allow visualizer area to take remaining space */
            width: 100%; /* Important for flex-grow to work properly */
            max-width: 800px; /* Max width for the visualizer content */
            align-items: center; /* Center items within visualizer area */
        }

        .canvas-container {
            width: 100%; /* Take full width of its parent (.visualizer-area) */
            background-color: #1a202c;
            border-radius: 0.75rem;
            border: 2px solid #4a5568;
            position: relative; /* For aspect ratio padding trick */
            overflow: hidden;
        }
        /* Aspect ratio classes */
        .aspect-ratio-16-9 { padding-bottom: 56.25%; /* 9 / 16 * 100 */ }
        .aspect-ratio-9-16 { padding-bottom: 177.77%; /* 16 / 9 * 100 */ }
        .aspect-ratio-1-1 { padding-bottom: 100%; }
        /* Explicit sizes for recording qualities */
        .fixed-size {
            padding-bottom: 0 !important; /* Override aspect ratio padding */
        }


        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            width: 100%;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
        .btn {
            background-color: #4299e1; /* Blue button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            font-weight: bold;
            border: none;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .btn:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-red {
            background-color: #e53e3e; /* Red button for recording */
        }
        .btn-red:hover {
            background-color: #c53030;
        }
        .btn-green {
            background-color: #38a169; /* Green button for stopping */
        }
        .btn-green:hover {
            background-color: #2f855a;
        }
        .volume-slider, .aspect-ratio-select, .image-size-slider, .visualizer-intensity-slider, .seek-slider,
        .canvas-filter-select, .text-color-input, .text-size-input, .text-position-select, .background-size-slider, .logo-position-select,
        .background-motion-type-select, .background-motion-speed-slider, .font-url-input, .font-select, .logo-size-slider, .text-animation-type-select, .background-alignment-select,
        .time-input, .margin-input, .transform-slider, .text-shadow-blur-input {
            width: 150px;
            -webkit-appearance: none;
            height: 8px;
            background: #4a5568;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
            padding: 0.5rem; /* Add padding for select */
            border: none;
            color: #e2e8f0;
        }
        .volume-slider:hover, .aspect-ratio-select:hover, .image-size-slider:hover, .visualizer-intensity-slider:hover, .seek-slider:hover,
        .canvas-filter-select:hover, .text-color-input:hover, .text-size-input:hover, .text-position-select:hover, .background-size-slider:hover, .logo-position-select:hover,
        .background-motion-type-select:hover, .background-motion-speed-slider:hover, .font-url-input:hover, .font-select:hover, .logo-size-slider:hover, .text-animation-type-select:hover,
        .time-input:hover, .margin-input:hover, .transform-slider:hover, .text-shadow-blur-input:hover {
            opacity: 1;
        }
        .volume-slider::-webkit-slider-thumb, .image-size-slider::-webkit-slider-thumb, .visualizer-intensity-slider::-webkit-slider-thumb, .seek-slider::-webkit-slider-thumb, .background-size-slider::-webkit-slider-thumb, .background-motion-speed-slider::-webkit-slider-thumb, .logo-size-slider::-webkit-slider-thumb, .time-input::-webkit-slider-thumb, .transform-slider::-webkit-slider-thumb, .text-shadow-blur-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
        .volume-slider::-moz-range-thumb, .image-size-slider::-moz-range-thumb, .visualizer-intensity-slider::-moz-range-thumb, .seek-slider::-moz-range-thumb, .background-size-slider::-moz-range-thumb, .background-motion-speed-slider::-moz-range-thumb, .logo-size-slider::-moz-range-thumb, .time-input::-moz-range-thumb, .transform-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
        .aspect-ratio-select, .canvas-filter-select, .text-position-select, .logo-position-select, .background-motion-type-select, .font-select, .text-animation-type-select, .background-alignment-select {
            background-color: #4a5568;
            cursor: pointer;
            width: auto; /* Adjust width based on content */
            z-index: 10; /* Added z-index */
            position: relative; /* Ensure z-index works */
        }
        .text-color-input {
            height: 38px; /* Match height of select/slider */
            padding: 0.25rem;
            width: 80px; /* Adjust width for color picker */
        }
        .text-size-input {
            width: 100px;
        }
        .text-input, .font-url-input, .time-input, .margin-input {
            background-color: #4a5568;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            width: 100%;
            max-width: 250px;
        }
        .time-input {
            width: 60px; /* Smaller width for time inputs */
            text-align: center;
        }
        .margin-input {
            width: 70px; /* Smaller width for margin inputs */
            text-align: center;
        }
        .transform-slider {
            width: 100px;
        }
        .seek-slider {
            width: 100%; /* Make seek slider full width */
            margin-top: 1rem;
        }
        .time-display {
            font-size: 0.9rem;
            color: #a0aec0;
            margin-top: 0.5rem;
            width: 100%;
            text-align: center;
        }
        .image-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 0.5rem;
            object-fit: contain;
            border: 2px solid #4a5568;
            display: none; /* Hidden by default */
        }
        .message-box {
            background-color: #38a169; /* Green for success */
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            text-align: center;
            display: none; /* Hidden by default */
            width: 100%;
        }
        .message-box.error {
            background-color: #e53e3e; /* Red for error */
        }
        .message-box.info {
            background-color: #4299e1; /* Blue for info */
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .visualizer-checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        /* Initial hidden state for controls */
        .controls-hidden {
            display: none !important;
        }

        /* Modal Overlay Styles */
        #accessModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top of everything */
        }

        /* Modal Content Styles */
        #accessControl {
            background-color: #2d3748; /* Same as controls-panel background */
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            padding: 2.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 90%;
            max-width: 400px; /* Fixed width for the modal content */
            text-align: center;
        }

        /* Responsive adjustments for small screens */
        @media (max-width: 1024px) {
            .main-wrapper {
                flex-direction: column; /* Stack vertically on smaller screens */
                align-items: center; /* Center items when stacked */
                gap: 1rem;
            }
            .controls-panel, .visualizer-area {
                max-width: 95%; /* Allow both to be wider on mobile */
                max-height: none; /* Remove max height when stacked */
                overflow-y: visible; /* Allow content to push height */
            }
            body {
                padding: 1rem; /* Reduce padding for mobile */
            }
        }
        /* Styling for individual text layer controls */
        .text-layer-controls {
            background-color: #3a475a; /* Slightly different background for clarity */
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .text-layer-controls .flex {
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .text-layer-controls .btn-remove {
            background-color: #e53e3e;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-self: flex-end; /* Align remove button to the right */
        }
        /* Styling for individual image layer controls */
        .image-layer-controls {
            background-color: #3a475a; /* Same as text layer for consistency */
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .image-layer-controls .flex {
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .image-layer-controls .btn-remove {
            background-color: #e53e3e;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-self: flex-end;
        }
        .image-layer-controls .image-file-input {
            width: 100%; /* Ensure file input wrapper takes full width */
        }
        .image-layer-controls .image-preview-thumbnail {
            max-width: 100px;
            max-height: 100px;
            border-radius: 0.25rem;
            object-fit: contain;
            border: 1px solid #4a5568;
            margin-top: 0.5rem;
            display: block;
        }
        /* Styling for individual video layer controls */
        .video-layer-controls {
            background-color: #3a475a;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .video-layer-controls .flex {
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .video-layer-controls .btn-remove {
            background-color: #e53e3e;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-self: flex-end;
        }
        .video-layer-controls .video-file-input {
            width: 100%;
        }
        .video-layer-controls .video-preview-thumbnail {
            max-width: 100px;
            max-height: 100px;
            border-radius: 0.25rem;
            object-fit: contain;
            border: 1px solid #4a5568;
            margin-top: 0.5rem;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Access Control Modal Overlay -->
    <div id="accessModalOverlay">
        <div id="accessControl" class="w-full flex flex-col items-center gap-4">
            <p class="text-lg text-center">សូមបញ្ចូលលេខសម្គាល់ដើម្បីបន្ត</p>
            <input type="password" id="secretIdInput" class="text-input" placeholder="បញ្ចូលលេខសម្គាត់...">
            <button id="verifyIdBtn" class="btn">ផ្ទៀងផ្ទាត់</button>
            <div id="messageBox" class="message-box"></div> <!-- Message box inside modal -->
        </div>
    </div>

    <div class="main-wrapper">
        <div class="visualizer-area">
            <img id="imagePreview" class="image-preview" alt="រូបភាពដែលបានជ្រើសរើស">

            <div id="canvasContainer" class="canvas-container aspect-ratio-16-9">
                <canvas id="visualizerCanvas"></canvas>
            </div>

            <div class="controls mt-4">
                <div class="flex flex-col sm:flex-row justify-center items-center gap-4">
                    <div class="control-group">
                        <label for="outputQualitySelect" class="text-sm">គុណភាពវីដេអូថតចេញ:</label>
                        <select id="outputQualitySelect" class="recording-quality-select">
                            <option value="current">បច្ចុប្បន្ន (តាមទំហំបង្ហាញ)</option>
                            <option value="640x480">SD (640x480)</option>
                            <option value="1280x720">HD (1280x720)</option>
                            <option value="1920x1080">Full HD (1920x1080)</option>
                            <option value="1080x1920">Vertical HD (1080x1920)</option>
                            <option value="1080x1080">Square HD (1080x1080)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="recordingFpsInput" class="text-sm">FPS វីដេអូថត:</label>
                        <input type="number" id="recordingFpsInput" min="1" max="60" value="30" class="time-input">
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                    <button id="fullscreenBtn" class="btn">ពេញអេក្រង់</button>
                    <button id="startRecordBtn" class="btn btn-red">ចាប់ផ្តើមថត</button>
                    <button id="stopRecordBtn" class="btn btn-green" disabled>បញ្ឈប់ការថត</button>
                    <a id="downloadVideoLink" class="btn hidden" download="visualizer_video.webm">ទាញយកវីដេអូ</a>
                </div>
                <div class="checkbox-group mt-2">
                    <input type="checkbox" id="recordWithoutFilterCheckbox">
                    <label for="recordWithoutFilterCheckbox" class="text-sm">ថតដោយគ្មានតម្រងរូបភាព</label>
                </div>
            </div>
        </div>
        <!-- Controls Panel moved here -->
        <div class="controls-panel">
            <h1 class="text-3xl font-bold text-center mb-4">កម្មវិធីចាក់តន្ត្រី និងបង្ហាញរូបភាពតាមចង្វាក់</h1>

            <!-- All other controls, initially hidden -->
            <div id="appControls" class="w-full flex flex-col items-center gap-1.5 controls-hidden">
                <div class="controls">
                    <div class="file-input-wrapper">
                        <button class="btn">ជ្រើសរើសឯកសារតន្ត្រី</button>
                        <input type="file" id="audioFile" accept="audio/*">
                    </div>
                    <div class="control-group">
                        <label for="aspectRatioSelect" class="text-sm">ទំហំបង្ហាញ:</label>
                        <select id="aspectRatioSelect" class="aspect-ratio-select">
                            <option value="16-9">YouTube (16:9)</option>
                            <option value="9-16">TikTok/Reels (9:16)</option>
                            <option value="1-1">Instagram (1:1)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="text-sm">ប្រភេទចលនា:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមប្រភេទចលនា</summary>
                            <div id="visualizerTypeControls" class="visualizer-checkbox-group mt-2">
                                <label><input type="checkbox" class="visualizer-checkbox" value="bars"> របារប្រេកង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="circle-pulse"> រង្វង់លោត</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="wave"> រលក</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="radial-bars"> របាររង្វង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="particle-swarm"> ហ្វូងភាគល្អិត</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="line-spectrum"> បន្ទាត់វិសាលគម</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="frequency-circle"> រង្វង់ប្រេកង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="falling-particles"> ភាគល្អិតធ្លាក់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="rising-particles"> ភាគល្អិតឡើងលើ</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="leftward-particles"> ភាគល្អិតទៅឆ្វេង</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="rightward-particles"> ភាគល្អិតទៅស្តាំ</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="colorful-particles"> ភាគល្អិតចម្រុះពណ៌</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="connecting-lines"> បន្ទាត់តភ្ជាប់</label>
                            </div>
                        </details>
                    </div>
                    <div class="control-group">
                        <label for="visualizerIntensitySlider" class="text-sm">កម្រិតចលនា:</label>
                        <input type="range" id="visualizerIntensitySlider" min="0.0" max="2.0" step="0.1" value="1.0" class="visualizer-intensity-slider">
                    </div>
                </div>

                <div class="w-full flex flex-col items-center">
                    <!-- Audio player controls moved here -->
                    <div class="flex flex-wrap justify-center gap-2 mb-2">
                        <button id="playPauseBtn" class="btn">ចាក់/ផ្អាក</button>
                        <div class="control-group">
                            <label for="volumeSlider" class="text-sm">កម្រិតសំឡេង:</label>
                            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.7" class="volume-slider">
                        </div>
                    </div>
                    <input type="range" id="seekSlider" min="0" max="0" value="0" step="0.01" class="seek-slider">
                    <div id="timeDisplay" class="time-display">0:00 / 0:00</div>
                </div>

                <div class="controls mt-4">
                    <div class="control-group">
                        <label for="backgroundFile" class="text-sm">ផ្ទៃខាងក្រោយ:</label>
                        <input type="file" id="backgroundFile" accept="image/*">
                        <div class="checkbox-group">
                            <input type="checkbox" id="autoBackgroundSizeCheckbox" checked>
                            <label for="autoBackgroundSizeCheckbox" class="text-sm">ស្វ័យប្រវត្តិ</label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="backgroundSizeSlider" class="text-sm">ទំហំផ្ទៃខាងក្រោយ:</label>
                        <input type="range" id="backgroundSizeSlider" min="0.1" max="2.0" step="0.05" value="1.0" class="background-size-slider">
                    </div>
                    <div class="control-group">
                        <label for="backgroundAlignmentSelect" class="text-sm">ទីតាំងផ្ទៃខាងក្រោយ:</label>
                        <select id="backgroundAlignmentSelect" class="background-alignment-select">
                            <option value="center">កណ្តាល</option>
                            <option value="top-left">លើ-ឆ្វេង</option>
                            <option value="top-center">លើ-កណ្តាល</option>
                            <option value="top-right">លើ-ស្តាំ</option>
                            <option value="center-left">កណ្តាល-ឆ្វេង</option>
                            <option value="center-right">កណ្តាល-ស្តាំ</option>
                            <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                            <option value="bottom-center">ក្រោម-កណ្តាល</option>
                            <option value="bottom-right">ក្រោម-ស្តាំ</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="backgroundMotionTypeSelect" class="text-sm">ចលនាផ្ទៃខាងក្រោយ:</label>
                        <select id="backgroundMotionTypeSelect" class="background-motion-type-select">
                            <option value="none">គ្មាន</option>
                            <option value="zoom">ពង្រីក/បង្រួម</option>
                            <option value="pan-horizontal">រំកិលផ្ដេក</option>
                            <option value="pan-vertical">រំកិលបញ្ឈរ</option>
                            <option value="rotate">បង្វិល</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="backgroundMotionSpeedSlider" class="text-sm">ល្បឿនចលនាផ្ទៃខាងក្រោយ:</label>
                        <input type="range" id="backgroundMotionSpeedSlider" min="0.0" max="1.0" step="0.05" value="0.5" class="background-motion-speed-slider">
                    </div>
                    <div class="control-group">
                        <label for="canvasFilterSelect" class="text-sm">តម្រងរូបភាព:</label>
                        <select id="canvasFilterSelect" class="canvas-filter-select">
                            <option value="none">គ្មាន</option>
                            <option value="grayscale(100%)">សខ្មៅ</option>
                            <option value="sepia(100%)">សេពៀ</option>
                            <option value="invert(100%)">បញ្ច្រាសពណ៌</option>
                            <option value="blur(5px)">ព្រិល</option>
                        </select>
                    </div>
                    
                    <!-- Image Layers Container -->
                    <div class="control-group w-full">
                        <label class="text-sm">គ្រប់គ្រងរូបភាព:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមគ្រប់គ្រងរូបភាព</summary>
                            <div id="imageLayersContainer" class="w-full mt-2">
                                <!-- Image input templates will be added here by JS -->
                            </div>
                            <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                                <button id="addImageLayerBtn" class="btn">បន្ថែមរូបភាពថ្មី</button>
                            </div>
                        </details>
                    </div>

                    <!-- Video Layers Container -->
                    <div class="control-group w-full">
                        <label class="text-sm">គ្រប់គ្រងវីដេអូ:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមគ្រប់គ្រងវីដេអូ</summary>
                            <div id="videoLayersContainer" class="w-full mt-2">
                                <!-- Video input templates will be added here by JS -->
                            </div>
                            <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                                <button id="addVideoLayerBtn" class="btn">បន្ថែមវីដេអូថ្មី</button>
                            </div>
                        </details>
                    </div>

                    <!-- Text Layers Container -->
                    <div class="control-group w-full">
                        <label class="text-sm">គ្រប់គ្រងអត្ថបទ:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមគ្រប់គ្រងអត្ថបទ</summary>
                            <div id="textLayersContainer" class="w-full mt-2">
                                <!-- Text input templates will be added here by JS -->
                            </div>
                            <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                                <button id="addTextLayerBtn" class="btn">បន្ថែមអត្ថបទថ្មី</button>
                                <button id="addSubtitleLayerBtn" class="btn">បន្ថែម Subtitle ថ្មី</button>
                            </div>
                        </details>
                    </div>

                    <div class="control-group">
                        <label for="logoFile" class="text-sm">Logo:</label>
                        <input type="file" id="logoFile" accept="image/*">
                    </div>
                    <div class="control-group">
                        <label for="logoPositionSelect" class="text-sm">ទីតាំង Logo:</label>
                        <select id="logoPositionSelect" class="logo-position-select">
                            <option value="top-left">លើ-ឆ្វេង</option>
                            <option value="top-right">លើ-ស្តាំ</option>
                            <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                            <option value="bottom-right">ក្រោម-ស្តាំ</option>
                            <option value="center">កណ្តាល</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="logoSizeSlider" class="text-sm">ទំហំ Logo:</label>
                        <input type="range" id="logoSizeSlider" min="10" max="200" step="5" value="50" class="logo-size-slider">
                        <div class="checkbox-group">
                            <input type="checkbox" id="autoLogoSizeCheckbox" checked>
                            <label for="autoLogoSizeCheckbox" class="text-sm">ស្វ័យប្រវត្តិ</label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="fontUrlInput" class="text-sm">ផ្ទុក Font ពី URL (Google Fonts):</label>
                        <input type="text" id="fontUrlInput" class="font-url-input" placeholder="ឧ. https://fonts.googleapis.com/css2?family=Noto+Sans+Khmer&display=swap">
                        <button id="loadFontUrlBtn" class="btn">ផ្ទុក Font URL</button>
                    </div>
                    <div class="control-group">
                        <label for="fontFileInput" class="text-sm">ផ្ទុក Font ពីឧបករណ៍ (.ttf, .otf, .woff):</label>
                        <input type="file" id="fontFileInput" accept=".ttf,.otf,.woff,.woff2">
                        <input type="text" id="customFontNameInput" class="text-input" placeholder="ឈ្មោះ Font (ឧ. MyCustomFont)">
                        <button id="loadFontFileBtn" class="btn">ផ្ទុក Font ឯកសារ</button>
                    </div>
                    <div class="control-group">
                        <label class="text-sm">ជ្រើសរើស Font:</label>
                        <select id="fontSelect" class="font-select">
                            <!-- Options will be populated by JS -->
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer" controls class="hidden"></audio>

    <!-- Hidden Text Layer Template -->
    <template id="textLayerTemplate">
        <div class="text-layer-controls">
            <button class="btn btn-red btn-remove">លុប</button>
            <button class="btn btn-copy">ចម្លង</button> <!-- New Copy button -->
            <textarea class="text-input" rows="2" placeholder="បញ្ចូលអត្ថបទ..."></textarea>
            <div class="flex">
                <input type="color" value="#ffffff" class="text-color-input">
                <input type="number" min="10" max="100" value="30" class="text-size-input">
                <select class="text-position-select">
                    <option value="bottom-center">ក្រោម-កណ្តាល</option>
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វ្វេង</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                    <option value="center">កណ្តាល</option>
                </select>
            </div>
            <div class="checkbox-group">
                <label><input type="checkbox" class="text-bold-checkbox"> អក្សរដិត</label>
                <label><input type="checkbox" class="text-shadow-checkbox"> ស្រមោលអក្សរ</label>
                <label><input type="checkbox" class="text-blur-checkbox"> អក្សរព្រាល</label>
            </div>
            <div class="control-group">
                <label class="text-sm">ចលនាអត្ថបទ:</label>
                <select class="text-animation-type-select">
                    <option value="none">គ្មាន</option>
                    <option value="pulse">លោតតាមភ្លេង</option>
                    <option value="fade">ព្រាលតាមភ្លេង</option>
                    <option value="slide-horizontal">រំកិលផ្ដេកតាមភ្លេង</option>
                    <option value="slide-vertical">រំកិលបញ្ឈរតាមភ្លេង</option>
                </select>
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលចាប់ផ្តើម:</label>
                <input type="number" min="0" value="0" class="time-input text-start-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input text-start-sec">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលបញ្ចប់:</label>
                <input type="number" min="0" value="0" class="time-input text-end-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input text-end-sec">
            </div>
            <div class="control-group">
                <label class="text-sm">ពណ៌គ្រោង:</label>
                <input type="color" value="#000000" class="text-outline-color-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ទទឹងគ្រោង:</label>
                <input type="number" min="0" max="10" step="0.5" value="0" class="transform-slider text-outline-width-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ពណ៌ស្រមោល:</label>
                <input type="color" value="#000000" class="text-shadow-color-input">
            </div>
            <div class="control-group">
                <label class="text-sm">កម្រិតព្រាលស្រមោល:</label>
                <input type="number" min="0" max="20" step="1" value="2" class="transform-slider text-shadow-blur-input">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">រឹមឆ្វេង:</label>
                <input type="number" value="0" class="margin-input text-margin-left-input">
                <label class="text-sm">រឹមស្តាំ:</label>
                <input type="number" value="0" class="margin-input text-margin-right-input">
            </div>
            <div class="control-group">
                <label class="text-sm">រឹមបញ្ឈរ:</label>
                <input type="number" value="0" class="margin-input text-margin-vertical-input">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">មាត្រដ្ឋាន X:</label>
                <input type="number" min="0.1" max="5.0" step="0.1" value="1.0" class="transform-slider text-scale-x-input">
                <label class="text-sm">មាត្រដ្ឋាន Y:</label>
                <input type="number" min="0.1" max="5.0" step="0.1" value="1.0" class="transform-slider text-scale-y-input">
            </div>
            <div class="control-group">
                <label class="text-sm">បង្វិល (ដឺក្រេ):</label>
                <input type="number" min="-180" max="180" value="0" class="transform-slider text-rotation-input">
            </div>
            <div class="control-group">
                <label class="text-sm">គម្លាតអក្សរ:</label>
                <input type="number" min="-10" max="20" step="0.5" value="0" class="transform-slider text-spacing-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ជ្រើសរើស Font:</label>
                <select class="font-select">
                    <!-- Options will be populated by JS -->
                </select>
            </div>
        </div>
    </template>

    <!-- Hidden Image Layer Template -->
    <template id="imageLayerTemplate">
        <div class="image-layer-controls">
            <button class="btn btn-red btn-remove">លុប</button>
            <button class="btn btn-copy-image">ចម្លង</button> <!-- New Copy button for images -->
            <div class="file-input-wrapper">
                <button class="btn">ជ្រើសរើសរូបភាព</button>
                <input type="file" accept="image/*" class="image-file-input">
            </div>
            <img class="image-preview-thumbnail" alt="រូបភាពតូច">
            <div class="control-group">
                <label class="text-sm">ទំហំរូបភាព:</label>
                <input type="range" min="0.1" max="2.0" step="0.05" value="1.0" class="image-size-slider">
                <div class="checkbox-group">
                    <input type="checkbox" checked class="auto-image-size-checkbox">
                    <label class="text-sm">ស្វ័យប្រវត្តិ</label>
                </div>
            </div>
            <div class="control-group">
                <label class="text-sm">ទីតាំងរូបភាព:</label>
                <select class="image-position-select">
                    <option value="center">កណ្តាល</option>
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-center">លើ-កណ្តាល</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="center-left">កណ្តាល-ឆ្វេង</option>
                    <option value="center-right">កណ្តាល-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                    <option value="bottom-center">ក្រោម-កណ្តាល</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                </select>
            </div>
            <div class="checkbox-group">
                <label><input type="checkbox" class="image-pulse-checkbox"> ចលនាលោតរូបភាព</label>
            </div>
            <div class="control-group">
                <label class="text-sm">អនុវត្តចលនា Visualizer លើរូបភាពនេះ:</label>
                <input type="checkbox" class="apply-visualizer-to-image-checkbox">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលចាប់ផ្តើម:</label>
                <input type="number" min="0" value="0" class="time-input image-start-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input image-start-sec">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលបញ្ចប់:</label>
                <input type="number" min="0" value="0" class="time-input image-end-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input image-end-sec">
            </div>
        </div>
    </template>

    <!-- Hidden Video Layer Template -->
    <template id="videoLayerTemplate">
        <div class="video-layer-controls">
            <button class="btn btn-red btn-remove">លុប</button>
            <button class="btn btn-copy-video">ចម្លង</button> <!-- Copy button for videos -->
            <div class="file-input-wrapper">
                <button class="btn">ជ្រើសរើសវីដេអូ</button>
                <input type="file" accept="video/*" class="video-file-input">
            </div>
            <video class="video-preview-thumbnail" muted autoplay loop></video> <!-- Autoplay/loop for preview -->
            <div class="control-group">
                <label class="text-sm">ទំហំវីដេអូ:</label>
                <input type="range" min="0.1" max="2.0" step="0.05" value="1.0" class="video-size-slider">
                <div class="checkbox-group">
                    <input type="checkbox" checked class="auto-video-size-checkbox">
                    <label class="text-sm">ស្វ័យប្រវត្តិ</label>
                </div>
            </div>
            <div class="control-group">
                <label class="text-sm">ទីតាំងវីដេអូ:</label>
                <select class="video-position-select">
                    <option value="center">កណ្តាល</option>
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-center">លើ-កណ្តាល</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="center-left">កណ្តាល-ឆ្វេង</option>
                    <option value="center-right">កណ្តាល-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                    <option value="bottom-center">ក្រោម-កណ្តាល</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                </select>
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលចាប់ផ្តើម:</label>
                <input type="number" min="0" value="0" class="time-input video-start-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input video-start-sec">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលបញ្ចប់:</label>
                <input type="number" min="0" value="0" class="time-input video-end-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input video-end-sec">
            </div>
        </div>
    </template>

    <script>
        // --- Security Measures (Client-Side Only) ---
        // Disable right-click context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            // No redirect here, just prevent default
        });

        // Disable F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C, Ctrl+U
        document.addEventListener('keydown', function(e) {
            // F12 key
            if (e.key === 'F12') {
                e.preventDefault();
            }

            // Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C (Developer Tools shortcuts)
            if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) {
                e.preventDefault();
            }

            // Ctrl+U (View Page Source)
            if (e.ctrlKey && e.key === 'u') {
                e.preventDefault();
            }
        });

        // This attempts to handle view-source: but is not foolproof as browser behavior varies.
        // It's client-side JS, so if someone types view-source: in the URL bar, the JS might not even run.
        // The primary defense is the keydown and contextmenu listeners.
        // Removed redirect for view-source as it causes issues with local files.

        // --- End Security Measures ---

        // Global variables
        let audioContext;
        let analyser;
        let source;
        let gainNode;
        let bufferLength;
        let dataArray;
        let animationFrameId;
        let audioDestinationNode;

        let bgImg = new Image();
        let isBgImageLoaded = false;
        let logoImg = new Image();
        let isLogoLoaded = false;

        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        let backgroundPanOffset = { x: 0, y: 0 };
        let backgroundRotation = 0;
        let lastFrameTime = 0;

        let activeVisualizerOrder = [];

        let textLayers = [];
        let imageLayers = [];
        let videoLayers = [];

        let textLayerCounter = 0;
        let imageLayerCounter = 0;
        let videoLayerCounter = 0;

        let isSettingAspectRatioByQuality = false;

        // Canvas for offscreen rendering during recording
        const recordingCanvas = document.createElement('canvas');
        const recordingCtx = recordingCanvas.getContext('2d');


        // Predefined list of fonts for the dropdowns
        const defaultFontOptions = [
            { value: 'Inter, sans-serif', text: 'Inter (លំនាំដើម)' },
            { value: 'Arial, sans-serif', text: 'Arial' },
            { value: 'Verdana, sans-serif', text: 'Verdana' },
            { value: 'Times New Roman, serif', text: 'Times New Roman' },
            { value: 'Noto Sans Khmer', text: 'Noto Sans Khmer' },
            { value: 'Battambang', text: 'Battambang' },
            { value: 'Bayon', text: 'Bayon' },
            { value: 'Freehand', text: 'Freehand' },
            { value: 'Kdam Thmor', text: 'Kdam Thmor' },
            { value: 'Moul', text: 'Moul' },
            { value: 'Preahvihear', text: 'Preahvihear' }
        ];

        // --- Helper Functions ---
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        function showMessage(message, isError = false, isInfo = false) {
            const targetMessageBox = accessModalOverlay.classList.contains('controls-hidden') ? messageBox : accessModalOverlay.querySelector('#messageBox');
            
            targetMessageBox.textContent = message;
            targetMessageBox.className = 'message-box';
            if (isError) {
                targetMessageBox.classList.add('error');
            } else if (isInfo) {
                targetMessageBox.classList.add('info');
            } else {
                targetMessageBox.classList.add('success');
            }
            targetMessageBox.style.display = 'block';
            setTimeout(() => {
                targetMessageBox.style.display = 'none';
            }, 3000);
        }

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                source = audioContext.createMediaElementSource(audioPlayer);
                gainNode = audioContext.createGain();
                source.connect(gainNode);
                gainNode.connect(analyser);
                analyser.connect(audioContext.destination);
            }
        }

        async function loadFontFromUrl(url) {
            if (!url) {
                showMessage('សូមបញ្ចូល URL Font ឱ្យបានត្រឹមត្រូវ។', true);
                return;
            }
            try {
                const existingLink = document.querySelector(`link[href="${url}"]`);
                if (existingLink) {
                    showMessage('Font នេះត្រូវបានផ្ទុកពីមុនមកហើយ។', false, true);
                    return;
                }

                const link = document.createElement('link');
                link.href = url;
                link.rel = 'stylesheet';
                document.head.appendChild(link);

                const match = url.match(/family=([^&:]+)/);
                let fontName = 'Unknown Font';
                if (match && match[1]) {
                    fontName = decodeURIComponent(match[1].replace(/\+/g, ' '));
                }

                await document.fonts.load(`1em "${fontName}"`);
                addFontToAllSelects(fontName, fontName);
                showMessage(`Font "${fontName}" ត្រូវបានផ្ទុកដោយជោគជ័យពី URL។`);
                drawVisualizer();
            } catch (error) {
                showMessage(`បរាជ័យក្នុងការផ្ទុក Font ពី URL: ${error.message}`, true);
                console.error('Font loading error:', error);
            }
        }

        async function loadFontFromFile(file, fontName) {
            if (!file) {
                showMessage('សូមជ្រើសរើសឯកសារ Font។', true);
                return;
            }
            if (!fontName || fontName.trim() === '') {
                showMessage('សូមបញ្ចូលឈ្មោះសម្រាប់ Font ផ្ទាល់ខ្លួន។', true);
                return;
            }
            try {
                const font = new FontFace(fontName, `url(${URL.createObjectURL(file)})`);
                await font.load();
                document.fonts.add(font);
                addFontToAllSelects(fontName, fontName);
                showMessage(`Font "${fontName}" ត្រូវបានផ្ទុកដោយជោគជោគជ័យពីឯកសារ។`);
                drawVisualizer();
            } catch (error) {
                showMessage(`បរាជ័យក្នុងការផ្ទុក Font ពីឯកសារ: ${error.message}`, true);
                console.error('Font loading error:', error);
            }
        }

        function addFontToAllSelects(value, text) {
            const fontSelects = document.querySelectorAll('.font-select');
            fontSelects.forEach(select => {
                if (!Array.from(select.options).some(option => option.value === value)) {
                    const newOption = new Option(text, value);
                    select.add(newOption);
                }
            });
        }

        function initializeParticleArray(arr, canvasWidth, canvasHeight, baseColor) {
            if (arr.length === 0) {
                for (let i = 0; i < maxParticlesPerVisualizer; i++) {
                    const particleColor = baseColor || `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`;
                    arr.push(new Particle(Math.random() * canvasWidth, Math.random() * canvasHeight, Math.random() * 3 + 1, particleColor));
                }
            }
        }

        // --- Drawing Functions ---
        function drawBars(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMusicScaleFactor, offsetX = 0, offsetY = 0) {
            const barWidth = (canvasWidth / bufferLength) * 2.5;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = dataArray[i] * activeMusicScaleFactor * 1.5;
                ctx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                ctx.fillRect(offsetX + x, offsetY + canvasHeight - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function drawCirclePulse(ctx, canvasWidth, canvasHeight, activeMusicScaleFactor, average, visualizerIntensity, offsetX = 0, offsetY = 0) {
            ctx.save();
            ctx.beginPath();
            const centerX = offsetX + canvasWidth / 2;
            const centerY = offsetY + canvasHeight / 2;
            const baseRadius = Math.min(canvasWidth, canvasHeight) * 0.2;
            const pulseRadius = baseRadius * activeMusicScaleFactor;
            ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(66, 153, 225, ${0.5 + (average / 255) * 0.5 * visualizerIntensity})`;
            ctx.fill();
            ctx.closePath();
            ctx.restore();
        }

        function drawWave(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMidScaleFactor, offsetX = 0, offsetY = 0) {
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = '#4299e1';
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            const sliceWidth = canvasWidth * 1.0 / bufferLength;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = offsetY + canvasHeight / 2 + v * (canvasHeight / 4) * activeMidScaleFactor;

                if (i === 0) {
                    ctx.moveTo(offsetX + x, y);
                } else {
                    ctx.lineTo(offsetX + x, y);
                }
                x += sliceWidth;
            }
            ctx.lineTo(offsetX + canvasWidth, offsetY + canvasHeight / 2);
            ctx.stroke();
            ctx.restore();
        }

        function drawRadialBars(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeBassScaleFactor, offsetX = 0, offsetY = 0) {
            ctx.save();
            ctx.translate(offsetX + canvasWidth / 2, offsetY + canvasHeight / 2);
            const radius = Math.min(canvasWidth, canvasHeight) * 0.2;
            const barCount = bufferLength / 2;
            const barAngle = (Math.PI * 2) / barCount;
            for (let i = 0; i < barCount; i++) {
                const barHeight = dataArray[i] * activeBassScaleFactor * 0.8;
                ctx.rotate(barAngle);
                ctx.fillStyle = `hsl(${i * (360 / barCount)}, 100%, 50%)`;
                ctx.fillRect(radius, 0, 5, -barHeight);
            }
            ctx.restore();
        }

        function drawParticleSwarm(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, activeMusicScaleFactor, offsetX = 0, offsetY = 0) {
            const particleCount = 50;
            const maxParticleSize = 5;
            const maxSpeed = 3;
            ctx.save();
            ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + (average / 255) * 0.4 * visualizerIntensity})`;
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const speed = maxSpeed * activeMusicScaleFactor;
                const size = maxParticleSize * activeMusicScaleFactor;
                const x = offsetX + canvasWidth / 2 + Math.cos(angle) * (average * speed);
                const y = offsetY + canvasHeight / 2 + Math.sin(angle) * (average * speed);
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawLineSpectrum(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeTrebleScaleFactor, trebleAverage, offsetX = 0, offsetY = 0) {
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = `hsl(${trebleAverage * 1.5}, 100%, 70%)`;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            const sliceWidth = canvasWidth * 1.0 / bufferLength;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 255.0;
                const y = offsetY + canvasHeight - (v * canvasHeight * 0.5 * activeTrebleScaleFactor);
                if (i === 0) {
                    ctx.moveTo(offsetX + x, y);
                } else {
                    ctx.lineTo(offsetX + x, y);
                }
                x += sliceWidth;
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawFrequencyCircle(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMusicScaleFactor, offsetX = 0, offsetY = 0) {
            ctx.save();
            const centerX = offsetX + canvasWidth / 2;
            const centerY = offsetY + canvasHeight / 2;
            const maxRadius = Math.min(canvasWidth, canvasHeight) * 0.4;
            for (let i = 0; i < bufferLength; i++) {
                const value = dataArray[i];
                const radius = maxRadius * (value / 255) * activeMusicScaleFactor;
                const hue = i * 360 / bufferLength;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            ctx.restore();
        }

        // --- New Particle Drawing Functions (using the generic Particle class) ---
        class Particle {
            constructor(x, y, size, color, speedX = 0, speedY = 0) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.speedX = speedX;
                this.speedY = speedY;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        const maxParticlesPerVisualizer = 100;
        let fallingParticles = [];
        let risingParticles = [];
        let leftwardParticles = [];
        let rightwardParticles = [];
        let colorfulParticles = [];

        function initializeParticleArray(arr, canvasWidth, canvasHeight, baseColor) {
            if (arr.length === 0) {
                for (let i = 0; i < maxParticlesPerVisualizer; i++) {
                    const particleColor = baseColor || `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`;
                    arr.push(new Particle(Math.random() * canvasWidth, Math.random() * canvasHeight, Math.random() * 3 + 1, particleColor));
                }
            }
        }

        function drawFallingParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray, offsetX = 0, offsetY = 0) {
            initializeParticleArray(fallingParticles, canvasWidth, canvasHeight);
            const baseSpeed = 1;
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < fallingParticles.length; i++) {
                const particle = fallingParticles[i];
                particle.speedY = baseSpeed + (dataArray[Math.floor(i / fallingParticles.length * bufferLength)] / 255) * musicInfluence;
                particle.speedX = 0;

                particle.update();
                if (particle.y > offsetY + canvasHeight) {
                    particle.y = offsetY;
                    particle.x = offsetX + Math.random() * canvasWidth;
                }
                particle.draw(ctx);
            }
        }

        function drawRisingParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray, offsetX = 0, offsetY = 0) {
            initializeParticleArray(risingParticles, canvasWidth, canvasHeight);
            const baseSpeed = 1;
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < risingParticles.length; i++) {
                const particle = risingParticles[i];
                particle.speedY = -(baseSpeed + (dataArray[Math.floor(i / risingParticles.length * bufferLength)] / 255) * musicInfluence);
                particle.speedX = 0;

                particle.update();
                if (particle.y < offsetY) {
                    particle.y = offsetY + canvasHeight;
                    particle.x = offsetX + Math.random() * canvasWidth;
                }
                particle.draw(ctx);
            }
        }

        function drawLeftwardParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray, offsetX = 0, offsetY = 0) {
            initializeParticleArray(leftwardParticles, canvasWidth, canvasHeight);
            const baseSpeed = 1;
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < leftwardParticles.length; i++) {
                const particle = leftwardParticles[i];
                particle.speedX = -(baseSpeed + (dataArray[Math.floor(i / leftwardParticles.length * bufferLength)] / 255) * musicInfluence);
                particle.speedY = 0;

                particle.update();
                if (particle.x < offsetX) {
                    particle.x = offsetX + canvasWidth;
                    particle.y = offsetY + Math.random() * canvasHeight;
                }
                particle.draw(ctx);
            }
        }

        function drawRightwardParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray, offsetX = 0, offsetY = 0) {
            initializeParticleArray(rightwardParticles, canvasWidth, canvasHeight);
            const baseSpeed = 1;
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < rightwardParticles.length; i++) {
                const particle = rightwardParticles[i];
                particle.speedX = baseSpeed + (dataArray[Math.floor(i / rightwardParticles.length * bufferLength)] / 255) * musicInfluence;
                particle.speedY = 0;

                particle.update();
                if (particle.x > offsetX + canvasWidth) {
                    particle.x = offsetX;
                    particle.y = offsetY + Math.random() * canvasHeight;
                }
                particle.draw(ctx);
            }
        }

        function drawColorfulParticles(ctx, canvasWidth, canvasHeight, average, visualizerIntensity, bufferLength, dataArray, offsetX = 0, offsetY = 0) {
            initializeParticleArray(colorfulParticles, canvasWidth, canvasHeight);
            const baseSpeed = 1;
            const musicInfluence = (average / 255) * 10 * visualizerIntensity;

            for (let i = 0; i < colorfulParticles.length; i++) {
                const particle = colorfulParticles[i];
                particle.speedY = baseSpeed + (dataArray[Math.floor(i / colorfulParticles.length * bufferLength)] / 255) * musicInfluence;
                particle.speedX = 0;

                const hue = (dataArray[Math.floor(i / colorfulParticles.length * bufferLength)] / 255) * 360;
                particle.color = `hsl(${hue}, 100%, 70%)`;

                particle.update();
                if (particle.y > offsetY + canvasHeight) {
                    particle.y = offsetY;
                    particle.x = offsetX + Math.random() * canvasWidth;
                }
                particle.draw(ctx);
            }
        }

        function drawConnectingLines(ctx, canvasWidth, canvasHeight, bufferLength, dataArray, activeMusicScaleFactor, visualizerIntensity, average, offsetX = 0, offsetY = 0) {
            ctx.save();
            ctx.strokeStyle = `rgba(66, 153, 225, ${0.5 + (average / 255) * 0.5 * visualizerIntensity})`;
            ctx.lineWidth = 1;
            const sliceWidth = canvasWidth * 1.0 / bufferLength;
            const points = [];
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 255.0;
                const x = offsetX + i * sliceWidth;
                const y = offsetY + canvasHeight / 2 + (v - 0.5) * canvasHeight * 0.4 * activeMusicScaleFactor;
                points.push({ x, y });
            }
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    const dist = Math.sqrt(Math.pow(points[i].x - points[j].x, 2) + Math.pow(points[i].y - points[j].y, 2));
                    if (dist < 150) {
                        ctx.beginPath();
                        ctx.moveTo(points[i].x, points[i].y);
                        ctx.lineTo(points[j].x, points[j].y);
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();
        }

        function drawImageLayer(ctx, canvasWidth, canvasHeight, activeMusicScaleFactor, imageLayer, average, visualizerIntensity, bufferLength, dataArray) {
            if (!imageLayer.isLoaded) return;

            const layerStartTime = (imageLayer.startTimeMinutes * 60) + imageLayer.startTimeSeconds;
            const layerEndTime = (imageLayer.endTimeMinutes * 60) + imageLayer.endTimeSeconds;
            const currentAudioTime = audioPlayer.currentTime;
            const shouldDisplay = (currentAudioTime >= layerStartTime) && (layerEndTime === 0 || currentAudioTime < layerEndTime);

            if (!shouldDisplay) return;

            ctx.save();

            let initialDrawWidth, initialDrawHeight;
            if (imageLayer.autoSize) {
                const imgAspectRatio = imageLayer.img.width / imageLayer.img.height;
                const canvasAspectRatio = canvasWidth / canvasHeight;
                if (imgAspectRatio > canvasAspectRatio) {
                    initialDrawWidth = canvasWidth;
                    initialDrawHeight = canvasWidth / imgAspectRatio;
                } else {
                    initialDrawHeight = canvasHeight;
                    initialDrawWidth = canvasHeight * imgAspectRatio;
                }
            } else {
                initialDrawWidth = imageLayer.img.width * imageLayer.size;
                initialDrawHeight = imageLayer.img.height * imageLayer.size;
                const imgAspectRatio = imageLayer.img.width / imageLayer.img.height;
                if (initialDrawWidth > canvasWidth || initialDrawHeight > canvasHeight) {
                    if (imgAspectRatio > canvasWidth / canvasHeight) {
                        initialDrawWidth = canvasWidth;
                        initialDrawHeight = canvasWidth / imgAspectRatio;
                    } else {
                        initialDrawHeight = canvasHeight;
                        initialDrawWidth = canvasHeight * imgAspectRatio;
                    }
                }
            }

            let finalDrawWidth = initialDrawWidth;
            let finalDrawHeight = initialDrawHeight;

            if (imageLayer.pulse) {
                const minScaleLimit = 0.5;
                const maxScaleLimit = 2.0;
                finalDrawWidth = initialDrawWidth * activeMusicScaleFactor;
                finalDrawHeight = initialDrawHeight * activeMusicScaleFactor;
                finalDrawWidth = Math.max(initialDrawWidth * minScaleLimit, Math.min(initialDrawWidth * maxScaleLimit, finalDrawWidth));
                finalDrawHeight = Math.max(initialDrawHeight * minScaleLimit, Math.min(initialDrawHeight * maxScaleLimit, finalDrawHeight));
            }

            let drawX, drawY;
            switch(imageLayer.position) {
                case 'bottom-center': drawX = (canvasWidth - finalDrawWidth) / 2; drawY = canvasHeight - finalDrawHeight; break;
                case 'top-center': drawX = (canvasWidth - finalDrawWidth) / 2; drawY = 0; break;
                case 'center-left': drawX = 0; drawY = (canvasHeight - finalDrawHeight) / 2; break;
                case 'center-right': drawX = canvasWidth - finalDrawWidth; drawY = (canvasHeight - finalDrawHeight) / 2; break;
                case 'top-left': drawX = 0; drawY = 0; break;
                case 'top-right': drawX = canvasWidth - finalDrawWidth; drawY = 0; break;
                case 'bottom-left': drawX = 0; drawY = canvasHeight - finalDrawHeight; break;
                case 'bottom-right': drawX = canvasWidth - finalDrawWidth; drawY = canvasHeight - finalDrawHeight; break;
                case 'center': default: drawX = (canvasWidth - finalDrawWidth) / 2; drawY = (canvasHeight - finalDrawHeight) / 2; break;
            }

            ctx.drawImage(imageLayer.img, drawX, drawY, finalDrawWidth, finalDrawHeight);

            if (imageLayer.applyVisualizer) {
                ctx.save();
                ctx.beginPath();
                ctx.rect(drawX, drawY, finalDrawWidth, finalDrawHeight);
                ctx.clip();

                activeVisualizerOrder.forEach(item => {
                    switch (item.type) {
                        case 'bars': drawBars(ctx, finalDrawWidth, finalDrawHeight, bufferLength, dataArray, activeMusicScaleFactor, drawX, drawY); break;
                        case 'circle-pulse': drawCirclePulse(ctx, finalDrawWidth, finalDrawHeight, activeMusicScaleFactor, average, visualizerIntensity, drawX, drawY); break;
                        case 'wave': drawWave(ctx, finalDrawWidth, finalDrawHeight, bufferLength, dataArray, activeMidScaleFactor, drawX, drawY); break;
                        case 'radial-bars': drawRadialBars(ctx, finalDrawWidth, finalDrawHeight, bufferLength, dataArray, activeBassScaleFactor, drawX, drawY); break;
                        case 'particle-swarm': drawParticleSwarm(ctx, finalDrawWidth, finalDrawHeight, average, visualizerIntensity, activeMusicScaleFactor, drawX, drawY); break;
                        case 'line-spectrum': drawLineSpectrum(ctx, finalDrawWidth, finalDrawHeight, bufferLength, dataArray, activeTrebleScaleFactor, trebleAverage, drawX, drawY); break;
                        case 'frequency-circle': drawFrequencyCircle(ctx, finalDrawWidth, finalDrawHeight, bufferLength, dataArray, activeMusicScaleFactor, drawX, drawY); break;
                        case 'falling-particles': drawFallingParticles(ctx, finalDrawWidth, finalDrawHeight, average, visualizerIntensity, bufferLength, dataArray, drawX, drawY); break;
                        case 'rising-particles': drawRisingParticles(ctx, finalDrawWidth, finalDrawHeight, average, visualizerIntensity, bufferLength, dataArray, drawX, drawY); break;
                        case 'leftward-particles': drawLeftwardParticles(ctx, finalDrawWidth, finalDrawHeight, average, visualizerIntensity, bufferLength, dataArray, drawX, drawY); break;
                        case 'rightward-particles': drawRightwardParticles(ctx, finalDrawWidth, finalDrawHeight, average, visualizerIntensity, bufferLength, dataArray, drawX, drawY); break;
                        case 'colorful-particles': drawColorfulParticles(ctx, finalDrawWidth, finalDrawHeight, average, visualizerIntensity, bufferLength, dataArray, drawX, drawY); break;
                        case 'connecting-lines': drawConnectingLines(ctx, finalDrawWidth, finalDrawHeight, bufferLength, dataArray, activeMusicScaleFactor, visualizerIntensity, average, drawX, drawY); break;
                    }
                });
                ctx.restore();
            }
            ctx.restore();
        }

        function drawVideoLayer(ctx, canvasWidth, canvasHeight, videoLayer) {
            if (!videoLayer.isLoaded || !videoLayer.video || videoLayer.video.readyState < 2) {
                return;
            }

            const layerStartTime = (videoLayer.startTimeMinutes * 60) + videoLayer.startTimeSeconds;
            const layerEndTime = (videoLayer.endTimeMinutes * 60) + videoLayer.endTimeSeconds;
            const currentAudioTime = audioPlayer.currentTime;

            const shouldDisplay = (currentAudioTime >= layerStartTime) && (layerEndTime === 0 || currentAudioTime < layerEndTime);

            if (!shouldDisplay) {
                if (!videoLayer.video.paused) {
                    videoLayer.video.pause();
                }
                return;
            } else {
                const timeDifference = Math.abs(videoLayer.video.currentTime - currentAudioTime);
                if (timeDifference > 0.1) {
                    videoLayer.video.currentTime = currentAudioTime;
                }
                if (videoLayer.video.paused) {
                    videoLayer.video.play().catch(e => console.error("Video autoplay failed:", e));
                }
            }

            ctx.save();

            let initialDrawWidth, initialDrawHeight;
            const videoActualWidth = videoLayer.video.videoWidth;
            const videoActualHeight = videoLayer.video.videoHeight;

            if (videoLayer.autoSize) {
                const videoAspectRatio = videoActualWidth / videoActualHeight;
                const canvasAspectRatio = canvasWidth / canvasHeight;
                if (isNaN(videoAspectRatio) || videoAspectRatio === 0) {
                    initialDrawWidth = 0;
                    initialDrawHeight = 0;
                } else if (videoAspectRatio > canvasAspectRatio) {
                    initialDrawWidth = canvasWidth;
                    initialDrawHeight = canvasWidth / videoAspectRatio;
                } else {
                    initialDrawHeight = canvasHeight;
                    initialDrawWidth = canvasHeight * videoAspectRatio;
                }
            } else {
                initialDrawWidth = videoActualWidth * videoLayer.size;
                initialDrawHeight = videoActualHeight * videoLayer.size;
                if (isNaN(videoActualWidth) || videoActualWidth === 0) {
                    initialDrawWidth = 0;
                    initialDrawHeight = 0;
                } else {
                    const videoAspectRatio = videoActualWidth / videoActualHeight;
                    if (initialDrawWidth > canvasWidth || initialDrawHeight > canvasHeight) {
                        if (videoAspectRatio > canvasWidth / canvasHeight) {
                            initialDrawWidth = canvasWidth;
                            initialDrawHeight = canvasWidth / videoAspectRatio;
                        } else {
                            initialDrawHeight = canvasHeight;
                            initialDrawWidth = canvasHeight * videoAspectRatio;
                        }
                    }
                }
            }

            let finalDrawWidth = initialDrawWidth;
            let finalDrawHeight = initialDrawHeight;

            let drawX, drawY;
            switch(videoLayer.position) {
                case 'bottom-center': drawX = (canvasWidth - finalDrawWidth) / 2; drawY = canvasHeight - finalDrawHeight; break;
                case 'top-center': drawX = (canvasWidth - finalDrawWidth) / 2; drawY = 0; break;
                case 'center-left': drawX = 0; drawY = (canvasHeight - finalDrawHeight) / 2; break;
                case 'center-right': drawX = canvasWidth - finalDrawWidth; drawY = (canvasHeight - finalDrawHeight) / 2; break;
                case 'top-left': drawX = 0; drawY = 0; break;
                case 'top-right': drawX = canvasWidth - finalDrawWidth; drawY = 0; break;
                case 'bottom-left': drawX = 0; drawY = canvasHeight - finalDrawHeight; break;
                case 'bottom-right': drawX = canvasWidth - finalDrawWidth; drawY = canvasHeight - finalDrawHeight; break;
                case 'center': default: drawX = (canvasWidth - finalDrawWidth) / 2; drawY = (canvasHeight - finalDrawHeight) / 2; break;
            }

            if (finalDrawWidth > 0 && finalDrawHeight > 0) {
                ctx.drawImage(videoLayer.video, drawX, drawY, finalDrawWidth, finalDrawHeight);
            }
            ctx.restore();
        }

        // Main drawVisualizer function
        function drawVisualizer(currentTime) {
            const targetCtx = isRecording ? recordingCtx : ctx;
            const targetCanvasWidth = isRecording ? recordingCanvas.width : visualizerCanvas.width;
            const targetCanvasHeight = isRecording ? recordingCanvas.height : visualizerCanvas.height;

            if (!isRecording || (isRecording && mediaRecorder && mediaRecorder.state === 'recording')) {
                animationFrameId = requestAnimationFrame(drawVisualizer);
            } else if (isRecording && mediaRecorder && mediaRecorder.state === 'inactive') {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            if (!lastFrameTime) lastFrameTime = currentTime;
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            if (!analyser || !dataArray) {
                ctx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            let currentFilterToApply = canvasFilterSelect.value;
            if (isRecording && recordWithoutFilterCheckbox.checked) {
                currentFilterToApply = 'none';
            }
            targetCtx.filter = currentFilterToApply;

            targetCtx.clearRect(0, 0, targetCanvasWidth, targetCanvasHeight);

            if (isBgImageLoaded) {
                targetCtx.save();

                const motionType = backgroundMotionTypeSelect.value;
                const motionSpeed = parseFloat(backgroundMotionSpeedSlider.value);

                let sum = 0;
                for (let i = 0; i < bufferLength; i++) { sum += dataArray[i]; }
                let average = sum / bufferLength;
                let activeMusicScaleFactor = 1 + ((average / 255) * 0.4 * parseFloat(visualizerIntensitySlider.value));

                let drawWidth, drawHeight, drawX, drawY;

                if (autoBackgroundSizeCheckbox.checked) {
                    const imgAspectRatio = bgImg.width / bgImg.height;
                    const canvasAspectRatio = targetCanvasWidth / targetCanvasHeight;

                    let sx = 0, sy = 0, sWidth = bgImg.width, sHeight = bgImg.height;
                    let dx = 0, dy = 0, dWidth = targetCanvasWidth, dHeight = targetCanvasHeight;

                    if (imgAspectRatio > canvasAspectRatio) {
                        sWidth = bgImg.height * canvasAspectRatio;
                        sx = (bgImg.width - sWidth) / 2;
                    } else {
                        sHeight = bgImg.width / canvasAspectRatio;
                        sy = (bgImg.height - sHeight) / 2;
                    }

                    drawWidth = dWidth;
                    drawHeight = dHeight;
                    drawX = dx;
                    drawY = dy;

                    if (motionType === 'zoom') {
                        const zoomFactor = 1 + (activeMusicScaleFactor - 1) * motionSpeed * 2;
                        drawWidth *= zoomFactor;
                        drawHeight *= zoomFactor;
                        drawX = (targetCanvasWidth - drawWidth) / 2;
                        drawY = (targetCanvasHeight - drawHeight) / 2;
                    }

                    if (motionType === 'pan-horizontal') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor;
                        backgroundPanOffset.x = (backgroundPanOffset.x + panSpeed * deltaTime) % drawWidth;
                        targetCtx.translate(backgroundPanOffset.x, 0);
                    } else if (motionType === 'pan-vertical') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor;
                        backgroundPanOffset.y = (backgroundPanOffset.y + panSpeed * deltaTime) % drawHeight;
                        targetCtx.translate(0, backgroundPanOffset.y);
                    } else if (motionType === 'rotate') {
                        const rotationSpeed = Math.PI / 4 * motionSpeed * activeMusicScaleFactor;
                        backgroundRotation = (backgroundRotation + rotationSpeed * deltaTime) % (Math.PI * 2);
                        targetCtx.translate(targetCanvasWidth / 2, targetCanvasHeight / 2);
                        targetCtx.rotate(backgroundRotation);
                        targetCtx.translate(-targetCanvasWidth / 2, -targetCanvasHeight / 2);
                    }

                    targetCtx.drawImage(bgImg, sx, sy, sWidth, sHeight, drawX, drawY, drawWidth, drawHeight);

                } else {
                    const backgroundScale = parseFloat(backgroundSizeSlider.value);
                    let initialDrawWidth = bgImg.width * backgroundScale;
                    let initialDrawHeight = bgImg.height * backgroundScale;

                    if (motionType === 'zoom') {
                        const zoomFactor = 1 + (activeMusicScaleFactor - 1) * motionSpeed * 2;
                        initialDrawWidth *= zoomFactor;
                        initialDrawHeight *= zoomFactor;
                    }

                    const alignment = backgroundAlignmentSelect.value;
                    switch (alignment) {
                        case 'top-left': drawX = 0; drawY = 0; break;
                        case 'top-center': drawX = (targetCanvasWidth - initialDrawWidth) / 2; drawY = 0; break;
                        case 'top-right': drawX = targetCanvasWidth - initialDrawWidth; drawY = 0; break;
                        case 'center-left': drawX = 0; drawY = (targetCanvasHeight - initialDrawHeight) / 2; break;
                        case 'center': drawX = (targetCanvasWidth - initialDrawWidth) / 2; drawY = (targetCanvasHeight - initialDrawHeight) / 2; break;
                        case 'center-right': drawX = targetCanvasWidth - initialDrawWidth; drawY = (targetCanvasHeight - initialDrawHeight) / 2; break;
                        case 'bottom-left': drawX = 0; drawY = targetCanvasHeight - initialDrawHeight; break;
                        case 'bottom-center': drawX = (targetCanvasWidth - initialDrawWidth) / 2; drawY = targetCanvasHeight - initialDrawHeight; break;
                        case 'bottom-right': drawX = targetCanvasWidth - initialDrawWidth; drawY = targetCanvasHeight - initialDrawHeight; break;
                        default: drawX = (targetCanvasWidth - initialDrawWidth) / 2; drawY = (targetCanvasHeight - initialDrawHeight) / 2; break;
                    }

                    if (motionType === 'pan-horizontal') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor;
                        backgroundPanOffset.x = (backgroundPanOffset.x + panSpeed * deltaTime) % initialDrawWidth;
                        targetCtx.translate(drawX + backgroundPanOffset.x, drawY);
                        drawX = 0; drawY = 0;
                    } else if (motionType === 'pan-vertical') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor;
                        backgroundPanOffset.y = (backgroundPanOffset.y + panSpeed * deltaTime) % initialDrawHeight;
                        targetCtx.translate(drawX, drawY + backgroundPanOffset.y);
                        drawY = 0; drawX = 0;
                    } else if (motionType === 'rotate') {
                        const rotationSpeed = Math.PI / 4 * motionSpeed * activeMusicScaleFactor;
                        backgroundRotation = (backgroundRotation + rotationSpeed * deltaTime) % (Math.PI * 2);
                        targetCtx.translate(targetCanvasWidth / 2, targetCanvasHeight / 2);
                        targetCtx.rotate(backgroundRotation);
                        targetCtx.translate(-targetCanvasWidth / 2, -targetCanvasHeight / 2);
                    }

                    targetCtx.drawImage(bgImg, drawX, drawY, initialDrawWidth, initialDrawHeight);
                }
                targetCtx.restore();
            } else {
                targetCtx.fillStyle = '#1a202c';
                targetCtx.fillRect(0, 0, targetCanvasWidth, targetCanvasHeight);
            }

            let bassSum = 0;
            for (let i = 0; i < bufferLength * 0.25; i++) { bassSum += dataArray[i]; }
            let bassAverage = bassSum / (bufferLength * 0.25);
            let midSum = 0;
            for (let i = bufferLength * 0.25; i < bufferLength * 0.75; i++) { midSum += dataArray[i]; }
            let midAverage = midSum / (bufferLength * 0.5);
            let trebleSum = 0;
            for (let i = bufferLength * 0.75; i < bufferLength; i++) { trebleSum += dataArray[i]; }
            let trebleAverage = trebleSum / (bufferLength * 0.25);

            let baseMusicScaleFactor = 1 + (average / 255) * 0.4;
            const visualizerIntensity = parseFloat(visualizerIntensitySlider.value);
            let activeMusicScaleFactor = 1 + ((baseMusicScaleFactor - 1) * visualizerIntensity);
            let activeBassScaleFactor = 1 + ((bassAverage / 255) * 0.4 * visualizerIntensity);
            let activeMidScaleFactor = 1 + ((midAverage / 255) * 0.4 * visualizerIntensity);
            let activeTrebleScaleFactor = 1 + ((trebleAverage / 255) * 0.4 * visualizerIntensity);

            activeVisualizerOrder.forEach(item => {
                if (!item.type.startsWith('image-pulse') && item.type !== 'apply-visualizer-to-image') {
                    switch (item.type) {
                        case 'bars': drawBars(targetCtx, targetCanvasWidth, targetCanvasHeight, bufferLength, dataArray, activeMusicScaleFactor); break;
                        case 'circle-pulse': drawCirclePulse(targetCtx, targetCanvasWidth, targetCanvasHeight, activeMusicScaleFactor, average, visualizerIntensity); break;
                        case 'wave': drawWave(targetCtx, targetCanvasWidth, targetCanvasHeight, bufferLength, dataArray, activeMidScaleFactor); break;
                        case 'radial-bars': drawRadialBars(targetCtx, targetCanvasWidth, targetCanvasHeight, bufferLength, dataArray, activeBassScaleFactor); break;
                        case 'particle-swarm': drawParticleSwarm(targetCtx, targetCanvasWidth, targetCanvasHeight, average, visualizerIntensity, activeMusicScaleFactor); break;
                        case 'line-spectrum': drawLineSpectrum(targetCtx, targetCanvasWidth, targetCanvasHeight, bufferLength, dataArray, activeTrebleScaleFactor, trebleAverage); break;
                        case 'frequency-circle': drawFrequencyCircle(targetCtx, targetCanvasWidth, targetCanvasHeight, bufferLength, dataArray, activeMusicScaleFactor); break;
                        case 'falling-particles': drawFallingParticles(targetCtx, targetCanvasWidth, targetCanvasHeight, average, visualizerIntensity, bufferLength, dataArray); break;
                        case 'rising-particles': drawRisingParticles(targetCtx, targetCanvasWidth, targetCanvasHeight, average, visualizerIntensity, bufferLength, dataArray); break;
                        case 'leftward-particles': drawLeftwardParticles(targetCtx, targetCanvasWidth, targetCanvasHeight, average, visualizerIntensity, bufferLength, dataArray); break;
                        case 'rightward-particles': drawRightwardParticles(targetCtx, targetCanvasWidth, targetCanvasHeight, average, visualizerIntensity, bufferLength, dataArray); break;
                        case 'colorful-particles': drawColorfulParticles(targetCtx, targetCanvasWidth, targetCanvasHeight, average, visualizerIntensity, bufferLength, dataArray); break;
                        case 'connecting-lines': drawConnectingLines(targetCtx, targetCanvasWidth, targetCanvasHeight, bufferLength, dataArray, activeMusicScaleFactor, visualizerIntensity, average); break;
                    }
                }
            });

            imageLayers.forEach(imageLayer => {
                drawImageLayer(targetCtx, targetCanvasWidth, targetCanvasHeight, activeMusicScaleFactor, imageLayer, average, visualizerIntensity, bufferLength, dataArray);
            });

            videoLayers.forEach(videoLayer => {
                drawVideoLayer(targetCtx, targetCanvasWidth, targetCanvasHeight, videoLayer);
            });

            if (isLogoLoaded) {
                targetCtx.save();
                let logoDrawSize;
                if (autoLogoSizeCheckbox.checked) {
                    logoDrawSize = 50;
                } else {
                    logoDrawSize = parseFloat(logoSizeSlider.value);
                }

                const padding = 10;
                let logoX, logoY;

                switch (logoPositionSelect.value) {
                    case 'top-left': logoX = padding; logoY = padding; break;
                    case 'top-right': logoX = targetCanvasWidth - logoDrawSize - padding; logoY = padding; break;
                    case 'bottom-left': logoX = padding; logoY = targetCanvasHeight - logoDrawSize - padding; break;
                    case 'bottom-right': logoX = targetCanvasWidth - logoDrawSize - padding; logoY = targetCanvasHeight - logoDrawSize - padding; break;
                    case 'center': logoX = (targetCanvasWidth - logoDrawSize) / 2; logoY = (targetCanvasHeight - logoDrawSize) / 2; break;
                    default: logoX = padding; logoY = padding; break;
                }
                targetCtx.drawImage(logoImg, logoX, logoY, logoDrawSize, logoDrawSize);
                targetCtx.restore();
            }

            textLayers.forEach(textLayer => {
                const text = textLayer.content;
                if (!text) return;

                const layerStartTime = (textLayer.startTimeMinutes * 60) + textLayer.startTimeSeconds;
                const layerEndTime = (textLayer.endTimeMinutes * 60) + textLayer.endTimeSeconds;
                const currentAudioTime = audioPlayer.currentTime;
                const shouldDisplay = (currentAudioTime >= layerStartTime) && (layerEndTime === 0 || currentAudioTime < layerEndTime);

                if (!shouldDisplay) return;

                targetCtx.save();
                targetCtx.fillStyle = textLayer.color;
                
                let fontStyle = '';
                if (textLayer.bold) { fontStyle += 'bold '; }
                targetCtx.font = `${fontStyle}${textLayer.size}px "${textLayer.fontFamily.split(',')[0].trim()}", ${textLayer.fontFamily.split(',').slice(1).join(',').trim() || 'sans-serif'}`;
                
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';

                let textX = targetCanvasWidth / 2;
                let textY = targetCanvasHeight / 2;
                const textPadding = 20;

                switch (textLayer.position) {
                    case 'top-left': textX = textPadding; textY = textPadding; targetCtx.textAlign = 'left'; targetCtx.textBaseline = 'top'; break;
                    case 'top-right': textX = targetCanvasWidth - textPadding; textY = textPadding; targetCtx.textAlign = 'right'; targetCtx.textBaseline = 'top'; break;
                    case 'bottom-left': textX = textPadding; textY = targetCanvasHeight - textPadding; targetCtx.textAlign = 'left'; targetCtx.textBaseline = 'bottom'; break;
                    case 'bottom-right': textX = targetCanvasWidth - textPadding; textY = targetCanvasHeight - textPadding; targetCtx.textAlign = 'right'; targetCtx.textBaseline = 'bottom'; break;
                    case 'bottom-center': textX = targetCanvasWidth / 2; textY = targetCanvasHeight - textPadding; targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'bottom'; break;
                    case 'center': default: textX = targetCanvasWidth / 2; textY = targetCanvasHeight / 2; targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'middle'; break;
                }

                textX += textLayer.marginLeft;
                textX -= textLayer.marginRight;
                textY += textLayer.marginVertical;

                let animatedScale = textLayer.scaleX;
                let animatedAlpha = 1;
                let animatedOffsetX = 0;
                let animatedOffsetY = 0;

                switch (textLayer.animationType) {
                    case 'pulse': animatedScale = textLayer.scaleX * (1 + (activeMusicScaleFactor - 1) * visualizerIntensity); break;
                    case 'fade': animatedAlpha = 0.5 + (average / 255) * 0.5 * visualizerIntensity; break;
                    case 'slide-horizontal': animatedOffsetX = (average / 255 - 0.5) * targetCanvasWidth * 0.1 * visualizerIntensity; break;
                    case 'slide-vertical': animatedOffsetY = (average / 255 - 0.5) * targetCanvasHeight * 0.1 * visualizerIntensity; break;
                }

                targetCtx.translate(textX + animatedOffsetX, textY + animatedOffsetY);
                targetCtx.scale(animatedScale, textLayer.scaleY * animatedScale);
                targetCtx.globalAlpha = animatedAlpha;
                targetCtx.rotate(textLayer.rotation * Math.PI / 180);

                if (textLayer.shadow) {
                    targetCtx.shadowColor = textLayer.shadowColor;
                    targetCtx.shadowBlur = textLayer.shadowBlur;
                    targetCtx.shadowOffsetX = 2;
                    targetCtx.shadowOffsetY = 2;
                } else {
                    targetCtx.shadowColor = 'transparent';
                    targetCtx.shadowBlur = 0;
                    targetCtx.shadowOffsetX = 0;
                    targetCtx.shadowOffsetY = 0;
                }

                if (textLayer.outlineWidth > 0) {
                    targetCtx.strokeStyle = textLayer.outlineColor;
                    targetCtx.lineWidth = textLayer.outlineWidth;
                    targetCtx.lineJoin = 'round';
                }

                if (textLayer.blur) {
                    const blurAmount = textLayer.shadowBlur;
                    targetCtx.filter = `blur(${blurAmount}px)`;
                } else {
                    targetCtx.filter = 'none';
                }

                const lines = text.split('\n');
                const lineHeight = textLayer.size * 1.2;
                const totalTextHeight = lines.length * lineHeight;
                let currentLineY = -totalTextHeight / 2 + lineHeight / 2;

                if (targetCtx.textBaseline === 'top') {
                    currentLineY = lineHeight / 2;
                } else if (targetCtx.textBaseline === 'bottom') {
                    currentLineY = -totalTextHeight + lineHeight / 2;
                }

                lines.forEach(line => {
                    if (textLayer.spacing !== 0) {
                        let currentX = 0;
                        if (targetCtx.textAlign === 'center') {
                            const textWidth = targetCtx.measureText(line).width;
                            currentX = -textWidth / 2;
                        } else if (targetCtx.textAlign === 'right') {
                            const textWidth = targetCtx.measureText(line).width;
                            currentX = -textWidth;
                        }

                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            targetCtx.fillText(char, currentX, currentLineY);
                            if (textLayer.outlineWidth > 0) {
                                targetCtx.strokeText(char, currentX, currentLineY);
                            }
                            currentX += targetCtx.measureText(char).width + textLayer.spacing;
                        }
                    } else {
                        targetCtx.fillText(line, 0, currentLineY);
                        if (textLayer.outlineWidth > 0) {
                            targetCtx.strokeText(line, 0, currentLineY);
                        }
                    }
                    currentLineY += lineHeight;
                });

                targetCtx.restore();
            });

            if (!(isRecording && recordWithoutFilterCheckbox.checked)) {
                targetCtx.filter = 'none';
            }

            if (isRecording) {
                ctx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                ctx.drawImage(recordingCanvas, 0, 0, visualizerCanvas.width, visualizerCanvas.height);
            }
        }

        // --- Event Listeners and Initial Setup ---

        // Get DOM elements
        const audioFile = document.getElementById('audioFile');
        const backgroundFile = document.getElementById('backgroundFile');
        const logoFile = document.getElementById('logoFile');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const audioPlayer = document.getElementById('audioPlayer');
        const visualizerCanvas = document.getElementById('visualizerCanvas');
        const messageBox = document.getElementById('messageBox');
        const aspectRatioSelect = document.getElementById('aspectRatioSelect');
        const outputQualitySelect = document.getElementById('outputQualitySelect');
        const recordingFpsInput = document.getElementById('recordingFpsInput');
        const canvasContainer = document.getElementById('canvasContainer');
        const startRecordBtn = document.getElementById('startRecordBtn');
        const stopRecordBtn = document.getElementById('stopRecordBtn');
        const downloadVideoLink = document.getElementById('downloadVideoLink');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const visualizerTypeControls = document.getElementById('visualizerTypeControls');
        const visualizerCheckboxes = document.querySelectorAll('.visualizer-checkbox');
        const visualizerIntensitySlider = document.getElementById('visualizerIntensitySlider');
        const seekSlider = document.getElementById('seekSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const autoBackgroundSizeCheckbox = document.getElementById('autoBackgroundSizeCheckbox');
        const canvasFilterSelect = document.getElementById('canvasFilterSelect');
        const backgroundSizeSlider = document.getElementById('backgroundSizeSlider');
        const logoPositionSelect = document.getElementById('logoPositionSelect');
        const backgroundMotionTypeSelect = document.getElementById('backgroundMotionTypeSelect');
        const backgroundMotionSpeedSlider = document.getElementById('backgroundMotionSpeedSlider');
        const fontUrlInput = document.getElementById('fontUrlInput');
        const loadFontUrlBtn = document.getElementById('loadFontUrlBtn');
        const fontFileInput = document.getElementById('fontFileInput');
        const customFontNameInput = document.getElementById('customFontNameInput');
        const loadFontFileBtn = document.getElementById('loadFontFileBtn');
        const fontSelect = document.getElementById('fontSelect');
        const logoSizeSlider = document.getElementById('logoSizeSlider');
        const autoLogoSizeCheckbox = document.getElementById('autoLogoSizeCheckbox');
        const recordWithoutFilterCheckbox = document.getElementById('recordWithoutFilterCheckbox');

        const accessModalOverlay = document.getElementById('accessModalOverlay');
        const secretIdInput = document.getElementById('secretIdInput');
        const verifyIdBtn = document.getElementById('verifyIdBtn');
        const appControlsDiv = document.getElementById('appControls');

        const textLayersContainer = document.getElementById('textLayersContainer');
        const addTextLayerBtn = document.getElementById('addTextLayerBtn');
        const addSubtitleLayerBtn = document.getElementById('addSubtitleLayerBtn');
        const textLayerTemplate = document.getElementById('textLayerTemplate');

        const imageLayersContainer = document.getElementById('imageLayersContainer');
        const addImageLayerBtn = document.getElementById('addImageLayerBtn');
        const imageLayerTemplate = document.getElementById('imageLayerTemplate');

        const videoLayersContainer = document.getElementById('videoLayersContainer');
        const addVideoLayerBtn = document.getElementById('addVideoLayerBtn');
        const videoLayerTemplate = document.getElementById('videoLayerTemplate');

        // --- Event Listeners ---
        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                audioPlayer.src = fileURL;
                audioPlayer.load();
                showMessage(`ឯកសារតន្ត្រី "${file.name}" ត្រូវបានផ្ទុក។`);
                initAudioContext();
                playPauseBtn.textContent = 'ផ្អាក';
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        drawVisualizer();
                    });
                } else {
                    drawVisualizer();
                }
                downloadVideoLink.classList.add('hidden');
            } else {
                showMessage('សូមជ្រើសរើសឯកសារតន្ត្រី។', true);
            }
        });

        audioPlayer.addEventListener('loadedmetadata', () => {
            seekSlider.max = audioPlayer.duration;
            timeDisplay.textContent = `0:00 / ${formatTime(audioPlayer.duration)}`;
        });

        audioPlayer.addEventListener('timeupdate', () => {
            if (!seekSlider.dragging) {
                seekSlider.value = audioPlayer.currentTime;
            }
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
        });

        seekSlider.addEventListener('input', () => {
            audioPlayer.currentTime = seekSlider.value;
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
        });

        backgroundFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    bgImg.src = e.target.result;
                    bgImg.onload = () => {
                        isBgImageLoaded = true;
                        showMessage(`រូបភាពផ្ទៃខាងក្រោយ "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer();
                    };
                    bgImg.onerror = () => {
                        isBgImageLoaded = false;
                        showMessage('មិនអាចផ្ទុករូបភាពផ្ទៃខាងក្រោយបានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសរូបភាពផ្ទៃខាងក្រោយ។', true);
            }
        });

        logoFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    logoImg.src = e.target.result;
                    logoImg.onload = () => {
                        isLogoLoaded = true;
                        showMessage(`ឯកសារ Logo "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer();
                    };
                    logoImg.onerror = () => {
                        isLogoLoaded = false;
                        showMessage('មិនអាចផ្ទុក Logo បានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Logo។', true);
            }
        });

        playPauseBtn.addEventListener('click', () => {
            if (!audioPlayer.src) {
                showMessage('សូមផ្ទុកឯកសារតន្ត្រីជាមុនសិន។', true);
                return;
            }

            initAudioContext();

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    if (audioPlayer.paused) {
                        audioPlayer.play();
                        playPauseBtn.textContent = 'ផ្អាក';
                        drawVisualizer();
                    } else {
                        audioPlayer.pause();
                        playPauseBtn.textContent = 'ចាក់';
                        cancelAnimationFrame(animationFrameId);
                    }
                }).catch(e => showMessage(`បរាជ័យក្នុងការបន្ត AudioContext: ${e.message}`, true));
            } else {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                    playPauseBtn.textContent = 'ផ្អាក';
                    drawVisualizer();
                } else {
                    audioPlayer.pause();
                    playPauseBtn.textContent = 'ចាក់';
                    cancelAnimationFrame(animationFrameId);
                }
            }
        });

        volumeSlider.addEventListener('input', () => {
            audioPlayer.volume = volumeSlider.value;
        });

        backgroundSizeSlider.addEventListener('input', () => {
            drawVisualizer();
        });

        autoBackgroundSizeCheckbox.addEventListener('change', () => {
            backgroundSizeSlider.disabled = autoBackgroundSizeCheckbox.checked;
            drawVisualizer();
        });

        backgroundAlignmentSelect.addEventListener('change', () => {
            drawVisualizer();
            showMessage(`ទីតាំងផ្ទៃខាងក្រោយត្រូវបានផ្លាស់ប្តូរទៅជា "${backgroundAlignmentSelect.options[backgroundAlignmentSelect.selectedIndex].text}"។`, false, true);
        });

        backgroundMotionTypeSelect.addEventListener('change', () => {
            backgroundPanOffset = { x: 0, y: 0 };
            backgroundRotation = 0;
            drawVisualizer();
            showMessage(`ចលនាផ្ទៃខាងក្រោយត្រូវបានផ្លាស់ប្តូរទៅជា "${backgroundMotionTypeSelect.options[backgroundMotionTypeSelect.selectedIndex].text}"។`, false, true);
        });

        backgroundMotionSpeedSlider.addEventListener('input', () => {
            drawVisualizer();
        });

        visualizerIntensitySlider.addEventListener('input', () => {
            drawVisualizer();
        });

        aspectRatioSelect.addEventListener('change', (event) => {
            const selectedRatio = event.target.value;
            outputQualitySelect.value = 'current';
            updateCanvasSize();
            showMessage(`ទំហំបង្ហាញត្រូវបានផ្លាស់ប្តូរទៅ ${selectedRatio.replace('-', ':')}។`, false, true);
        });

        outputQualitySelect.addEventListener('change', (event) => {
            updateCanvasSize();
            showMessage(`គុណភាពវីដេអូថតចេញត្រូវបានផ្លាស់ប្តូរទៅជា "${outputQualitySelect.options[outputQualitySelect.selectedIndex].text}"។`, false, true);
        });

        visualizerCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const visualizerType = checkbox.value;
                if (checkbox.checked) {
                    activeVisualizerOrder = activeVisualizerOrder.filter(item => item.type !== visualizerType);
                    activeVisualizerOrder.push({ type: visualizerType, timestamp: Date.now() });
                } else {
                    activeVisualizerOrder = activeVisualizerOrder.filter(item => item.type !== visualizerType);
                    switch (visualizerType) {
                        case 'falling-particles': fallingParticles.length = 0; break;
                        case 'rising-particles': risingParticles.length = 0; break;
                        case 'leftward-particles': leftwardParticles.length = 0; break;
                        case 'rightward-particles': rightwardParticles.length = 0; break;
                        case 'colorful-particles': colorfulParticles.length = 0; break;
                    }
                }
                drawVisualizer();
                const selectedTypes = activeVisualizerOrder.map(item => {
                    const labelElement = document.querySelector(`.visualizer-checkbox[value="${item.type}"]`).parentNode;
                    return labelElement ? labelElement.textContent.trim() : item.type;
                }).join(', ');

                if (selectedTypes) {
                    showMessage(`ប្រភេទចលនាត្រូវបានផ្លាស់ប្តូរទៅជា: ${selectedTypes}។`, false, true);
                } else {
                    showMessage('ចលនាទាំងអស់ត្រូវបានបិទ។', false, true);
                }
            });
        });

        canvasFilterSelect.addEventListener('change', () => {
            drawVisualizer();
            showMessage(`តម្រងរូបភាពត្រូវបានផ្លាស់ប្តូរទៅជា "${canvasFilterSelect.options[canvasFilterSelect.selectedIndex].text}"។`, false, true);
        });

        logoPositionSelect.addEventListener('change', drawVisualizer);

        logoSizeSlider.addEventListener('input', () => {
            drawVisualizer();
        });

        autoLogoSizeCheckbox.addEventListener('change', () => {
            logoSizeSlider.disabled = autoLogoSizeCheckbox.checked;
            drawVisualizer();
        });

        fontUrlInput.addEventListener('change', () => {
            loadFontFromUrl(fontUrlInput.value);
        });

        loadFontUrlBtn.addEventListener('click', () => {
            loadFontFromUrl(fontUrlInput.value);
        });

        fontFileInput.addEventListener('change', (event) => {
            if (event.target.files.length > 0) {
                loadFontFromFile(event.target.files[0], customFontNameInput.value);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Font ដើម្បីផ្ទុក។', true);
            }
        });

        loadFontFileBtn.addEventListener('click', () => {
            if (fontFileInput.files.length > 0) {
                loadFontFromFile(fontFileInput.files[0], customFontNameInput.value);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Font ដើម្បីផ្ទុក។', true);
            }
        });

        fontSelect.addEventListener('change', drawVisualizer);

        fullscreenBtn.addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
                showMessage('ចេញពីរបៀបពេញអេក្រង់។', false, true);
            } else {
                canvasContainer.requestFullscreen().then(() => {
                    showMessage('ចូលទៅរបៀបពេញអេក្រង់។', false, true);
                }).catch(err => {
                    showMessage(`មិនអាចចូលទៅរបៀបពេញអេក្រង់បានទេ: ${err.message}`, true);
                });
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                fullscreenBtn.textContent = 'ចេញពីពេញអេក្រង់';
            } else {
                fullscreenBtn.textContent = 'ពេញអេក្រង់';
            }
            updateCanvasSize();
        });

        startRecordBtn.addEventListener('click', () => {
            console.log('Start Record button clicked.');
            if (!audioPlayer.src) {
                showMessage('សូមផ្ទុកឯកសារតន្ត្រីជាមុមសិន។', true);
                console.log('Error: Audio source not loaded.');
                return;
            }
            const needsImage = imageLayers.some(layer => layer.isLoaded && layer.pulse);
            if (needsImage && imageLayers.length === 0) {
                showMessage('សូមផ្ទុករូបភាពជាមុនសិន ប្រសិនបើអ្នកជ្រើសរើសចលនារូបភាព។', true);
                console.log('Error: Image not loaded for image-pulse visualizer.');
                return;
            }

            initAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed.');
                }).catch(e => {
                    showMessage(`បរាជ័យក្នុងការបន្ត AudioContext: ${e.message}`, true);
                    console.error('Error resuming AudioContext:', e);
                });
            }

            if (audioPlayer.paused) {
                audioPlayer.play();
                playPauseBtn.textContent = 'ផ្អាក';
                console.log('Audio player started.');
            }

            if (!audioDestinationNode) {
                audioDestinationNode = audioContext.createMediaStreamDestination();
                gainNode.connect(audioDestinationNode);
                console.log('AudioDestinationNode created and connected to gainNode.');
            }

            const fps = parseInt(recordingFpsInput.value) || 30;
            const stream = recordingCanvas.captureStream(fps);
            console.log('Recording stream captured from offscreen canvas:', stream, 'at', fps, 'FPS');

            const audioTrack = audioDestinationNode.stream.getAudioTracks()[0];
            if (audioTrack) {
                stream.addTrack(audioTrack);
                console.log('Audio track added to recording stream.');
            } else {
                showMessage('មិនអាចចាប់យកសម្លេងបានទេ។ ត្រូវប្រាកតថាឯកសារតន្ត្រីត្រូវបានផ្ទុក។', true);
                console.error('Error: Audio track not found in audio destination stream.');
                if (audioDestinationNode) {
                    gainNode.disconnect(audioDestinationNode);
                    audioDestinationNode = null;
                }
                isRecording = false;
                return;
            }

            isRecording = true;
            console.log('isRecording set to true.');

            drawVisualizer();
            console.log('drawVisualizer started for recording.');

            recordedChunks = [];
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp8,opus' });
            console.log('MediaRecorder created:', mediaRecorder);

            mediaRecorder.ondataavailable = (event) => {
                console.log('ondataavailable event fired:', event.data.size, 'bytes');
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                console.log('onstop event fired. Recorded chunks:', recordedChunks.length);
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                downloadVideoLink.href = url;
                downloadVideoLink.classList.remove('hidden');
                downloadVideoLink.textContent = 'ទាញយកវីដេអូ (WebM)';
                showMessage('ការថតត្រូវបានបញ្ចប់។ អ្នកអាចទាញយកវីដេអូបាន។', false, true);
                isRecording = false;
                startRecordBtn.disabled = false;
                stopRecordBtn.disabled = true;

                if (audioDestinationNode) {
                    gainNode.disconnect(audioDestinationNode);
                    audioDestinationNode = null;
                }
                ctx.filter = canvasFilterSelect.value;
                console.log('Canvas filter reset to display value.');
            };

            mediaRecorder.start();
            console.log('MediaRecorder started.');
            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = false;
            downloadVideoLink.classList.add('hidden');
            showMessage('កំពុងថតវីដេអូ...', false, true);
        });

        stopRecordBtn.addEventListener('click', () => {
            console.log('Stop Record button clicked.');
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                cancelAnimationFrame(animationFrameId);
                audioPlayer.pause();
                playPauseBtn.textContent = 'ចាក់';
                showMessage('បញ្ឈប់ការថត។ កំពុងរៀបចំវីដេអូ...', false, true);
                console.log('MediaRecorder stopped. Audio paused. Visualization cancelled.');
            }
        });

        window.addEventListener('resize', () => {
            updateCanvasSize();
        });

        // --- Text Layer Management Functions ---
        function createAndAddTextLayer(initialContent = '', isSubtitle = false, copiedLayer = null) {
            const templateClone = textLayerTemplate.content.cloneNode(true);
            const textLayerDiv = templateClone.querySelector('.text-layer-controls');
            const id = textLayerCounter++;
            textLayerDiv.dataset.id = id;

            const textArea = textLayerDiv.querySelector('textarea');
            const colorInput = textLayerDiv.querySelector('input[type="color"]');
            const sizeInput = textLayerDiv.querySelector('input[type="number"]');
            const positionSelect = textLayerDiv.querySelector('select.text-position-select');
            const boldCheckbox = textLayerDiv.querySelector('.text-bold-checkbox');
            const shadowCheckbox = textLayerDiv.querySelector('.text-shadow-checkbox');
            const blurCheckbox = textLayerDiv.querySelector('.text-blur-checkbox');
            const animationTypeSelect = textLayerDiv.querySelector('.text-animation-type-select');
            const removeBtn = textLayerDiv.querySelector('.btn-remove');
            const copyBtn = textLayerDiv.querySelector('.btn-copy');
            const startMinInput = textLayerDiv.querySelector('.text-start-min');
            const startSecInput = textLayerDiv.querySelector('.text-start-sec');
            const endMinInput = textLayerDiv.querySelector('.text-end-min');
            const endSecInput = textLayerDiv.querySelector('.text-end-sec');

            const textOutlineColorInput = textLayerDiv.querySelector('.text-outline-color-input');
            const textOutlineWidthInput = textLayerDiv.querySelector('.text-outline-width-input');
            const textShadowColorInput = textLayerDiv.querySelector('.text-shadow-color-input');
            const textShadowBlurInput = textLayerDiv.querySelector('.text-shadow-blur-input');
            const textMarginLeftInput = textLayerDiv.querySelector('.text-margin-left-input');
            const textMarginRightInput = textLayerDiv.querySelector('.text-margin-right-input');
            const textMarginVerticalInput = textLayerDiv.querySelector('.text-margin-vertical-input');
            const textScaleXInput = textLayerDiv.querySelector('.text-scale-x-input');
            const textScaleYInput = textLayerDiv.querySelector('.text-scale-y-input');
            const textRotationInput = textLayerDiv.querySelector('.text-rotation-input');
            const textSpacingInput = textLayerDiv.querySelector('.text-spacing-input');
            const textFontSelect = textLayerDiv.querySelector('select.font-select');

            const newTextLayer = {
                id: id,
                content: initialContent,
                color: colorInput.value,
                size: parseInt(sizeInput.value),
                position: positionSelect.value,
                bold: boldCheckbox.checked,
                shadow: shadowCheckbox.checked,
                blur: blurCheckbox.checked,
                animationType: animationTypeSelect.value,
                startTimeMinutes: parseInt(startMinInput.value),
                startTimeSeconds: parseInt(startSecInput.value),
                endTimeMinutes: parseInt(endMinInput.value),
                endTimeSeconds: parseInt(endSecInput.value),
                outlineColor: textOutlineColorInput.value,
                outlineWidth: parseFloat(textOutlineWidthInput.value),
                shadowColor: textShadowColorInput.value,
                shadowBlur: parseFloat(textShadowBlurInput.value),
                marginLeft: parseFloat(textMarginLeftInput.value),
                marginRight: parseFloat(textMarginRightInput.value),
                marginVertical: parseFloat(textMarginVerticalInput.value),
                scaleX: parseFloat(textScaleXInput.value),
                scaleY: parseFloat(textScaleYInput.value),
                rotation: parseFloat(textRotationInput.value),
                spacing: parseFloat(textSpacingInput.value),
                fontFamily: defaultFontOptions[0].value,
                currentOffsetX: 0,
                currentOffsetY: 0,
                currentAlpha: 1,
                currentScale: 1
            };

            if (copiedLayer) {
                Object.assign(newTextLayer, JSON.parse(JSON.stringify(copiedLayer)));
                newTextLayer.id = id;
                textArea.value = newTextLayer.content;
                colorInput.value = newTextLayer.color;
                sizeInput.value = newTextLayer.size;
                positionSelect.value = newTextLayer.position;
                boldCheckbox.checked = newTextLayer.bold;
                shadowCheckbox.checked = newTextLayer.shadow;
                blurCheckbox.checked = newTextLayer.blur;
                animationTypeSelect.value = newTextLayer.animationType;
                startMinInput.value = newTextLayer.startTimeMinutes;
                startSecInput.value = newTextLayer.startTimeSeconds;
                endMinInput.value = newTextLayer.endTimeMinutes;
                endSecInput.value = newTextLayer.endTimeSeconds;
                textOutlineColorInput.value = newTextLayer.outlineColor;
                textOutlineWidthInput.value = newTextLayer.outlineWidth;
                textShadowColorInput.value = newTextLayer.shadowColor;
                textShadowBlurInput.value = newTextLayer.shadowBlur;
                textMarginLeftInput.value = newTextLayer.marginLeft;
                textMarginRightInput.value = newTextLayer.marginRight;
                textMarginVerticalInput.value = newTextLayer.marginVertical;
                textScaleXInput.value = newTextLayer.scaleX;
                textScaleYInput.value = newTextLayer.scaleY;
                textRotationInput.value = newTextLayer.rotation;
                textSpacingInput.value = newTextLayer.spacing;
            }

            if (isSubtitle && !copiedLayer) {
                newTextLayer.content = initialContent;
                newTextLayer.color = '#ffffff';
                newTextLayer.size = 40;
                newTextLayer.position = 'bottom-center';
                newTextLayer.bold = true;
                newTextLayer.shadow = true;
                newTextLayer.shadowColor = 'rgba(0,0,0,0.8)';
                newTextLayer.shadowBlur = 5;
                newTextLayer.outlineWidth = 2;
                newTextLayer.outlineColor = '#000000';
                newTextLayer.animationType = 'none';
                newTextLayer.blur = false;
                newTextLayer.marginVertical = -20;
                newTextLayer.fontFamily = 'Noto Sans Khmer';

                textArea.value = newTextLayer.content;
                colorInput.value = newTextLayer.color;
                sizeInput.value = newTextLayer.size;
                positionSelect.value = newTextLayer.position;
                boldCheckbox.checked = newTextLayer.bold;
                shadowCheckbox.checked = newTextLayer.shadow;
                blurCheckbox.checked = newTextLayer.blur;
                animationTypeSelect.value = newTextLayer.animationType;
                textOutlineColorInput.value = newTextLayer.outlineColor;
                textOutlineWidthInput.value = newTextLayer.outlineWidth;
                textShadowColorInput.value = newTextLayer.shadowColor;
                textShadowBlurInput.value = newTextLayer.shadowBlur;
                textMarginVerticalInput.value = newTextLayer.marginVertical;
            }

            textLayers.push(newTextLayer);

            textFontSelect.innerHTML = '';
            defaultFontOptions.forEach(font => {
                const option = new Option(font.text, font.value);
                textFontSelect.add(option);
            });
            textFontSelect.value = newTextLayer.fontFamily;

            textArea.value = newTextLayer.content;

            textArea.addEventListener('input', () => { newTextLayer.content = textArea.value; drawVisualizer(); });
            colorInput.addEventListener('input', () => { newTextLayer.color = colorInput.value; drawVisualizer(); });
            sizeInput.addEventListener('input', () => { newTextLayer.size = parseInt(sizeInput.value); drawVisualizer(); });
            positionSelect.addEventListener('change', () => { newTextLayer.position = positionSelect.value; drawVisualizer(); });
            boldCheckbox.addEventListener('change', () => { newTextLayer.bold = boldCheckbox.checked; drawVisualizer(); });
            shadowCheckbox.addEventListener('change', () => { newTextLayer.shadow = shadowCheckbox.checked; drawVisualizer(); });
            blurCheckbox.addEventListener('change', () => { newTextLayer.blur = blurCheckbox.checked; drawVisualizer(); });
            animationTypeSelect.addEventListener('change', () => { newTextLayer.animationType = animationTypeSelect.value; drawVisualizer(); });
            startMinInput.addEventListener('input', () => { newTextLayer.startTimeMinutes = parseInt(startMinInput.value) || 0; drawVisualizer(); });
            startSecInput.addEventListener('input', () => { newTextLayer.startTimeSeconds = parseInt(startSecInput.value) || 0; drawVisualizer(); });
            endMinInput.addEventListener('input', () => { newTextLayer.endTimeMinutes = parseInt(endMinInput.value) || 0; drawVisualizer(); });
            endSecInput.addEventListener('input', () => { newTextLayer.endTimeSeconds = parseInt(endSecInput.value) || 0; drawVisualizer(); });
            removeBtn.addEventListener('click', () => { removeTextLayer(id); });
            copyBtn.addEventListener('click', () => { copyTextLayer(id); });
            textOutlineColorInput.addEventListener('input', () => { newTextLayer.outlineColor = textOutlineColorInput.value; drawVisualizer(); });
            textOutlineWidthInput.addEventListener('input', () => { newTextLayer.outlineWidth = parseFloat(textOutlineWidthInput.value); drawVisualizer(); });
            textShadowColorInput.addEventListener('input', () => { newTextLayer.shadowColor = textShadowColorInput.value; drawVisualizer(); });
            textShadowBlurInput.addEventListener('input', () => { newTextLayer.shadowBlur = parseFloat(textShadowBlurInput.value); drawVisualizer(); });
            textMarginLeftInput.addEventListener('input', () => { newTextLayer.marginLeft = parseFloat(textMarginLeftInput.value); drawVisualizer(); });
            textMarginRightInput.addEventListener('input', () => { newTextLayer.marginRight = parseFloat(textMarginRightInput.value); drawVisualizer(); });
            textMarginVerticalInput.addEventListener('input', () => { newTextLayer.marginVertical = parseFloat(textMarginVerticalInput.value); drawVisualizer(); });
            textScaleXInput.addEventListener('input', () => { newTextLayer.scaleX = parseFloat(textScaleXInput.value); drawVisualizer(); });
            textScaleYInput.addEventListener('input', () => { newTextLayer.scaleY = parseFloat(textScaleYInput.value); drawVisualizer(); });
            textRotationInput.addEventListener('input', () => { newTextLayer.rotation = parseFloat(textRotationInput.value); drawVisualizer(); });
            textSpacingInput.addEventListener('input', () => { newTextLayer.spacing = parseFloat(textSpacingInput.value); drawVisualizer(); });
            textFontSelect.addEventListener('change', () => { newTextLayer.fontFamily = textFontSelect.value; drawVisualizer(); });

            textLayersContainer.appendChild(textLayerDiv);
            drawVisualizer();
        }

        function copyTextLayer(idToCopy) {
            const originalLayer = textLayers.find(layer => layer.id === idToCopy);
            if (originalLayer) {
                const clonedLayer = { ...originalLayer };
                clonedLayer.id = textLayerCounter++;
                createAndAddTextLayer(clonedLayer.content, false, clonedLayer); // Pass clonedLayer to set values
                showMessage('អត្ថបទត្រូវបានចម្លង។', false, true);
            } else {
                showMessage('មិនអាចរកឃើញស្រទាប់អត្ថបទដើម្បីចម្លងបានទេ។', true);
            }
        }

        function removeTextLayer(idToRemove) {
            const elementToRemove = textLayersContainer.querySelector(`[data-id="${idToRemove}"]`);
            if (elementToRemove) {
                const foundIndex = textLayers.findIndex(layer => layer.id === idToRemove);
                
                if (foundIndex > -1) {
                    textLayers.splice(foundIndex, 1);
                }
                
                elementToRemove.remove();
                showMessage('អត្ថបទត្រូវបានលុប។', false, true);
                drawVisualizer();
            }
        }

        addTextLayerBtn.addEventListener('click', () => {
            createAndAddTextLayer('');
        });

        addSubtitleLayerBtn.addEventListener('click', () => {
            createAndAddTextLayer('បញ្ចូល Subtitle នៅទីនេះ', true);
        });


        // --- Image Layer Management Functions ---
        function createAndAddImageLayer(copiedLayer = null) {
            const templateClone = imageLayerTemplate.content.cloneNode(true);
            const imageLayerDiv = templateClone.querySelector('.image-layer-controls');
            const id = imageLayerCounter++;
            imageLayerDiv.dataset.id = id;

            const imageFileInput = imageLayerDiv.querySelector('.image-file-input');
            const imagePreviewThumbnail = imageLayerDiv.querySelector('.image-preview-thumbnail');
            const imageSizeSlider = imageLayerDiv.querySelector('.image-size-slider');
            const autoImageSizeCheckbox = imageLayerDiv.querySelector('.auto-image-size-checkbox');
            const imagePositionSelect = imageLayerDiv.querySelector('.image-position-select');
            const imagePulseCheckbox = imageLayerDiv.querySelector('.image-pulse-checkbox');
            const applyVisualizerToImageCheckbox = imageLayerDiv.querySelector('.apply-visualizer-to-image-checkbox');
            const removeBtn = imageLayerDiv.querySelector('.btn-remove');
            const copyBtn = imageLayerDiv.querySelector('.btn-copy-image');
            const startMinInput = imageLayerDiv.querySelector('.image-start-min');
            const startSecInput = imageLayerDiv.querySelector('.image-start-sec');
            const endMinInput = imageLayerDiv.querySelector('.image-end-min');
            const endSecInput = imageLayerDiv.querySelector('.image-end-sec');

            const newImageLayer = {
                id: id,
                img: new Image(),
                isLoaded: false,
                src: '',
                size: parseFloat(imageSizeSlider.value),
                autoSize: autoImageSizeCheckbox.checked,
                position: imagePositionSelect.value,
                pulse: imagePulseCheckbox.checked,
                applyVisualizer: applyVisualizerToImageCheckbox.checked,
                startTimeMinutes: parseInt(startMinInput.value),
                startTimeSeconds: parseInt(startSecInput.value),
                endTimeMinutes: parseInt(endMinInput.value),
                endTimeSeconds: parseInt(endSecInput.value)
            };

            if (copiedLayer) {
                Object.assign(newImageLayer, JSON.parse(JSON.stringify(copiedLayer)));
                newImageLayer.id = id;
                newImageLayer.img = new Image();
                newImageLayer.img.src = copiedLayer.src;
                newImageLayer.isLoaded = copiedLayer.isLoaded;

                imagePreviewThumbnail.src = newImageLayer.src;
                imageSizeSlider.value = newImageLayer.size;
                autoImageSizeCheckbox.checked = newImageLayer.autoSize;
                imageSizeSlider.disabled = newImageLayer.autoSize;
                imagePositionSelect.value = newImageLayer.position;
                imagePulseCheckbox.checked = newImageLayer.pulse;
                applyVisualizerToImageCheckbox.checked = newImageLayer.applyVisualizer;
                startMinInput.value = newImageLayer.startTimeMinutes;
                startSecInput.value = newImageLayer.startTimeSeconds;
                endMinInput.value = newImageLayer.endTimeMinutes;
                endSecInput.value = newImageLayer.endTimeSeconds;
            }

            imageLayers.push(newImageLayer);

            imageSizeSlider.disabled = newImageLayer.autoSize;

            imageFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        newImageLayer.src = e.target.result;
                        newImageLayer.img.src = e.target.result;
                        newImageLayer.img.onload = () => {
                            newImageLayer.isLoaded = true;
                            imagePreviewThumbnail.src = newImageLayer.src;
                            drawVisualizer();
                            showMessage(`រូបភាព "${file.name}" ត្រូវបានផ្ទុក។`);
                        };
                        newImageLayer.img.onerror = () => {
                            newImageLayer.isLoaded = false;
                            showMessage('មិនអាចផ្ទុករូបភាពបានទេ។', true);
                        };
                    };
                    reader.readAsDataURL(file);
                } else {
                    newImageLayer.isLoaded = false;
                    imagePreviewThumbnail.src = '';
                    showMessage('សូមជ្រើសរើសរូបភាព។', true);
                }
                moveImageLayerToTop(id);
            });

            imageSizeSlider.addEventListener('input', () => {
                newImageLayer.size = parseFloat(imageSizeSlider.value);
                moveImageLayerToTop(id);
            });

            autoImageSizeCheckbox.addEventListener('change', () => {
                newImageLayer.autoSize = autoImageSizeCheckbox.checked;
                imageSizeSlider.disabled = newImageLayer.autoSize;
                moveImageLayerToTop(id);
            });

            imagePositionSelect.addEventListener('change', () => {
                newImageLayer.position = imagePositionSelect.value;
                moveImageLayerToTop(id);
            });

            imagePulseCheckbox.addEventListener('change', () => {
                newImageLayer.pulse = imagePulseCheckbox.checked;
                moveImageLayerToTop(id);
            });

            applyVisualizerToImageCheckbox.addEventListener('change', () => {
                newImageLayer.applyVisualizer = applyVisualizerToImageCheckbox.checked;
                drawVisualizer();
            });

            startMinInput.addEventListener('input', () => {
                newImageLayer.startTimeMinutes = parseInt(startMinInput.value) || 0;
                drawVisualizer();
            });
            startSecInput.addEventListener('input', () => {
                newImageLayer.startTimeSeconds = parseInt(startSecInput.value) || 0;
                drawVisualizer();
            });
            endMinInput.addEventListener('input', () => {
                newImageLayer.endTimeMinutes = parseInt(endMinInput.value) || 0;
                drawVisualizer();
            });
            endSecInput.addEventListener('input', () => {
                newImageLayer.endTimeSeconds = parseInt(endSecInput.value) || 0;
                drawVisualizer();
            });

            removeBtn.addEventListener('click', () => {
                removeImageLayer(id);
            });
            copyBtn.addEventListener('click', () => {
                copyImageLayer(id);
            });

            imageLayersContainer.appendChild(imageLayerDiv);
            drawVisualizer();
        }

        function copyImageLayer(idToCopy) {
            const originalLayer = imageLayers.find(layer => layer.id === idToCopy);
            if (originalLayer) {
                const clonedLayer = { ...originalLayer };
                clonedLayer.id = imageLayerCounter++;
                clonedLayer.img = new Image();
                clonedLayer.img.src = originalLayer.src;
                clonedLayer.isLoaded = originalLayer.isLoaded;

                const templateClone = imageLayerTemplate.content.cloneNode(true);
                const imageLayerDiv = templateClone.querySelector('.image-layer-controls');
                imageLayerDiv.dataset.id = clonedLayer.id;

                const imageFileInput = imageLayerDiv.querySelector('.image-file-input');
                const imagePreviewThumbnail = imageLayerDiv.querySelector('.image-preview-thumbnail');
                const imageSizeSlider = imageLayerDiv.querySelector('.image-size-slider');
                const autoImageSizeCheckbox = imageLayerDiv.querySelector('.auto-image-size-checkbox');
                const imagePositionSelect = imageLayerDiv.querySelector('.image-position-select');
                const imagePulseCheckbox = imageLayerDiv.querySelector('.image-pulse-checkbox');
                const applyVisualizerToImageCheckbox = imageLayerDiv.querySelector('.apply-visualizer-to-image-checkbox');
                const removeBtn = imageLayerDiv.querySelector('.btn-remove');
                const copyBtn = imageLayerDiv.querySelector('.btn-copy-image');
                const startMinInput = imageLayerDiv.querySelector('.image-start-min');
                const startSecInput = imageLayerDiv.querySelector('.image-start-sec');
                const endMinInput = imageLayerDiv.querySelector('.image-end-min');
                const endSecInput = imageLayerDiv.querySelector('.image-end-sec');

                imagePreviewThumbnail.src = clonedLayer.src;
                imageSizeSlider.value = clonedLayer.size;
                autoImageSizeCheckbox.checked = clonedLayer.autoSize;
                imageSizeSlider.disabled = clonedLayer.autoSize;
                imagePositionSelect.value = clonedLayer.position;
                imagePulseCheckbox.checked = clonedLayer.pulse;
                applyVisualizerToImageCheckbox.checked = clonedLayer.applyVisualizer;
                startMinInput.value = clonedLayer.startTimeMinutes;
                startSecInput.value = clonedLayer.startTimeSeconds;
                endMinInput.value = clonedLayer.endTimeMinutes;
                endSecInput.value = clonedLayer.endTimeSeconds;

                imageFileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            clonedLayer.src = e.target.result;
                            clonedLayer.img.src = e.target.result;
                            clonedLayer.img.onload = () => {
                                clonedLayer.isLoaded = true;
                                imagePreviewThumbnail.src = clonedLayer.src;
                                drawVisualizer();
                                showMessage(`រូបភាព "${file.name}" ត្រូវបានផ្ទុក។`);
                            };
                            clonedLayer.img.onerror = () => {
                                clonedLayer.isLoaded = false;
                                showMessage('មិនអាចផ្ទុករូបភាពបានទេ។', true);
                            };
                        };
                        reader.readAsDataURL(file);
                    } else {
                        clonedLayer.isLoaded = false;
                        imagePreviewThumbnail.src = '';
                        showMessage('សូមជ្រើសរើសរូបភាព។', true);
                    }
                    moveImageLayerToTop(clonedLayer.id);
                });

                imageSizeSlider.addEventListener('input', () => { clonedLayer.size = parseFloat(imageSizeSlider.value); moveImageLayerToTop(clonedLayer.id); });
                autoImageSizeCheckbox.addEventListener('change', () => { clonedLayer.autoSize = autoImageSizeCheckbox.checked; imageSizeSlider.disabled = clonedLayer.autoSize; moveImageLayerToTop(clonedLayer.id); });
                imagePositionSelect.addEventListener('change', () => { clonedLayer.position = imagePositionSelect.value; moveImageLayerToTop(clonedLayer.id); });
                imagePulseCheckbox.addEventListener('change', () => { clonedLayer.pulse = imagePulseCheckbox.checked; moveImageLayerToTop(clonedLayer.id); });
                applyVisualizerToImageCheckbox.addEventListener('change', () => { clonedLayer.applyVisualizer = applyVisualizerToImageCheckbox.checked; drawVisualizer(); });
                startMinInput.addEventListener('input', () => { clonedLayer.startTimeMinutes = parseInt(startMinInput.value) || 0; drawVisualizer(); });
                startSecInput.addEventListener('input', () => { clonedLayer.startTimeSeconds = parseInt(startSecInput.value) || 0; drawVisualizer(); });
                endMinInput.addEventListener('input', () => { clonedLayer.endTimeMinutes = parseInt(endMinInput.value) || 0; drawVisualizer(); });
                endSecInput.addEventListener('input', () => { clonedLayer.endTimeSeconds = parseInt(endSecInput.value) || 0; drawVisualizer(); });
                removeBtn.addEventListener('click', () => { removeImageLayer(clonedLayer.id); });
                copyBtn.addEventListener('click', () => { copyImageLayer(clonedLayer.id); });


                imageLayersContainer.appendChild(imageLayerDiv);
                imageLayers.push(clonedLayer);
                drawVisualizer();
                showMessage('រូបភាពត្រូវបានចម្លង។', false, true);
            } else {
                showMessage('មិនអាចរកឃើញស្រទាប់រូបភាពដើម្បីចម្លងបានទេ។', true);
            }
        }

        function moveImageLayerToTop(idToMove) {
            const index = imageLayers.findIndex(layer => layer.id === idToMove);
            if (index > -1) {
                const [movedLayer] = imageLayers.splice(index, 1);
                imageLayers.push(movedLayer);
                drawVisualizer();
            }
        }

        function removeImageLayer(idToRemove) {
            const elementToRemove = imageLayersContainer.querySelector(`[data-id="${idToRemove}"]`);
            if (elementToRemove) {
                const foundIndex = imageLayers.findIndex(layer => layer.id === idToRemove);
                if (foundIndex > -1) {
                    imageLayers.splice(foundIndex, 1);
                }
                elementToRemove.remove();
                showMessage('រូបភាពត្រូវបានលុប។', false, true);
                drawVisualizer();
            }
        }

        addImageLayerBtn.addEventListener('click', () => {
            createAndAddImageLayer();
        });


        // --- Video Layer Management Functions ---
        function createAndAddVideoLayer(copiedLayer = null) {
            const templateClone = videoLayerTemplate.content.cloneNode(true);
            const videoLayerDiv = templateClone.querySelector('.video-layer-controls');
            const id = videoLayerCounter++;
            videoLayerDiv.dataset.id = id;

            const videoFileInput = videoLayerDiv.querySelector('.video-file-input');
            const videoPreviewThumbnail = videoLayerDiv.querySelector('.video-preview-thumbnail');
            const videoSizeSlider = videoLayerDiv.querySelector('.video-size-slider');
            const autoVideoSizeCheckbox = videoLayerDiv.querySelector('.auto-video-size-checkbox');
            const videoPositionSelect = videoLayerDiv.querySelector('.video-position-select');
            const removeBtn = videoLayerDiv.querySelector('.btn-remove');
            const copyBtn = videoLayerDiv.querySelector('.btn-copy-video');
            const startMinInput = videoLayerDiv.querySelector('.video-start-min');
            const startSecInput = videoLayerDiv.querySelector('.video-start-sec');
            const endMinInput = videoLayerDiv.querySelector('.video-end-min');
            const endSecInput = videoLayerDiv.querySelector('.video-end-sec');

            const newVideoLayer = {
                id: id,
                video: document.createElement('video'),
                isLoaded: false,
                src: '',
                size: parseFloat(videoSizeSlider.value),
                autoSize: autoVideoSizeCheckbox.checked,
                position: videoPositionSelect.value,
                startTimeMinutes: parseInt(startMinInput.value),
                startTimeSeconds: parseInt(startSecInput.value),
                endTimeMinutes: parseInt(endMinInput.value),
                endTimeSeconds: parseInt(endSecInput.value)
            };

            newVideoLayer.video.muted = true;
            newVideoLayer.video.loop = true;
            newVideoLayer.video.autoplay = true;
            newVideoLayer.video.preload = 'auto';

            if (copiedLayer) {
                Object.assign(newVideoLayer, JSON.parse(JSON.stringify(copiedLayer)));
                newVideoLayer.id = id;
                newVideoLayer.video = document.createElement('video');
                newVideoLayer.video.muted = true;
                newVideoLayer.video.loop = true;
                newVideoLayer.video.autoplay = true;
                newVideoLayer.video.preload = 'auto';
                newVideoLayer.video.src = copiedLayer.src;
                newVideoLayer.isLoaded = copiedLayer.isLoaded;

                videoPreviewThumbnail.src = newVideoLayer.src;
                videoSizeSlider.value = newVideoLayer.size;
                autoVideoSizeCheckbox.checked = newVideoLayer.autoSize;
                videoSizeSlider.disabled = newVideoLayer.autoSize;
                videoPositionSelect.value = newVideoLayer.position;
                startMinInput.value = newVideoLayer.startTimeMinutes;
                startSecInput.value = newVideoLayer.startTimeSeconds;
                endMinInput.value = newVideoLayer.endTimeMinutes;
                endSecInput.value = newVideoLayer.endTimeSeconds;
            }

            videoLayers.push(newVideoLayer);

            videoFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const fileURL = URL.createObjectURL(file);
                    newVideoLayer.src = fileURL;
                    newVideoLayer.video.src = fileURL;
                    videoPreviewThumbnail.src = fileURL;

                    newVideoLayer.video.onloadedmetadata = () => {
                        newVideoLayer.isLoaded = true;
                        newVideoLayer.video.play().catch(e => console.error("Video autoplay failed:", e));
                        drawVisualizer();
                        showMessage(`វីដេអូ "${file.name}" ត្រូវបានផ្ទុក។`);
                    };
                    newVideoLayer.video.onerror = () => {
                        newVideoLayer.isLoaded = false;
                        showMessage('មិនអាចផ្ទុកវីដេអូបានទេ។', true);
                    };
                } else {
                    newVideoLayer.isLoaded = false;
                    newVideoLayer.src = '';
                    videoPreviewThumbnail.src = '';
                    showMessage('សូមជ្រើសរើសវីដេអូ។', true);
                }
                moveVideoLayerToTop(id);
            });

            videoSizeSlider.addEventListener('input', () => {
                newVideoLayer.size = parseFloat(videoSizeSlider.value);
                moveVideoLayerToTop(id);
            });

            autoVideoSizeCheckbox.addEventListener('change', () => {
                newVideoLayer.autoSize = autoVideoSizeCheckbox.checked;
                videoSizeSlider.disabled = newVideoLayer.autoSize;
                moveVideoLayerToTop(id);
            });

            videoPositionSelect.addEventListener('change', () => {
                newVideoLayer.position = videoPositionSelect.value;
                moveVideoLayerToTop(id);
            });

            startMinInput.addEventListener('input', () => {
                newVideoLayer.startTimeMinutes = parseInt(startMinInput.value) || 0;
                drawVisualizer();
            });
            startSecInput.addEventListener('input', () => {
                newVideoLayer.startTimeSeconds = parseInt(startSecInput.value) || 0;
                drawVisualizer();
            });
            endMinInput.addEventListener('input', () => {
                newVideoLayer.endTimeMinutes = parseInt(endMinInput.value) || 0;
                drawVisualizer();
            });
            endSecInput.addEventListener('input', () => {
                newVideoLayer.endTimeSeconds = parseInt(endSecInput.value) || 0;
                drawVisualizer();
            });

            removeBtn.addEventListener('click', () => {
                removeVideoLayer(id);
            });
            copyBtn.addEventListener('click', () => {
                copyVideoLayer(id);
            });

            videoLayersContainer.appendChild(videoLayerDiv);
            drawVisualizer();
        }

        function copyVideoLayer(idToCopy) {
            const originalLayer = videoLayers.find(layer => layer.id === idToCopy);
            if (originalLayer) {
                const clonedLayer = { ...originalLayer };
                clonedLayer.id = videoLayerCounter++;
                clonedLayer.video = document.createElement('video');
                clonedLayer.video.muted = true;
                clonedLayer.video.loop = true;
                clonedLayer.video.autoplay = true;
                clonedLayer.video.preload = 'auto';
                clonedLayer.video.src = originalLayer.src;
                clonedLayer.isLoaded = originalLayer.isLoaded;

                const templateClone = videoLayerTemplate.content.cloneNode(true);
                const videoLayerDiv = templateClone.querySelector('.video-layer-controls');
                videoLayerDiv.dataset.id = clonedLayer.id;

                const videoFileInput = videoLayerDiv.querySelector('.video-file-input');
                const videoPreviewThumbnail = videoLayerDiv.querySelector('.video-preview-thumbnail');
                const videoSizeSlider = videoLayerDiv.querySelector('.video-size-slider');
                const autoVideoSizeCheckbox = videoLayerDiv.querySelector('.auto-video-size-checkbox');
                const videoPositionSelect = videoLayerDiv.querySelector('.video-position-select');
                const removeBtn = videoLayerDiv.querySelector('.btn-remove');
                const copyBtn = videoLayerDiv.querySelector('.btn-copy-video');
                const startMinInput = videoLayerDiv.querySelector('.video-start-min');
                const startSecInput = videoLayerDiv.querySelector('.video-start-sec');
                const endMinInput = videoLayerDiv.querySelector('.video-end-min');
                const endSecInput = videoLayerDiv.querySelector('.video-end-sec');

                videoPreviewThumbnail.src = clonedLayer.src;
                videoSizeSlider.value = clonedLayer.size;
                autoVideoSizeCheckbox.checked = clonedLayer.autoSize;
                videoSizeSlider.disabled = clonedLayer.autoSize;
                videoPositionSelect.value = clonedLayer.position;
                startMinInput.value = clonedLayer.startTimeMinutes;
                startSecInput.value = clonedLayer.startTimeSeconds;
                endMinInput.value = clonedLayer.endTimeMinutes;
                endSecInput.value = clonedLayer.endTimeSeconds;

                videoFileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const fileURL = URL.createObjectURL(file);
                        clonedLayer.src = fileURL;
                        clonedLayer.video.src = fileURL;
                        videoPreviewThumbnail.src = fileURL;
                        clonedLayer.video.onloadedmetadata = () => {
                            clonedLayer.isLoaded = true;
                            clonedLayer.video.play().catch(e => console.error("Video autoplay failed:", e));
                            drawVisualizer();
                            showMessage(`វីដេអូ "${file.name}" ត្រូវបានផ្ទុក។`);
                        };
                        clonedLayer.video.onerror = () => {
                            clonedLayer.isLoaded = false;
                            showMessage('មិនអាចផ្ទុកវីដេអូបានទេ។', true);
                        };
                    } else {
                        clonedLayer.isLoaded = false;
                        videoPreviewThumbnail.src = '';
                        showMessage('សូមជ្រើសរើសវីដេអូ។', true);
                    }
                    moveVideoLayerToTop(clonedLayer.id);
                });
                videoSizeSlider.addEventListener('input', () => { clonedLayer.size = parseFloat(videoSizeSlider.value); moveVideoLayerToTop(clonedLayer.id); });
                autoVideoSizeCheckbox.addEventListener('change', () => { clonedLayer.autoSize = autoVideoSizeCheckbox.checked; videoSizeSlider.disabled = clonedLayer.autoSize; moveVideoLayerToTop(clonedLayer.id); });
                videoPositionSelect.addEventListener('change', () => { clonedLayer.position = videoPositionSelect.value; moveVideoLayerToTop(clonedLayer.id); });
                startMinInput.addEventListener('input', () => { clonedLayer.startTimeMinutes = parseInt(startMinInput.value) || 0; drawVisualizer(); });
                startSecInput.addEventListener('input', () => { clonedLayer.startTimeSeconds = parseInt(startSecInput.value) || 0; drawVisualizer(); });
                endMinInput.addEventListener('input', () => { clonedLayer.endTimeMinutes = parseInt(endMinInput.value) || 0; drawVisualizer(); });
                endSecInput.addEventListener('input', () => { clonedLayer.endTimeSeconds = parseInt(endSecInput.value) || 0; drawVisualizer(); });
                removeBtn.addEventListener('click', () => { removeVideoLayer(clonedLayer.id); });
                copyBtn.addEventListener('click', () => { copyVideoLayer(clonedLayer.id); });

                videoLayersContainer.appendChild(videoLayerDiv);
                videoLayers.push(clonedLayer);
                drawVisualizer();
                showMessage('វីដេអូត្រូវបានចម្លង។', false, true);
            } else {
                showMessage('មិនអាចរកឃើញស្រទាប់វីដេអូដើម្បីចម្លងបានទេ។', true);
            }
        }

        function moveVideoLayerToTop(idToMove) {
            const index = videoLayers.findIndex(layer => layer.id === idToMove);
            if (index > -1) {
                const [movedLayer] = videoLayers.splice(index, 1);
                videoLayers.push(movedLayer);
                drawVisualizer();
            }
        }

        function removeVideoLayer(idToRemove) {
            const elementToRemove = videoLayersContainer.querySelector(`[data-id="${idToRemove}"]`);
            if (elementToRemove) {
                const foundIndex = videoLayers.findIndex(layer => layer.id === idToRemove);
                if (foundIndex > -1) {
                    if (videoLayers[foundIndex].video) {
                        videoLayers[foundIndex].video.pause();
                        videoLayers[foundIndex].video.removeAttribute('src');
                        videoLayers[foundIndex].video.load();
                    }
                    videoLayers.splice(foundIndex, 1);
                }
                elementToRemove.remove();
                showMessage('វីដេអូត្រូវបានលុប។', false, true);
                drawVisualizer();
            }
        }

        addVideoLayerBtn.addEventListener('click', () => {
            createAndAddVideoLayer();
        });

    </script>
</body>
</html>
