<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>កម្មវិធីចាក់តន្ត្រី និងបង្ហាញរូបភាពតាមចង្វាក់</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for Khmer -->
    <link href="https://fonts.googleapis.com/css2?family=Battambang&family=Bayon&family=Freehand&family=Kdam+Thmor&family=Moul&family=Noto+Sans+Khmer:wght@100..900&family=Preahvihear&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center; /* Center the main wrapper */
            align-items: flex-start; /* Align wrapper to top */
            min-height: 100vh;
            margin: 0;
            overflow-y: auto; /* Allow vertical scrolling for the whole page if needed */
            padding: 2rem; /* Padding around the whole content */
        }

        .main-wrapper {
            display: flex;
            flex-direction: column; /* Controls and visualizer stacked vertically */
            gap: 2rem; /* Space between the two main sections */
            width: 100%;
            max-width: 1200px; /* Max width for the entire application layout */
            align-items: center; /* Center items when stacked */
        }

        .controls-panel {
            background-color: #2d3748;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            padding: 2.5rem;
            width: 100%;
            max-width: 400px; /* Fixed max-width for controls */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            max-height: calc(100vh - 4rem); /* Limit height for scrolling controls */
            overflow-y: auto; /* Allow internal scrolling for controls */
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        .visualizer-area {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            flex-grow: 1; /* Allow visualizer area to take remaining space */
            width: 100%; /* Important for flex-grow to work properly */
            max-width: 800px; /* Max width for the visualizer content */
            align-items: center; /* Center items within visualizer area */
        }

        .canvas-container {
            width: 100%; /* Take full width of its parent (.visualizer-area) */
            background-color: #1a202c;
            border-radius: 0.75rem;
            border: 2px solid #4a5568;
            position: relative; /* For aspect ratio padding trick */
            overflow: hidden;
        }
        /* Aspect ratio classes */
        .aspect-ratio-16-9 { padding-bottom: 56.25%; /* 9 / 16 * 100 */ }
        .aspect-ratio-9-16 { padding-bottom: 177.77%; /* 16 / 9 * 100 */ }
        .aspect-ratio-1-1 { padding-bottom: 100%; }
        /* Explicit sizes for recording qualities */
        .fixed-size {
            padding-bottom: 0 !important; /* Override aspect ratio padding */
        }


        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            width: 100%;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
        .btn {
            background-color: #4299e1; /* Blue button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            font-weight: bold;
            border: none;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .btn:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-red {
            background-color: #e53e3e; /* Red button for recording */
        }
        .btn-red:hover {
            background-color: #c53030;
        }
        .btn-green {
            background-color: #38a169; /* Green button for stopping */
        }
        .btn-green:hover {
            background-color: #2f855a;
        }
        .volume-slider, .aspect-ratio-select, .image-size-slider, .visualizer-intensity-slider, .seek-slider,
        .canvas-filter-select, .text-color-input, .text-size-input, .text-position-select, .background-size-slider, .logo-position-select,
        .background-motion-type-select, .background-motion-speed-slider, .font-url-input, .font-select, .logo-size-slider, .text-animation-type-select, .background-alignment-select,
        .time-input, .margin-input, .transform-slider, .text-shadow-blur-input {
            width: 150px;
            -webkit-appearance: none;
            height: 8px;
            background: #4a5568;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
            padding: 0.5rem; /* Add padding for select */
            border: none;
            color: #e2e8f0;
        }
        .volume-slider:hover, .aspect-ratio-select:hover, .image-size-slider:hover, .visualizer-intensity-slider:hover, .seek-slider:hover,
        .canvas-filter-select:hover, .text-color-input:hover, .text-size-input:hover, .text-position-select:hover, .background-size-slider:hover, .logo-position-select:hover,
        .background-motion-type-select:hover, .background-motion-speed-slider:hover, .font-url-input:hover, .font-select:hover, .logo-size-slider:hover, .text-animation-type-select:hover,
        .time-input:hover, .margin-input:hover, .transform-slider:hover, .text-shadow-blur-input:hover {
            opacity: 1;
        }
        .volume-slider::-webkit-slider-thumb, .image-size-slider::-webkit-slider-thumb, .visualizer-intensity-slider::-webkit-slider-thumb, .seek-slider::-webkit-slider-thumb, .background-size-slider::-webkit-slider-thumb, .background-motion-speed-slider::-webkit-slider-thumb, .logo-size-slider::-webkit-slider-thumb, .time-input::-webkit-slider-thumb, .transform-slider::-webkit-slider-thumb, .text-shadow-blur-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
        .volume-slider::-moz-range-thumb, .image-size-slider::-moz-range-thumb, .visualizer-intensity-slider::-moz-range-thumb, .seek-slider::-moz-range-thumb, .background-size-slider::-moz-range-thumb, .background-motion-speed-slider::-moz-range-thumb, .logo-size-slider::-moz-range-thumb, .time-input::-moz-range-thumb, .transform-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
        .aspect-ratio-select, .canvas-filter-select, .text-position-select, .logo-position-select, .background-motion-type-select, .font-select, .text-animation-type-select, .background-alignment-select {
            background-color: #4a5568;
            cursor: pointer;
            width: auto; /* Adjust width based on content */
            z-index: 10; /* Added z-index */
            position: relative; /* Ensure z-index works */
        }
        .text-color-input {
            height: 38px; /* Match height of select/slider */
            padding: 0.25rem;
            width: 80px; /* Adjust width for color picker */
        }
        .text-size-input {
            width: 100px;
        }
        .text-input, .font-url-input, .time-input, .margin-input {
            background-color: #4a5568;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            width: 100%;
            max-width: 250px;
        }
        .time-input {
            width: 60px; /* Smaller width for time inputs */
            text-align: center;
        }
        .margin-input {
            width: 70px; /* Smaller width for margin inputs */
            text-align: center;
        }
        .transform-slider {
            width: 100px;
        }
        .seek-slider {
            width: 100%; /* Make seek slider full width */
            margin-top: 1rem;
        }
        .time-display {
            font-size: 0.9rem;
            color: #a0aec0;
            margin-top: 0.5rem;
            width: 100%;
            text-align: center;
        }
        .image-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 0.5rem;
            object-fit: contain;
            border: 2px solid #4a5568;
            display: none; /* Hidden by default */
        }
        .message-box {
            background-color: #38a169; /* Green for success */
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            text-align: center;
            display: none; /* Hidden by default */
            width: 100%;
        }
        .message-box.error {
            background-color: #e53e3e; /* Red for error */
        }
        .message-box.info {
            background-color: #4299e1; /* Blue for info */
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .visualizer-checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        /* Initial hidden state for controls */
        .controls-hidden {
            display: none !important;
        }

        /* Modal Overlay Styles */
        #accessModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top of everything */
        }

        /* Modal Content Styles */
        #accessControl {
            background-color: #2d3748; /* Same as controls-panel background */
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            padding: 2.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 90%;
            max-width: 400px; /* Fixed width for the modal content */
            text-align: center;
        }

        /* Responsive adjustments for small screens */
        @media (max-width: 1024px) {
            .main-wrapper {
                flex-direction: column; /* Stack vertically on smaller screens */
                align-items: center; /* Center items when stacked */
                gap: 1rem;
            }
            .controls-panel, .visualizer-area {
                max-width: 95%; /* Allow both to be wider on mobile */
                max-height: none; /* Remove max height when stacked */
                overflow-y: visible; /* Allow content to push height */
            }
            body {
                padding: 1rem; /* Reduce padding for mobile */
            }
        }
        /* Styling for individual text layer controls */
        .text-layer-controls {
            background-color: #3a475a; /* Slightly different background for clarity */
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .text-layer-controls .flex {
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .text-layer-controls .btn-remove {
            background-color: #e53e3e;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-self: flex-end; /* Align remove button to the right */
        }
        /* Styling for individual image layer controls */
        .image-layer-controls {
            background-color: #3a475a; /* Same as text layer for consistency */
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .image-layer-controls .flex {
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .image-layer-controls .btn-remove {
            background-color: #e53e3e;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-self: flex-end;
        }
        .image-layer-controls .image-file-input {
            width: 100%; /* Ensure file input wrapper takes full width */
        }
        .image-layer-controls .image-preview-thumbnail {
            max-width: 100px;
            max-height: 100px;
            border-radius: 0.25rem;
            object-fit: contain;
            border: 1px solid #4a5568;
            margin-top: 0.5rem;
            display: block;
        }
        /* Styling for individual video layer controls */
        .video-layer-controls {
            background-color: #3a475a;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .video-layer-controls .flex {
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .video-layer-controls .btn-remove {
            background-color: #e53e3e;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            align-self: flex-end;
        }
        .video-layer-controls .video-file-input {
            width: 100%;
        }
        .video-layer-controls .video-preview-thumbnail {
            max-width: 100px;
            max-height: 100px;
            border-radius: 0.25rem;
            object-fit: contain;
            border: 1px solid #4a5568;
            margin-top: 0.5rem;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Access Control Modal Overlay -->
    <div id="accessModalOverlay">
        <div id="accessControl" class="w-full flex flex-col items-center gap-4">
            <p class="text-lg text-center">សូមបញ្ចូលលេខសម្គាល់ដើម្បីបន្ត</p>
            <input type="password" id="secretIdInput" class="text-input" placeholder="បញ្ចូលលេខសម្គាត់...">
            <button id="verifyIdBtn" class="btn">ផ្ទៀងផ្ទាត់</button>
            <div id="messageBox" class="message-box"></div> <!-- Message box inside modal -->
        </div>
    </div>

    <div class="main-wrapper">
        <div class="visualizer-area">
            <img id="imagePreview" class="image-preview" alt="រូបភាពដែលបានជ្រើសរើស">

            <div id="canvasContainer" class="canvas-container aspect-ratio-16-9">
                <canvas id="visualizerCanvas"></canvas>
            </div>

            <div class="controls mt-4">
                <div class="flex flex-col sm:flex-row justify-center items-center gap-4">
                    <div class="control-group">
                        <label for="outputQualitySelect" class="text-sm">គុណភាពវីដេអូថតចេញ:</label>
                        <select id="outputQualitySelect" class="recording-quality-select">
                            <option value="current">បច្ចុប្បន្ន (តាមទំហំបង្ហាញ)</option>
                            <option value="640x480">SD (640x480)</option>
                            <option value="1280x720">HD (1280x720)</option>
                            <option value="1920x1080">Full HD (1920x1080)</option>
                            <option value="1080x1920">Vertical HD (1080x1920)</option>
                            <option value="1080x1080">Square HD (1080x1080)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="recordingFpsInput" class="text-sm">FPS វីដេអូថត:</label>
                        <input type="number" id="recordingFpsInput" min="1" max="60" value="30" class="time-input">
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                    <button id="fullscreenBtn" class="btn">ពេញអេក្រង់</button>
                    <button id="startRecordBtn" class="btn btn-red">ចាប់ផ្តើមថត</button>
                    <button id="stopRecordBtn" class="btn btn-green" disabled>បញ្ឈប់ការថត</button>
                    <a id="downloadVideoLink" class="btn hidden" download="visualizer_video.webm">ទាញយកវីដេអូ</a>
                </div>
                <div class="checkbox-group mt-2">
                    <input type="checkbox" id="recordWithoutFilterCheckbox">
                    <label for="recordWithoutFilterCheckbox" class="text-sm">ថតដោយគ្មានតម្រងរូបភាព</label>
                </div>
            </div>
        </div>
        <!-- Controls Panel moved here -->
        <div class="controls-panel">
            <h1 class="text-3xl font-bold text-center mb-4">កម្មវិធីចាក់តន្ត្រី និងបង្ហាញរូបភាពតាមចង្វាក់</h1>

            <!-- All other controls, initially hidden -->
            <div id="appControls" class="w-full flex flex-col items-center gap-1.5 controls-hidden">
                <div class="controls">
                    <div class="file-input-wrapper">
                        <button class="btn">ជ្រើសរើសឯកសារតន្ត្រី</button>
                        <input type="file" id="audioFile" accept="audio/*">
                    </div>
                    <div class="control-group">
                        <label for="aspectRatioSelect" class="text-sm">ទំហំបង្ហាញ:</label>
                        <select id="aspectRatioSelect" class="aspect-ratio-select">
                            <option value="16-9">YouTube (16:9)</option>
                            <option value="9-16">TikTok/Reels (9:16)</option>
                            <option value="1-1">Instagram (1:1)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="text-sm">ប្រភេទចលនា:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមប្រភេទចលនា</summary>
                            <div id="visualizerTypeControls" class="visualizer-checkbox-group mt-2">
                                <label><input type="checkbox" class="visualizer-checkbox" value="bars"> របារប្រេកង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="circle-pulse"> រង្វង់លោត</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="wave"> រលក</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="radial-bars"> របាររង្វង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="particle-swarm"> ហ្វូងភាគល្អិត</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="line-spectrum"> បន្ទាត់វិសាលគម</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="frequency-circle"> រង្វង់ប្រេកង់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="falling-particles"> ភាគល្អិតធ្លាក់</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="rising-particles"> ភាគល្អិតឡើងលើ</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="leftward-particles"> ភាគល្អិតទៅឆ្វេង</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="rightward-particles"> ភាគល្អិតទៅស្តាំ</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="colorful-particles"> ភាគល្អិតចម្រុះពណ៌</label>
                                <label><input type="checkbox" class="visualizer-checkbox" value="connecting-lines"> បន្ទាត់តភ្ជាប់</label>
                            </div>
                        </details>
                    </div>
                    <div class="control-group">
                        <label for="visualizerIntensitySlider" class="text-sm">កម្រិតចលនា:</label>
                        <input type="range" id="visualizerIntensitySlider" min="0.0" max="2.0" step="0.1" value="1.0" class="visualizer-intensity-slider">
                    </div>
                </div>

                <div class="w-full flex flex-col items-center">
                    <!-- Audio player controls moved here -->
                    <div class="flex flex-wrap justify-center gap-2 mb-2">
                        <button id="playPauseBtn" class="btn">ចាក់/ផ្អាក</button>
                        <div class="control-group">
                            <label for="volumeSlider" class="text-sm">កម្រិតសំឡេង:</label>
                            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.7" class="volume-slider">
                        </div>
                    </div>
                    <input type="range" id="seekSlider" min="0" max="0" value="0" step="0.01" class="seek-slider">
                    <div id="timeDisplay" class="time-display">0:00 / 0:00</div>
                </div>

                <div class="controls mt-4">
                    <div class="control-group">
                        <label for="backgroundFile" class="text-sm">ផ្ទៃខាងក្រោយ:</label>
                        <input type="file" id="backgroundFile" accept="image/*">
                        <div class="checkbox-group">
                            <input type="checkbox" id="autoBackgroundSizeCheckbox" checked>
                            <label for="autoBackgroundSizeCheckbox" class="text-sm">ស្វ័យប្រវត្តិ</label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="backgroundSizeSlider" class="text-sm">ទំហំផ្ទៃខាងក្រោយ:</label>
                        <input type="range" id="backgroundSizeSlider" min="0.1" max="2.0" step="0.05" value="1.0" class="background-size-slider">
                    </div>
                    <div class="control-group">
                        <label for="backgroundAlignmentSelect" class="text-sm">ទីតាំងផ្ទៃខាងក្រោយ:</label>
                        <select id="backgroundAlignmentSelect" class="background-alignment-select">
                            <option value="center">កណ្តាល</option>
                            <option value="top-left">លើ-ឆ្វេង</option>
                            <option value="top-center">លើ-កណ្តាល</option>
                            <option value="top-right">លើ-ស្តាំ</option>
                            <option value="center-left">កណ្តាល-ឆ្វេង</option>
                            <option value="center-right">កណ្តាល-ស្តាំ</option>
                            <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                            <option value="bottom-center">ក្រោម-កណ្តាល</option>
                            <option value="bottom-right">ក្រោម-ស្តាំ</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="backgroundMotionTypeSelect" class="text-sm">ចលនាផ្ទៃខាងក្រោយ:</label>
                        <select id="backgroundMotionTypeSelect" class="background-motion-type-select">
                            <option value="none">គ្មាន</option>
                            <option value="zoom">ពង្រីក/បង្រួម</option>
                            <option value="pan-horizontal">រំកិលផ្ដេក</option>
                            <option value="pan-vertical">រំកិលបញ្ឈរ</option>
                            <option value="rotate">បង្វិល</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="backgroundMotionSpeedSlider" class="text-sm">ល្បឿនចលនាផ្ទៃខាងក្រោយ:</label>
                        <input type="range" id="backgroundMotionSpeedSlider" min="0.0" max="1.0" step="0.05" value="0.5" class="background-motion-speed-slider">
                    </div>
                    <div class="control-group">
                        <label for="canvasFilterSelect" class="text-sm">តម្រងរូបភាព:</label>
                        <select id="canvasFilterSelect" class="canvas-filter-select">
                            <option value="none">គ្មាន</option>
                            <option value="grayscale(100%)">សខ្មៅ</option>
                            <option value="sepia(100%)">សេពៀ</option>
                            <option value="invert(100%)">បញ្ច្រាសពណ៌</option>
                            <option value="blur(5px)">ព្រិល</option>
                        </select>
                    </div>
                    
                    <!-- Image Layers Container -->
                    <div class="control-group w-full">
                        <label class="text-sm">គ្រប់គ្រងរូបភាព:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមគ្រប់គ្រងរូបភាព</summary>
                            <div id="imageLayersContainer" class="w-full mt-2">
                                <!-- Image input templates will be added here by JS -->
                            </div>
                            <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                                <button id="addImageLayerBtn" class="btn">បន្ថែមរូបភាពថ្មី</button>
                            </div>
                        </details>
                    </div>

                    <!-- Video Layers Container -->
                    <div class="control-group w-full">
                        <label class="text-sm">គ្រប់គ្រងវីដេអូ:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមគ្រប់គ្រងវីដេអូ</summary>
                            <div id="videoLayersContainer" class="w-full mt-2">
                                <!-- Video input templates will be added here by JS -->
                            </div>
                            <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                                <button id="addVideoLayerBtn" class="btn">បន្ថែមវីដេអូថ្មី</button>
                            </div>
                        </details>
                    </div>

                    <!-- Text Layers Container -->
                    <div class="control-group w-full">
                        <label class="text-sm">គ្រប់គ្រងអត្ថបទ:</label>
                        <details class="w-full bg-gray-700 rounded-lg p-3">
                            <summary class="cursor-pointer text-white font-bold">ពង្រីក/បង្រួមគ្រប់គ្រងអត្ថបទ</summary>
                            <div id="textLayersContainer" class="w-full mt-2">
                                <!-- Text input templates will be added here by JS -->
                            </div>
                            <div class="flex flex-col sm:flex-row justify-center gap-2 mt-4">
                                <button id="addTextLayerBtn" class="btn">បន្ថែមអត្ថបទថ្មី</button>
                                <button id="addSubtitleLayerBtn" class="btn">បន្ថែម Subtitle ថ្មី</button>
                            </div>
                        </details>
                    </div>

                    <div class="control-group">
                        <label for="logoFile" class="text-sm">Logo:</label>
                        <input type="file" id="logoFile" accept="image/*">
                    </div>
                    <div class="control-group">
                        <label for="logoPositionSelect" class="text-sm">ទីតាំង Logo:</label>
                        <select id="logoPositionSelect" class="logo-position-select">
                            <option value="top-left">លើ-ឆ្វេង</option>
                            <option value="top-right">លើ-ស្តាំ</option>
                            <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                            <option value="bottom-right">ក្រោម-ស្តាំ</option>
                            <option value="center">កណ្តាល</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="logoSizeSlider" class="text-sm">ទំហំ Logo:</label>
                        <input type="range" id="logoSizeSlider" min="10" max="200" step="5" value="50" class="logo-size-slider">
                        <div class="checkbox-group">
                            <input type="checkbox" id="autoLogoSizeCheckbox" checked>
                            <label for="autoLogoSizeCheckbox" class="text-sm">ស្វ័យប្រវត្តិ</label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="fontUrlInput" class="text-sm">ផ្ទុក Font ពី URL (Google Fonts):</label>
                        <input type="text" id="fontUrlInput" class="font-url-input" placeholder="ឧ. https://fonts.googleapis.com/css2?family=Noto+Sans+Khmer&display=swap">
                        <button id="loadFontUrlBtn" class="btn">ផ្ទុក Font URL</button>
                    </div>
                    <div class="control-group">
                        <label for="fontFileInput" class="text-sm">ផ្ទុក Font ពីឧបករណ៍ (.ttf, .otf, .woff):</label>
                        <input type="file" id="fontFileInput" accept=".ttf,.otf,.woff,.woff2">
                        <input type="text" id="customFontNameInput" class="text-input" placeholder="ឈ្មោះ Font (ឧ. MyCustomFont)">
                        <button id="loadFontFileBtn" class="btn">ផ្ទុក Font ឯកសារ</button>
                    </div>
                    <div class="control-group">
                        <label class="text-sm">ជ្រើសរើស Font:</label>
                        <select id="fontSelect" class="font-select">
                            <!-- Options will be populated by JS -->
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer" controls class="hidden"></audio>

    <!-- Hidden Text Layer Template -->
    <template id="textLayerTemplate">
        <div class="text-layer-controls">
            <button class="btn btn-red btn-remove">លុប</button>
            <button class="btn btn-copy">ចម្លង</button> <!-- New Copy button -->
            <textarea class="text-input" rows="2" placeholder="បញ្ចូលអត្ថបទ..."></textarea>
            <div class="flex">
                <input type="color" value="#ffffff" class="text-color-input">
                <input type="number" min="10" max="100" value="30" class="text-size-input">
                <select class="text-position-select">
                    <option value="bottom-center">ក្រោម-កណ្តាល</option>
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វ្វេង</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                    <option value="center">កណ្តាល</option>
                </select>
            </div>
            <div class="checkbox-group">
                <label><input type="checkbox" class="text-bold-checkbox"> អក្សរដិត</label>
                <label><input type="checkbox" class="text-shadow-checkbox"> ស្រមោលអក្សរ</label>
                <label><input type="checkbox" class="text-blur-checkbox"> អក្សរព្រាល</label>
            </div>
            <div class="control-group">
                <label class="text-sm">ចលនាអត្ថបទ:</label>
                <select class="text-animation-type-select">
                    <option value="none">គ្មាន</option>
                    <option value="pulse">លោតតាមភ្លេង</option>
                    <option value="fade">ព្រាលតាមភ្លេង</option>
                    <option value="slide-horizontal">រំកិលផ្ដេកតាមភ្លេង</option>
                    <option value="slide-vertical">រំកិលបញ្ឈរតាមភ្លេង</option>
                </select>
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលចាប់ផ្តើម:</label>
                <input type="number" min="0" value="0" class="time-input text-start-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input text-start-sec">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលបញ្ចប់:</label>
                <input type="number" min="0" value="0" class="time-input text-end-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input text-end-sec">
            </div>
            <div class="control-group">
                <label class="text-sm">ពណ៌គ្រោង:</label>
                <input type="color" value="#000000" class="text-outline-color-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ទទឹងគ្រោង:</label>
                <input type="number" min="0" max="10" step="0.5" value="0" class="transform-slider text-outline-width-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ពណ៌ស្រមោល:</label>
                <input type="color" value="#000000" class="text-shadow-color-input">
            </div>
            <div class="control-group">
                <label class="text-sm">កម្រិតព្រាលស្រមោល:</label>
                <input type="number" min="0" max="20" step="1" value="2" class="transform-slider text-shadow-blur-input">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">រឹមឆ្វេង:</label>
                <input type="number" value="0" class="margin-input text-margin-left-input">
                <label class="text-sm">រឹមស្តាំ:</label>
                <input type="number" value="0" class="margin-input text-margin-right-input">
            </div>
            <div class="control-group">
                <label class="text-sm">រឹមបញ្ឈរ:</label>
                <input type="number" value="0" class="margin-input text-margin-vertical-input">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">មាត្រដ្ឋាន X:</label>
                <input type="number" min="0.1" max="5.0" step="0.1" value="1.0" class="transform-slider text-scale-x-input">
                <label class="text-sm">មាត្រដ្ឋាន Y:</label>
                <input type="number" min="0.1" max="5.0" step="0.1" value="1.0" class="transform-slider text-scale-y-input">
            </div>
            <div class="control-group">
                <label class="text-sm">បង្វិល (ដឺក្រេ):</label>
                <input type="number" min="-180" max="180" value="0" class="transform-slider text-rotation-input">
            </div>
            <div class="control-group">
                <label class="text-sm">គម្លាតអក្សរ:</label>
                <input type="number" min="-10" max="20" step="0.5" value="0" class="transform-slider text-spacing-input">
            </div>
            <div class="control-group">
                <label class="text-sm">ជ្រើសរើស Font:</label>
                <select class="font-select">
                    <!-- Options will be populated by JS -->
                </select>
            </div>
        </div>
    </template>

    <!-- Hidden Image Layer Template -->
    <template id="imageLayerTemplate">
        <div class="image-layer-controls">
            <button class="btn btn-red btn-remove">លុប</button>
            <button class="btn btn-copy-image">ចម្លង</button> <!-- New Copy button for images -->
            <div class="file-input-wrapper">
                <button class="btn">ជ្រើសរើសរូបភាព</button>
                <input type="file" accept="image/*" class="image-file-input">
            </div>
            <img class="image-preview-thumbnail" alt="រូបភាពតូច">
            <div class="control-group">
                <label class="text-sm">ទំហំរូបភាព:</label>
                <input type="range" min="0.1" max="2.0" step="0.05" value="1.0" class="image-size-slider">
                <div class="checkbox-group">
                    <input type="checkbox" checked class="auto-image-size-checkbox">
                    <label class="text-sm">ស្វ័យប្រវត្តិ</label>
                </div>
            </div>
            <div class="control-group">
                <label class="text-sm">ទីតាំងរូបភាព:</label>
                <select class="image-position-select">
                    <option value="center">កណ្តាល</option>
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-center">លើ-កណ្តាល</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="center-left">កណ្តាល-ឆ្វេង</option>
                    <option value="center-right">កណ្តាល-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                    <option value="bottom-center">ក្រោម-កណ្តាល</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                </select>
            </div>
            <div class="checkbox-group">
                <label><input type="checkbox" class="image-pulse-checkbox"> ចលនាលោតរូបភាព</label>
            </div>
            <div class="control-group">
                <label class="text-sm">អនុវត្តចលនា Visualizer លើរូបភាពនេះ:</label>
                <input type="checkbox" class="apply-visualizer-to-image-checkbox">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលចាប់ផ្តើម:</label>
                <input type="number" min="0" value="0" class="time-input image-start-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input image-start-sec">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលបញ្ចប់:</label>
                <input type="number" min="0" value="0" class="time-input image-end-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input image-end-sec">
            </div>
        </div>
    </template>

    <!-- Hidden Video Layer Template -->
    <template id="videoLayerTemplate">
        <div class="video-layer-controls">
            <button class="btn btn-red btn-remove">លុប</button>
            <button class="btn btn-copy-video">ចម្លង</button> <!-- Copy button for videos -->
            <div class="file-input-wrapper">
                <button class="btn">ជ្រើសរើសវីដេអូ</button>
                <input type="file" accept="video/*" class="video-file-input">
            </div>
            <video class="video-preview-thumbnail" muted autoplay loop></video> <!-- Autoplay/loop for preview -->
            <div class="control-group">
                <label class="text-sm">ទំហំវីដេអូ:</label>
                <input type="range" min="0.1" max="2.0" step="0.05" value="1.0" class="video-size-slider">
                <div class="checkbox-group">
                    <input type="checkbox" checked class="auto-video-size-checkbox">
                    <label class="text-sm">ស្វ័យប្រវត្តិ</label>
                </div>
            </div>
            <div class="control-group">
                <label class="text-sm">ទីតាំងវីដេអូ:</label>
                <select class="video-position-select">
                    <option value="center">កណ្តាល</option>
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-center">លើ-កណ្តាល</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="center-left">កណ្តាល-ឆ្វេង</option>
                    <option value="center-right">កណ្តាល-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                    <option value="bottom-center">ក្រោម-កណ្តាល</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                </select>
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលចាប់ផ្តើម:</label>
                <input type="number" min="0" value="0" class="time-input video-start-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input video-start-sec">
            </div>
            <div class="flex items-center justify-between gap-2">
                <label class="text-sm">ពេលបញ្ចប់:</label>
                <input type="number" min="0" value="0" class="time-input video-end-min"><span>:</span><input type="number" min="0" max="59" value="0" class="time-input video-end-sec">
            </div>
        </div>
    </template>

    <script>
        // --- Security Measures (Client-Side Only) ---
        // Disable right-click context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            // No redirect here, just prevent default
        });

        // Disable F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C, Ctrl+U
        document.addEventListener('keydown', function(e) {
            // F12 key
            if (e.key === 'F12') {
                e.preventDefault();
            }

            // Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C (Developer Tools shortcuts)
            if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) {
                e.preventDefault();
            }

            // Ctrl+U (View Page Source)
            if (e.ctrlKey && e.key === 'u') {
                e.preventDefault();
            }
        });

        // This attempts to handle view-source: but is not foolproof as browser behavior varies.
        // It's client-side JS, so if someone types view-source: in the URL bar, the JS might not even run.
        // The primary defense is the keydown and contextmenu listeners.
        // Removed redirect for view-source as it causes issues with local files.

        // --- End Security Measures ---


        // Get DOM elements
        const audioFile = document.getElementById('audioFile');
        const backgroundFile = document.getElementById('backgroundFile');
        const logoFile = document.getElementById('logoFile');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const audioPlayer = document.getElementById('audioPlayer');
        const visualizerCanvas = document.getElementById('visualizerCanvas');
        const messageBox = document.getElementById('messageBox');
        const aspectRatioSelect = document.getElementById('aspectRatioSelect');
        const outputQualitySelect = document.getElementById('outputQualitySelect'); // Renamed and moved
        const recordingFpsInput = document.getElementById('recordingFpsInput'); // New FPS input
        const canvasContainer = document.getElementById('canvasContainer');
        const startRecordBtn = document.getElementById('startRecordBtn');
        const stopRecordBtn = document.getElementById('stopRecordBtn');
        const downloadVideoLink = document.getElementById('downloadVideoLink');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const visualizerTypeControls = document.getElementById('visualizerTypeControls'); // Changed to div
        const visualizerCheckboxes = document.querySelectorAll('.visualizer-checkbox'); // Get all checkboxes
        const visualizerIntensitySlider = document.getElementById('visualizerIntensitySlider');
        const seekSlider = document.getElementById('seekSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const autoBackgroundSizeCheckbox = document.getElementById('autoBackgroundSizeCheckbox');
        const canvasFilterSelect = document.getElementById('canvasFilterSelect');
        const backgroundSizeSlider = document.getElementById('backgroundSizeSlider');
        const logoPositionSelect = document.getElementById('logoPositionSelect');
        const backgroundMotionTypeSelect = document.getElementById('backgroundMotionTypeSelect');
        const backgroundMotionSpeedSlider = document.getElementById('backgroundMotionSpeedSlider');
        const fontUrlInput = document.getElementById('fontUrlInput');
        const loadFontUrlBtn = document.getElementById('loadFontUrlBtn');
        const fontFileInput = document.getElementById('fontFileInput');
        const customFontNameInput = document.getElementById('customFontNameInput');
        const loadFontFileBtn = document.getElementById('loadFontFileBtn');
        const fontSelect = document.getElementById('fontSelect'); // Global font select
        const logoSizeSlider = document.getElementById('logoSizeSlider'); // New logo size slider
        const autoLogoSizeCheckbox = document.getElementById('autoLogoSizeCheckbox'); // New auto logo size checkbox
        const recordWithoutFilterCheckbox = document.getElementById('recordWithoutFilterCheckbox'); // New record without filter checkbox

        // Access Control Elements
        const accessModalOverlay = document.getElementById('accessModalOverlay'); // New: Modal overlay
        const secretIdInput = document.getElementById('secretIdInput');
        const verifyIdBtn = document.getElementById('verifyIdBtn');
        const appControlsDiv = document.getElementById('appControls');

        // Text Layer Management Elements
        const textLayersContainer = document.getElementById('textLayersContainer');
        const addTextLayerBtn = document.getElementById('addTextLayerBtn');
        const addSubtitleLayerBtn = document.getElementById('addSubtitleLayerBtn'); // New subtitle button
        const textLayerTemplate = document.getElementById('textLayerTemplate');

        // Image Layer Management Elements
        const imageLayersContainer = document.getElementById('imageLayersContainer'); // New container for image layers
        const addImageLayerBtn = document.getElementById('addImageLayerBtn'); // New add image button
        const imageLayerTemplate = document.getElementById('imageLayerTemplate'); // New image layer template

        // Video Layer Management Elements
        const videoLayersContainer = document.getElementById('videoLayersContainer'); // New container for video layers
        const addVideoLayerBtn = document.getElementById('addVideoLayerBtn'); // New add video button
        const videoLayerTemplate = document.getElementById('videoLayerTemplate'); // New video layer template

        // New background alignment select
        const backgroundAlignmentSelect = document.getElementById('backgroundAlignmentSelect');

        // Global variable to track if recordingQualitySelect is changing aspectRatioSelect to prevent loop
        let isSettingAspectRatioByQuality = false;

        // Canvas for offscreen rendering during recording
        const recordingCanvas = document.createElement('canvas');
        const recordingCtx = recordingCanvas.getContext('2d');

        // Canvas context for display
        const ctx = visualizerCanvas.getContext('2d');

        // Audio context and analyser
        let audioContext;
        let analyser;
        let source;
        let gainNode; // New: GainNode for audio routing
        let bufferLength;
        let dataArray;
        let animationFrameId;
        let audioDestinationNode;

        // Image objects
        let bgImg = new Image();
        let isBgImageLoaded = false;
        let logoImg = new Image();
        let isLogoLoaded = false;

        // Media Recorder variables
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        // Global variable for background pan/rotate animation
        let backgroundPanOffset = { x: 0, y: 0 };
        let backgroundRotation = 0;
        let lastFrameTime = 0;

        // Global array to store the order of selected visualizers
        let activeVisualizerOrder = []; // Stores objects like { type: 'bars', timestamp: Date.now() }

        // Particle Class (generic for all particle visualizers)
        class Particle {
            constructor(x, y, size, color, speedX = 0, speedY = 0) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.speedX = speedX;
                this.speedY = speedY;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // Separate particle arrays for each particle visualizer type
        const maxParticlesPerVisualizer = 100;
        let fallingParticles = [];
        let risingParticles = [];
        let leftwardParticles = [];
        let rightwardParticles = [];
        let colorfulParticles = []; // These will be falling particles with dynamic colors

        // Array to hold all text layer objects
        let textLayers = [];
        // Array to hold all image layer objects
        let imageLayers = [];
        // Array to hold all video layer objects
        let videoLayers = [];


        // Predefined list of fonts for the dropdowns
        const defaultFontOptions = [
            { value: 'Inter, sans-serif', text: 'Inter (លំនាំដើម)' },
            { value: 'Arial, sans-serif', text: 'Arial' },
            { value: 'Verdana, sans-serif', text: 'Verdana' },
            { value: 'Times New Roman, serif', text: 'Times New Roman' },
            { value: 'Noto Sans Khmer', text: 'Noto Sans Khmer' },
            { value: 'Battambang', text: 'Battambang' },
            { value: 'Bayon', text: 'Bayon' },
            { value: 'Freehand', text: 'Freehand' },
            { value: 'Kdam Thmor', text: 'Kdam Thmor' },
            { value: 'Moul', text: 'Moul' },
            { value: 'Preahvihear', text: 'Preahvihear' }
        ];


        // Helper to initialize particles for a given array
        function initializeParticleArray(arr, canvasWidth, canvasHeight, baseColor) {
            if (arr.length === 0) {
                for (let i = 0; i < maxParticlesPerVisualizer; i++) {
                    const particleColor = baseColor || `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`; // Explicitly define color
                    arr.push(new Particle(Math.random() * canvasWidth, Math.random() * canvasHeight, Math.random() * 3 + 1, particleColor));
                }
            }
        }

        // Function to format time (e.g., 150 seconds -> 2:30)
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        // Function to show messages
        function showMessage(message, isError = false, isInfo = false) {
            // Use the messageBox within the modal for access control messages
            const targetMessageBox = accessModalOverlay.classList.contains('controls-hidden') ? messageBox : accessModalOverlay.querySelector('#messageBox');
            
            targetMessageBox.textContent = message;
            targetMessageBox.className = 'message-box'; // Reset classes
            if (isError) {
                targetMessageBox.classList.add('error');
            } else if (isInfo) {
                targetMessageBox.classList.add('info');
            } else {
                targetMessageBox.classList.add('success'); // Default for success
            }
            targetMessageBox.style.display = 'block';
            setTimeout(() => {
                targetMessageBox.style.display = 'none';
            }, 3000); // Hide after 3 seconds
        }

        // Initialize AudioContext when user interacts
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256; // Fast Fourier Transform size
                bufferLength = analyser.frequencyBinCount; // Number of data points
                dataArray = new Uint8Array(bufferLength); // Array to hold frequency data

                source = audioContext.createMediaElementSource(audioPlayer);
                gainNode = audioContext.createGain(); // Create a gain node
                source.connect(gainNode); // Connect source to gain node
                gainNode.connect(analyser); // Connect gain node to analyser
                analyser.connect(audioContext.destination); // Connect analyser to speakers
            }
        }

        // Function to load font from URL (e.g., Google Fonts)
        async function loadFontFromUrl(url) {
            if (!url) {
                showMessage('សូមបញ្ចូល URL Font ឱ្យបានត្រឹមត្រូវ។', true);
                return;
            }
            try {
                // Check if the font is already loaded or being loaded
                const existingLink = document.querySelector(`link[href="${url}"]`);
                if (existingLink) {
                    showMessage('Font នេះត្រូវបានផ្ទុកពីមុនមកហើយ។', false, true);
                    return;
                }

                const link = document.createElement('link');
                link.href = url;
                link.rel = 'stylesheet';
                document.head.appendChild(link);

                // Attempt to get font family name from Google Fonts URL
                const match = url.match(/family=([^&:]+)/);
                let fontName = 'Unknown Font';
                if (match && match[1]) {
                    fontName = decodeURIComponent(match[1].replace(/\+/g, ' '));
                }

                // Wait for the font to be loaded
                await document.fonts.load(`1em "${fontName}"`);
                // Add to global font options and update all existing font selects
                addFontToAllSelects(fontName, fontName);
                showMessage(`Font "${fontName}" ត្រូវបានផ្ទុកដោយជោគជ័យពី URL។`);
                drawVisualizer(); // Redraw with new font
            } catch (error) {
                showMessage(`បរាជ័យក្នុងការផ្ទុក Font ពី URL: ${error.message}`, true);
                console.error('Font loading error:', error);
            }
        }

        // Function to load font from local file
        async function loadFontFromFile(file, fontName) {
            if (!file) {
                showMessage('សូមជ្រើសរើសឯកសារ Font។', true);
                return;
            }
            if (!fontName || fontName.trim() === '') {
                showMessage('សូមបញ្ចូលឈ្មោះសម្រាប់ Font ផ្ទាល់ខ្លួន។', true);
                return;
            }
            try {
                const font = new FontFace(fontName, `url(${URL.createObjectURL(file)})`);
                await font.load();
                document.fonts.add(font);
                // Add to global font options and update all existing font selects
                addFontToAllSelects(fontName, fontName);
                showMessage(`Font "${fontName}" ត្រូវបានផ្ទុកដោយជោគជោគជ័យពីឯកសារ។`);
                drawVisualizer(); // Redraw with new font
            } catch (error) {
                showMessage(`បរាជ័យក្នុងការផ្ទុក Font ពីឯកសារ: ${error.message}`, true);
                console.error('Font loading error:', error);
            }
        }

        // Helper function to add a font option to all font select dropdowns
        function addFontToAllSelects(value, text) {
            const fontSelects = document.querySelectorAll('.font-select');
            fontSelects.forEach(select => {
                // Check if option already exists to prevent duplicates
                if (!Array.from(select.options).some(option => option.value === value)) {
                    const newOption = new Option(text, value);
                    select.add(newOption);
                }
            });
        }


        // Handle audio file selection
        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                audioPlayer.src = fileURL;
                audioPlayer.load(); // Load the audio
                showMessage(`ឯកសារតន្ត្រី "${file.name}" ត្រូវបានផ្ទុក។`);
                initAudioContext(); // Initialize audio context on file load
                playPauseBtn.textContent = 'ចាក់'; // Reset button text
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        // Ensure visualizer starts only after audio context resumes
                        drawVisualizer();
                    });
                } else {
                    drawVisualizer();
                }
                downloadVideoLink.classList.add('hidden'); // Hide download link on new audio
            } else {
                showMessage('សូមជ្រើសរើសឯកសារតន្ត្រី។', true);
            }
        });

        // Update seek slider max and time display when audio metadata is loaded
        audioPlayer.addEventListener('loadedmetadata', () => {
            seekSlider.max = audioPlayer.duration;
            timeDisplay.textContent = `0:00 / ${formatTime(audioPlayer.duration)}`;
        });

        // Update seek slider and time display as audio plays
        audioPlayer.addEventListener('timeupdate', () => {
            if (!seekSlider.dragging) { // Only update if user isn't dragging the slider
                seekSlider.value = audioPlayer.currentTime;
            }
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
        });

        // Seek slider functionality
        seekSlider.addEventListener('input', () => {
            audioPlayer.currentTime = seekSlider.value;
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
        });

        // Handle background file selection
        backgroundFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    bgImg.src = e.target.result;
                    bgImg.onload = () => {
                        isBgImageLoaded = true;
                        showMessage(`រូបភាពផ្ទៃខាងក្រោយ "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer(); // Redraw canvas with new background
                    };
                    bgImg.onerror = () => {
                        isBgImageLoaded = false;
                        showMessage('មិនអាចផ្ទុករូបភាពផ្ទៃខាងក្រោយបានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសរូបភាពផ្ទៃខាងក្រោយ។', true);
            }
        });

        // Handle logo file selection
        logoFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    logoImg.src = e.target.result;
                    logoImg.onload = () => {
                        isLogoLoaded = true;
                        showMessage(`ឯកសារ Logo "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer(); // Redraw canvas with new logo
                    };
                    logoImg.onerror = () => {
                        isLogoLoaded = false;
                        showMessage('មិនអាចផ្ទុក Logo បានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Logo។', true);
            }
        });

        // Play/Pause button functionality
        playPauseBtn.addEventListener('click', () => {
            if (!audioPlayer.src) {
                showMessage('សូមផ្ទុកឯកសារតន្ត្រីជាមុនសិន។', true);
                return;
            }

            initAudioContext(); // Ensure context is initialized and resumed

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    if (audioPlayer.paused) {
                        audioPlayer.play();
                        playPauseBtn.textContent = 'ផ្អាក';
                        drawVisualizer(); // Start visualization
                    } else {
                        audioPlayer.pause();
                        playPauseBtn.textContent = 'ចាក់';
                        cancelAnimationFrame(animationFrameId); // Stop visualization
                    }
                }).catch(e => showMessage(`បរាជ័យក្នុងការបន្ត AudioContext: ${e.message}`, true));
            } else {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                    playPauseBtn.textContent = 'ផ្អាក';
                    drawVisualizer(); // Start visualization
                } else {
                    audioPlayer.pause();
                    playPauseBtn.textContent = 'ចាក់';
                    cancelAnimationFrame(animationFrameId); // Stop visualization
                }
            }
        });

        // Volume control
        volumeSlider.addEventListener('input', () => {
            audioPlayer.volume = volumeSlider.value;
        });

        // Background Size control
        backgroundSizeSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new background size
        });

        // Auto Background Size checkbox control
        autoBackgroundSizeCheckbox.addEventListener('change', () => {
            backgroundSizeSlider.disabled = autoBackgroundSizeCheckbox.checked;
            drawVisualizer(); // Redraw canvas with new background sizing mode
        });

        // Background Alignment control
        backgroundAlignmentSelect.addEventListener('change', () => {
            drawVisualizer(); // Redraw canvas with new background alignment
            showMessage(`ទីតាំងផ្ទៃខាងក្រោយត្រូវបានផ្លាស់ប្តូរទៅជា "${backgroundAlignmentSelect.options[backgroundAlignmentSelect.selectedIndex].text}"។`, false, true);
        });

        // Background Motion Type control
        backgroundMotionTypeSelect.addEventListener('change', () => {
            // Reset motion state when type changes
            backgroundPanOffset = { x: 0, y: 0 };
            backgroundRotation = 0;
            drawVisualizer(); // Redraw canvas with new motion type
            showMessage(`ចលនាផ្ទៃខាងក្រោយត្រូវបានផ្លាស់ប្តូរទៅជា "${backgroundMotionTypeSelect.options[backgroundMotionTypeSelect.selectedIndex].text}"។`, false, true);
        });

        // Background Motion Speed control
        backgroundMotionSpeedSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new motion speed
        });

        // Visualizer Intensity control
        visualizerIntensitySlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new intensity
        });

        // Aspect Ratio selection
        aspectRatioSelect.addEventListener('change', (event) => {
            const selectedRatio = event.target.value;
            // If aspect ratio is manually changed, ensure output quality is "current"
            outputQualitySelect.value = 'current';
            updateCanvasSize();
            showMessage(`ទំហំបង្ហាញត្រូវបានផ្លាស់ប្តូរទៅ ${selectedRatio.replace('-', ':')}។`, false, true);
        });

        // Output Quality selection (for recording)
        outputQualitySelect.addEventListener('change', (event) => {
            // This change does NOT affect the display canvas size, only the recording resolution.
            // The `updateCanvasSize` function will handle setting the recordingCanvas dimensions.
            updateCanvasSize(); // Call updateCanvasSize to ensure recordingCanvas dimensions are set
            showMessage(`គុណភាពវីដេអូថតចេញត្រូវបានផ្លាស់ប្តូរទៅជា "${outputQualitySelect.options[outputQualitySelect.selectedIndex].text}"។`, false, true);
        });


        // Visualizer Type checkboxes change
        visualizerCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const visualizerType = checkbox.value;
                if (checkbox.checked) {
                    // Add or move to end if re-selected
                    activeVisualizerOrder = activeVisualizerOrder.filter(item => item.type !== visualizerType); // Remove if exists
                    activeVisualizerOrder.push({ type: visualizerType, timestamp: Date.now() });
                } else {
                    // Remove if unchecked
                    activeVisualizerOrder = activeVisualizerOrder.filter(item => item.type !== visualizerType);
                    // Clear particles for specific visualizer types when unchecked
                    switch (visualizerType) {
                        case 'falling-particles': fallingParticles.length = 0; break;
                        case 'rising-particles': risingParticles.length = 0; break;
                        case 'leftward-particles': leftwardParticles.length = 0; break;
                        case 'rightward-particles': rightwardParticles.length = 0; break;
                        case 'colorful-particles': colorfulParticles.length = 0; break;
                    }
                }
                drawVisualizer(); // Redraw canvas with new visualizer type order
                const selectedTypes = activeVisualizerOrder.map(item => {
                    // Find the label text for the visualizerType
                    const labelElement = document.querySelector(`.visualizer-checkbox[value="${item.type}"]`).parentNode;
                    return labelElement ? labelElement.textContent.trim() : item.type;
                }).join(', ');

                if (selectedTypes) {
                    showMessage(`ប្រភេទចលនាត្រូវបានផ្លាស់ប្តូរទៅជា: ${selectedTypes}។`, false, true);
                } else {
                    showMessage('ចលនាទាំងអស់ត្រូវបានបិទ។', false, true);
                }
            });
        });


        // Canvas Filter selection
        canvasFilterSelect.addEventListener('change', () => {
            drawVisualizer(); // Redraw canvas with new filter
            showMessage(`តម្រងរូបភាពត្រូវបានផ្លាស់ប្តូរទៅជា "${canvasFilterSelect.options[canvasFilterSelect.selectedIndex].text}"។`, false, true);
        });

        // Logo Position selection
        logoPositionSelect.addEventListener('change', drawVisualizer);

        // Logo Size control
        logoSizeSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new logo size
        });

        // Auto Logo Size checkbox control
        autoLogoSizeCheckbox.addEventListener('change', () => {
            logoSizeSlider.disabled = autoLogoSizeCheckbox.checked;
            drawVisualizer(); // Redraw canvas with new logo sizing mode
        });

        // Font URL loading
        loadFontUrlBtn.addEventListener('click', () => {
            loadFontFromUrl(fontUrlInput.value);
        });

        // Font File loading
        loadFontFileBtn.addEventListener('click', () => {
            if (fontFileInput.files.length > 0) {
                loadFontFromFile(fontFileInput.files[0], customFontNameInput.value);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Font ដើម្បីផ្ទុក។', true);
            }
        });

        // Font selection change
        fontSelect.addEventListener('change', drawVisualizer);


        // Fullscreen functionality
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                fullscreenBtn.textContent = 'ចេញពីពេញអេក្រង់';
            } else {
                fullscreenBtn.textContent = 'ពេញអេក្រង់';
            }
            // No need to call updateCanvasSize directly here, as aspectRatioSelect change listener handles it
        });


        // Function to update canvas size based on its container
        function updateCanvasSize() {
            const selectedOutputQuality = outputQualitySelect.value;
            const selectedAspectRatio = aspectRatioSelect.value;

            // Always set the display canvas based on the aspect ratio
            canvasContainer.classList.remove('aspect-ratio-16-9', 'aspect-ratio-9-16', 'aspect-ratio-1-1');
            canvasContainer.classList.remove('fixed-size'); // Ensure fixed-size is removed for display
            canvasContainer.classList.add(`aspect-ratio-${selectedAspectRatio}`);
            
            // Set visualizerCanvas dimensions to match the responsive container's current display size
            visualizerCanvas.width = canvasContainer.offsetWidth;
            visualizerCanvas.height = canvasContainer.offsetWidth / (16/9); // Default to 16:9 if no specific aspect ratio class

            // Set recordingCanvas dimensions based on selected output quality
            let recordWidth, recordHeight;
            if (selectedOutputQuality === 'current') {
                recordWidth = visualizerCanvas.width;
                recordHeight = visualizerCanvas.height;
            } else {
                const [w, h] = selectedOutputQuality.split('x').map(Number);
                recordWidth = w;
                recordHeight = h;
            }
            recordingCanvas.width = recordWidth;
            recordingCanvas.height = recordHeight;

            drawVisualizer(); // Redraw content after resizing
        }

        // --- Text Layer Management Functions ---
        let textLayerCounter = 0; // To give unique IDs to text layers

        function createAndAddTextLayer(initialContent = '', isSubtitle = false, copiedLayer = null) {
            const templateClone = textLayerTemplate.content.cloneNode(true);
            const textLayerDiv = templateClone.querySelector('.text-layer-controls');
            const id = textLayerCounter++; // Use id for unique identification
            textLayerDiv.dataset.id = id; // Store id in dataset for easy lookup

            const textArea = textLayerDiv.querySelector('textarea');
            const colorInput = textLayerDiv.querySelector('input[type="color"]');
            const sizeInput = textLayerDiv.querySelector('input[type="number"]');
            const positionSelect = textLayerDiv.querySelector('select.text-position-select');
            const boldCheckbox = textLayerDiv.querySelector('.text-bold-checkbox');
            const shadowCheckbox = textLayerDiv.querySelector('.text-shadow-checkbox');
            const blurCheckbox = textLayerDiv.querySelector('.text-blur-checkbox');
            const animationTypeSelect = textLayerDiv.querySelector('.text-animation-type-select');
            const removeBtn = textLayerDiv.querySelector('.btn-remove');
            const copyBtn = textLayerDiv.querySelector('.btn-copy'); // Get the copy button
            const startMinInput = textLayerDiv.querySelector('.text-start-min');
            const startSecInput = textLayerDiv.querySelector('.text-start-sec');
            const endMinInput = textLayerDiv.querySelector('.text-end-min');
            const endSecInput = textLayerDiv.querySelector('.text-end-sec');

            // New text styling inputs
            const textOutlineColorInput = textLayerDiv.querySelector('.text-outline-color-input');
            const textOutlineWidthInput = textLayerDiv.querySelector('.text-outline-width-input');
            const textShadowColorInput = textLayerDiv.querySelector('.text-shadow-color-input');
            const textShadowBlurInput = textLayerDiv.querySelector('.text-shadow-blur-input'); // New shadow blur input
            const textMarginLeftInput = textLayerDiv.querySelector('.text-margin-left-input');
            const textMarginRightInput = textLayerDiv.querySelector('.text-margin-right-input');
            const textMarginVerticalInput = textLayerDiv.querySelector('.text-margin-vertical-input');
            const textScaleXInput = textLayerDiv.querySelector('.text-scale-x-input');
            const textScaleYInput = textLayerDiv.querySelector('.text-scale-y-input');
            const textRotationInput = textLayerDiv.querySelector('.text-rotation-input');
            const textSpacingInput = textLayerDiv.querySelector('.text-spacing-input');
            const textFontSelect = textLayerDiv.querySelector('select.font-select'); // Get font select for this layer


            // Initialize text layer object
            const newTextLayer = {
                id: id, // Assign unique ID
                content: initialContent,
                color: colorInput.value,
                size: parseInt(sizeInput.value),
                position: positionSelect.value,
                bold: boldCheckbox.checked,
                shadow: shadowCheckbox.checked,
                blur: blurCheckbox.checked,
                animationType: animationTypeSelect.value,
                startTimeMinutes: parseInt(startMinInput.value),
                startTimeSeconds: parseInt(startSecInput.value),
                endTimeMinutes: parseInt(endMinInput.value),
                endTimeSeconds: parseInt(endSecInput.value),
                // New properties
                outlineColor: textOutlineColorInput.value,
                outlineWidth: parseFloat(textOutlineWidthInput.value),
                shadowColor: textShadowColorInput.value,
                shadowBlur: parseFloat(textShadowBlurInput.value), // Initialize new shadow blur
                marginLeft: parseFloat(textMarginLeftInput.value),
                marginRight: parseFloat(textMarginRightInput.value),
                marginVertical: parseFloat(textMarginVerticalInput.value),
                scaleX: parseFloat(textScaleXInput.value),
                scaleY: parseFloat(textScaleYInput.value),
                rotation: parseFloat(textRotationInput.value),
                spacing: parseFloat(textSpacingInput.value),
                fontFamily: defaultFontOptions[0].value, // Default to first font option
                // Animation state variables (will be updated in drawVisualizer)
                currentOffsetX: 0,
                currentOffsetY: 0,
                currentAlpha: 1,
                currentScale: 1
            };

            // If copying an existing layer, apply its properties
            if (copiedLayer) {
                Object.assign(newTextLayer, JSON.parse(JSON.stringify(copiedLayer))); // Deep copy
                newTextLayer.id = id; // Ensure new unique ID
                // Update controls to reflect copied values
                textArea.value = newTextLayer.content;
                colorInput.value = newTextLayer.color;
                sizeInput.value = newTextLayer.size;
                positionSelect.value = newTextLayer.position;
                boldCheckbox.checked = newTextLayer.bold;
                shadowCheckbox.checked = newTextLayer.shadow;
                blurCheckbox.checked = newTextLayer.blur;
                animationTypeSelect.value = newTextLayer.animationType;
                startMinInput.value = newTextLayer.startTimeMinutes;
                startSecInput.value = newTextLayer.startTimeSeconds;
                endMinInput.value = newTextLayer.endTimeMinutes;
                endSecInput.value = newTextLayer.endTimeSeconds;
                textOutlineColorInput.value = newTextLayer.outlineColor;
                textOutlineWidthInput.value = newTextLayer.outlineWidth;
                textShadowColorInput.value = newTextLayer.shadowColor;
                textShadowBlurInput.value = newTextLayer.shadowBlur;
                textMarginLeftInput.value = newTextLayer.marginLeft;
                textMarginRightInput.value = newTextLayer.marginRight;
                textMarginVerticalInput.value = newTextLayer.marginVertical;
                textScaleXInput.value = newTextLayer.scaleX;
                textScaleYInput.value = newTextLayer.scaleY;
                textRotationInput.value = newTextLayer.rotation;
                textSpacingInput.value = newTextLayer.spacing;
            }

            // Apply subtitle presets if requested (only if not copied, or if copied subtitle)
            if (isSubtitle && !copiedLayer) {
                newTextLayer.content = initialContent;
                newTextLayer.color = '#ffffff';
                newTextLayer.size = 40;
                newTextLayer.position = 'bottom-center';
                newTextLayer.bold = true;
                newTextLayer.shadow = true;
                newTextLayer.shadowColor = 'rgba(0,0,0,0.8)';
                newTextLayer.shadowBlur = 5; // Preset blur for subtitle
                newTextLayer.outlineWidth = 2;
                newTextLayer.outlineColor = '#000000';
                newTextLayer.animationType = 'none'; // Subtitles usually don't animate by default
                newTextLayer.blur = false;
                newTextLayer.marginVertical = -20; // Slightly move up for subtitle effect
                newTextLayer.fontFamily = 'Noto Sans Khmer'; // Default font for subtitle

                // Update controls to reflect presets
                textArea.value = newTextLayer.content;
                colorInput.value = newTextLayer.color;
                sizeInput.value = newTextLayer.size;
                positionSelect.value = newTextLayer.position;
                boldCheckbox.checked = newTextLayer.bold;
                shadowCheckbox.checked = newTextLayer.shadow;
                blurCheckbox.checked = newTextLayer.blur;
                animationTypeSelect.value = newTextLayer.animationType;
                textOutlineColorInput.value = newTextLayer.outlineColor;
                textOutlineWidthInput.value = newTextLayer.outlineWidth;
                textShadowColorInput.value = newTextLayer.shadowColor;
                textShadowBlurInput.value = newTextLayer.shadowBlur; // Set preset blur value
                textMarginVerticalInput.value = newTextLayer.marginVertical;
            }

            textLayers.push(newTextLayer);

            // Populate font select options for this new layer
            textFontSelect.innerHTML = ''; // Clear existing options
            defaultFontOptions.forEach(font => {
                const option = new Option(font.text, font.value);
                textFontSelect.add(option);
            });
            textFontSelect.value = newTextLayer.fontFamily; // Set the selected font

            // Set initial values from object to controls
            textArea.value = newTextLayer.content; // Ensure textarea content is set

            // Attach event listeners
            textArea.addEventListener('input', () => {
                newTextLayer.content = textArea.value;
                drawVisualizer();
            });
            colorInput.addEventListener('input', () => {
                newTextLayer.color = colorInput.value;
                drawVisualizer();
            });
            sizeInput.addEventListener('input', () => {
                newTextLayer.size = parseInt(sizeInput.value);
                drawVisualizer();
            });
            positionSelect.addEventListener('change', () => {
                newTextLayer.position = positionSelect.value;
                drawVisualizer();
            });
            boldCheckbox.addEventListener('change', () => {
                newTextLayer.bold = boldCheckbox.checked;
                drawVisualizer();
            });
            shadowCheckbox.addEventListener('change', () => {
                newTextLayer.shadow = shadowCheckbox.checked;
                drawVisualizer();
            });
            blurCheckbox.addEventListener('change', () => {
                newTextLayer.blur = blurCheckbox.checked;
                drawVisualizer();
            });
            animationTypeSelect.addEventListener('change', () => {
                newTextLayer.animationType = animationTypeSelect.value;
                drawVisualizer();
            });
            startMinInput.addEventListener('input', () => {
                newTextLayer.startTimeMinutes = parseInt(startMinInput.value) || 0;
                drawVisualizer();
            });
            startSecInput.addEventListener('input', () => {
                newTextLayer.startTimeSeconds = parseInt(startSecInput.value) || 0;
                drawVisualizer();
            });
            endMinInput.addEventListener('input', () => {
                newTextLayer.endTimeMinutes = parseInt(endMinInput.value) || 0;
                drawVisualizer();
            });
            endSecInput.addEventListener('input', () => {
                newTextLayer.endTimeSeconds = parseInt(endSecInput.value) || 0;
                drawVisualizer();
            });
            removeBtn.addEventListener('click', () => {
                removeTextLayer(id); // Use id for removal
            });
            copyBtn.addEventListener('click', () => { // Event listener for the new copy button
                copyTextLayer(id);
            });

            // New event listeners for text styling and transformations
            textOutlineColorInput.addEventListener('input', () => { newTextLayer.outlineColor = textOutlineColorInput.value; drawVisualizer(); });
            textOutlineWidthInput.addEventListener('input', () => { newTextLayer.outlineWidth = parseFloat(textOutlineWidthInput.value); drawVisualizer(); });
            textShadowColorInput.addEventListener('input', () => { newTextLayer.shadowColor = textShadowColorInput.value; drawVisualizer(); });
            textShadowBlurInput.addEventListener('input', () => { newTextLayer.shadowBlur = parseFloat(textShadowBlurInput.value); drawVisualizer(); }); // Event listener for new shadow blur
            textMarginLeftInput.addEventListener('input', () => { newTextLayer.marginLeft = parseFloat(textMarginLeftInput.value); drawVisualizer(); });
            textMarginRightInput.addEventListener('input', () => { newTextLayer.marginRight = parseFloat(textMarginRightInput.value); drawVisualizer(); });
            textMarginVerticalInput.addEventListener('input', () => { newTextLayer.marginVertical = parseFloat(textMarginVerticalInput.value); drawVisualizer(); });
            textScaleXInput.addEventListener('input', () => { newTextLayer.scaleX = parseFloat(textScaleXInput.value); drawVisualizer(); });
            textScaleYInput.addEventListener('input', () => { newTextLayer.scaleY = parseFloat(textScaleYInput.value); drawVisualizer(); });
            textRotationInput.addEventListener('input', () => { newTextLayer.rotation = parseFloat(textRotationInput.value); drawVisualizer(); });
            textSpacingInput.addEventListener('input', () => { newTextLayer.spacing = parseFloat(textSpacingInput.value); drawVisualizer(); });
            textFontSelect.addEventListener('change', () => { // Event listener for individual font select
                newTextLayer.fontFamily = textFontSelect.value;
                drawVisualizer();
            });


            textLayersContainer.appendChild(textLayerDiv);
            drawVisualizer(); // Redraw to show new text layer
        }

        function copyTextLayer(idToCopy) {
            const originalLayer = textLayers.find(layer => layer.id === idToCopy);
            if (originalLayer) {
                // Create a shallow copy of the object
                const clonedLayer = { ...originalLayer };
                clonedLayer.id = textLayerCounter++; // Assign new unique ID
                // Create a new DOM element for it
                const templateClone = textLayerTemplate.content.cloneNode(true);
                const textLayerDiv = templateClone.querySelector('.text-layer-controls');
                textLayerDiv.dataset.id = clonedLayer.id;

                const textArea = textLayerDiv.querySelector('textarea');
                const colorInput = textLayerDiv.querySelector('input[type="color"]');
                const sizeInput = textLayerDiv.querySelector('input[type="number"]');
                const positionSelect = textLayerDiv.querySelector('select.text-position-select');
                const boldCheckbox = textLayerDiv.querySelector('.text-bold-checkbox');
                const shadowCheckbox = textLayerDiv.querySelector('.text-shadow-checkbox');
                const blurCheckbox = textLayerDiv.querySelector('.text-blur-checkbox');
                const animationTypeSelect = textLayerDiv.querySelector('.text-animation-type-select');
                const removeBtn = textLayerDiv.querySelector('.btn-remove');
                const copyBtn = textLayerDiv.querySelector('.btn-copy');
                const startMinInput = textLayerDiv.querySelector('.text-start-min');
                const startSecInput = textLayerDiv.querySelector('.text-start-sec');
                const endMinInput = textLayerDiv.querySelector('.text-end-min');
                const endSecInput = textLayerDiv.querySelector('.text-end-sec');
                const textOutlineColorInput = textLayerDiv.querySelector('.text-outline-color-input');
                const textOutlineWidthInput = textLayerDiv.querySelector('.text-outline-width-input');
                const textShadowColorInput = textLayerDiv.querySelector('.text-shadow-color-input');
                const textShadowBlurInput = textLayerDiv.querySelector('.text-shadow-blur-input');
                const textMarginLeftInput = textLayerDiv.querySelector('.text-margin-left-input');
                const textMarginRightInput = textLayerDiv.querySelector('.text-margin-right-input');
                const textMarginVerticalInput = textLayerDiv.querySelector('.text-margin-vertical-input');
                const textScaleXInput = textLayerDiv.querySelector('.text-scale-x-input');
                const textScaleYInput = textLayerDiv.querySelector('.text-scale-y-input');
                const textRotationInput = textLayerDiv.querySelector('.text-rotation-input');
                const textSpacingInput = textLayerDiv.querySelector('.text-spacing-input');
                const textFontSelect = textLayerDiv.querySelector('select.font-select');

                // Populate controls with cloned values
                textArea.value = clonedLayer.content;
                colorInput.value = clonedLayer.color;
                sizeInput.value = clonedLayer.size;
                positionSelect.value = clonedLayer.position;
                boldCheckbox.checked = clonedLayer.bold;
                shadowCheckbox.checked = clonedLayer.shadow;
                blurCheckbox.checked = clonedLayer.blur;
                animationTypeSelect.value = clonedLayer.animationType;
                startMinInput.value = clonedLayer.startTimeMinutes;
                startSecInput.value = clonedLayer.startTimeSeconds;
                endMinInput.value = clonedLayer.endTimeMinutes;
                endSecInput.value = clonedLayer.endTimeSeconds;
                textOutlineColorInput.value = clonedLayer.outlineColor;
                textOutlineWidthInput.value = clonedLayer.outlineWidth;
                textShadowColorInput.value = clonedLayer.shadowColor;
                textShadowBlurInput.value = clonedLayer.shadowBlur;
                textMarginLeftInput.value = clonedLayer.marginLeft;
                textMarginRightInput.value = clonedLayer.marginRight;
                textMarginVerticalInput.value = clonedLayer.marginVertical;
                textScaleXInput.value = clonedLayer.scaleX;
                textScaleYInput.value = clonedLayer.scaleY;
                textRotationInput.value = clonedLayer.rotation;
                textSpacingInput.value = clonedLayer.spacing;

                // Populate font select options for this new layer
                textFontSelect.innerHTML = '';
                defaultFontOptions.forEach(font => {
                    const option = new Option(font.text, font.value);
                    textFontSelect.add(option);
                });
                textFontSelect.value = clonedLayer.fontFamily;

                // Attach event listeners for the new DOM elements
                textArea.addEventListener('input', () => { clonedLayer.content = textArea.value; drawVisualizer(); });
                colorInput.addEventListener('input', () => { clonedLayer.color = colorInput.value; drawVisualizer(); });
                sizeInput.addEventListener('input', () => { clonedLayer.size = parseInt(sizeInput.value); drawVisualizer(); });
                positionSelect.addEventListener('change', () => { clonedLayer.position = positionSelect.value; drawVisualizer(); });
                boldCheckbox.addEventListener('change', () => { clonedLayer.bold = boldCheckbox.checked; drawVisualizer(); });
                shadowCheckbox.addEventListener('change', () => { clonedLayer.shadow = shadowCheckbox.checked; drawVisualizer(); });
                blurCheckbox.addEventListener('change', () => { clonedLayer.blur = blurCheckbox.checked; drawVisualizer(); });
                animationTypeSelect.addEventListener('change', () => { clonedLayer.animationType = animationTypeSelect.value; drawVisualizer(); });
                startMinInput.addEventListener('input', () => { clonedLayer.startTimeMinutes = parseInt(startMinInput.value) || 0; drawVisualizer(); });
                startSecInput.addEventListener('input', () => { clonedLayer.startTimeSeconds = parseInt(startSecInput.value) || 0; drawVisualizer(); });
                endMinInput.addEventListener('input', () => { clonedLayer.endTimeMinutes = parseInt(endMinInput.value) || 0; drawVisualizer(); });
                endSecInput.addEventListener('input', () => { clonedLayer.endTimeSeconds = parseInt(endSecInput.value) || 0; drawVisualizer(); });
                removeBtn.addEventListener('click', () => { removeTextLayer(clonedLayer.id); });
                copyBtn.addEventListener('click', () => { copyTextLayer(clonedLayer.id); });
                textOutlineColorInput.addEventListener('input', () => { clonedLayer.outlineColor = textOutlineColorInput.value; drawVisualizer(); });
                textOutlineWidthInput.addEventListener('input', () => { clonedLayer.outlineWidth = parseFloat(textOutlineWidthInput.value); drawVisualizer(); });
                textShadowColorInput.addEventListener('input', () => { clonedLayer.shadowColor = textShadowColorInput.value; drawVisualizer(); });
                textShadowBlurInput.addEventListener('input', () => { clonedLayer.shadowBlur = parseFloat(textShadowBlurInput.value); drawVisualizer(); });
                textMarginLeftInput.addEventListener('input', () => { clonedLayer.marginLeft = parseFloat(textMarginLeftInput.value); drawVisualizer(); });
                textMarginRightInput.addEventListener('input', () => { clonedLayer.marginRight = parseFloat(textMarginRightInput.value); drawVisualizer(); });
                textMarginVerticalInput.addEventListener('input', () => { clonedLayer.marginVertical = parseFloat(textMarginVerticalInput.value); drawVisualizer(); });
                textScaleXInput.addEventListener('input', () => { clonedLayer.scaleX = parseFloat(textScaleXInput.value); drawVisualizer(); });
                textScaleYInput.addEventListener('input', () => { clonedLayer.scaleY = parseFloat(textScaleYInput.value); drawVisualizer(); });
                textRotationInput.addEventListener('input', () => { clonedLayer.rotation = parseFloat(textRotationInput.value); drawVisualizer(); });
                textSpacingInput.addEventListener('input', () => { clonedLayer.spacing = parseFloat(textSpacingInput.value); drawVisualizer(); });
                textFontSelect.addEventListener('change', () => { clonedLayer.fontFamily = textFontSelect.value; drawVisualizer(); });

                textLayersContainer.appendChild(textLayerDiv);
                textLayers.push(clonedLayer); // Add to data array
                drawVisualizer(); // Redraw to show new text layer
                showMessage('អត្ថបទត្រូវបានចម្លង។', false, true);
            } else {
                showMessage('មិនអាចរកឃើញស្រទាប់អត្ថបទដើម្បីចម្លងបានទេ។', true);
            }
        }

        function removeTextLayer(idToRemove) {
            // Find the actual DOM element for the text layer
            const elementToRemove = textLayersContainer.querySelector(`[data-id="${idToRemove}"]`);
            if (elementToRemove) {
                // Find the corresponding object in the textLayers array and remove it
                const foundIndex = textLayers.findIndex(layer => layer.id === idToRemove);
                
                if (foundIndex > -1) {
                    textLayers.splice(foundIndex, 1); // Remove from data array
                }
                
                elementToRemove.remove(); // Remove from DOM
                showMessage('អត្ថបទត្រូវបានលុប។', false, true);
                drawVisualizer(); // Redraw after removal
            }
        }

        addTextLayerBtn.addEventListener('click', () => {
            createAndAddTextLayer(''); // Add a new empty text layer
        });

        addSubtitleLayerBtn.addEventListener('click', () => {
            createAndAddTextLayer('បញ្ចូល Subtitle នៅទីនេះ', true); // Add a new subtitle layer with presets
        });


        // --- Image Layer Management Functions ---
        let imageLayerCounter = 0; // To give unique IDs to image layers

        function createAndAddImageLayer(copiedLayer = null) {
            const templateClone = imageLayerTemplate.content.cloneNode(true);
            const imageLayerDiv = templateClone.querySelector('.image-layer-controls');
            const id = imageLayerCounter++; // Use id for unique identification
            imageLayerDiv.dataset.id = id;

            const imageFileInput = imageLayerDiv.querySelector('.image-file-input');
            const imagePreviewThumbnail = imageLayerDiv.querySelector('.image-preview-thumbnail');
            const imageSizeSlider = imageLayerDiv.querySelector('.image-size-slider');
            const autoImageSizeCheckbox = imageLayerDiv.querySelector('.auto-image-size-checkbox');
            const imagePositionSelect = imageLayerDiv.querySelector('.image-position-select');
            const imagePulseCheckbox = imageLayerDiv.querySelector('.image-pulse-checkbox');
            const applyVisualizerToImageCheckbox = imageLayerDiv.querySelector('.apply-visualizer-to-image-checkbox'); // New checkbox
            const removeBtn = imageLayerDiv.querySelector('.btn-remove');
            const copyBtn = imageLayerDiv.querySelector('.btn-copy-image'); // Get the copy button for images
            const startMinInput = imageLayerDiv.querySelector('.image-start-min'); // New time input
            const startSecInput = imageLayerDiv.querySelector('.image-start-sec'); // New time input
            const endMinInput = imageLayerDiv.querySelector('.image-end-min'); // New time input
            const endSecInput = imageLayerDiv.querySelector('.image-end-sec'); // New time input


            const newImageLayer = {
                id: id,
                img: new Image(),
                isLoaded: false,
                src: '',
                size: parseFloat(imageSizeSlider.value),
                autoSize: autoImageSizeCheckbox.checked,
                position: imagePositionSelect.value,
                pulse: imagePulseCheckbox.checked,
                applyVisualizer: applyVisualizerToImageCheckbox.checked, // New property
                startTimeMinutes: parseInt(startMinInput.value), // New time property
                startTimeSeconds: parseInt(startSecInput.value), // New time property
                endTimeMinutes: parseInt(endMinInput.value), // New time property
                endTimeSeconds: parseInt(endSecInput.value) // New time property
            };

            if (copiedLayer) {
                Object.assign(newImageLayer, JSON.parse(JSON.stringify(copiedLayer)));
                newImageLayer.id = id;
                newImageLayer.img = new Image();
                newImageLayer.img.src = copiedLayer.src;
                newImageLayer.isLoaded = copiedLayer.isLoaded;

                // Update controls to reflect copied values
                imagePreviewThumbnail.src = newImageLayer.src;
                imageSizeSlider.value = newImageLayer.size;
                autoImageSizeCheckbox.checked = newImageLayer.autoSize;
                imageSizeSlider.disabled = newImageLayer.autoSize;
                imagePositionSelect.value = newImageLayer.position;
                imagePulseCheckbox.checked = newImageLayer.pulse;
                applyVisualizerToImageCheckbox.checked = newImageLayer.applyVisualizer;
                startMinInput.value = newImageLayer.startTimeMinutes;
                startSecInput.value = newImageLayer.startTimeSeconds;
                endMinInput.value = newImageLayer.endTimeMinutes;
                endSecInput.value = newImageLayer.endTimeSeconds;
            }

            imageLayers.push(newImageLayer);

            // Set initial state of controls
            imageSizeSlider.disabled = newImageLayer.autoSize;

            // Event Listeners
            imageFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        newImageLayer.src = e.target.result;
                        newImageLayer.img.src = e.target.result;
                        newImageLayer.img.onload = () => {
                            newImageLayer.isLoaded = true;
                            imagePreviewThumbnail.src = newImageLayer.src;
                            drawVisualizer();
                            showMessage(`រូបភាព "${file.name}" ត្រូវបានផ្ទុក។`);
                        };
                        newImageLayer.img.onerror = () => {
                            newImageLayer.isLoaded = false;
                            showMessage('មិនអាចផ្ទុករូបភាពបានទេ។', true);
                        };
                    };
                    reader.readAsDataURL(file);
                } else {
                    newImageLayer.isLoaded = false;
                    imagePreviewThumbnail.src = '';
                    showMessage('សូមជ្រើសរើសរូបភាព។', true);
                }
                moveImageLayerToTop(id); // Move to top on file selection
            });

            imageSizeSlider.addEventListener('input', () => {
                newImageLayer.size = parseFloat(imageSizeSlider.value);
                moveImageLayerToTop(id); // Move to top on change
            });

            autoImageSizeCheckbox.addEventListener('change', () => {
                newImageLayer.autoSize = autoImageSizeCheckbox.checked;
                imageSizeSlider.disabled = newImageLayer.autoSize;
                moveImageLayerToTop(id); // Move to top on change
            });

            imagePositionSelect.addEventListener('change', () => {
                newImageLayer.position = imagePositionSelect.value;
                moveImageLayerToTop(id); // Move to top on change
            });

            imagePulseCheckbox.addEventListener('change', () => {
                newImageLayer.pulse = imagePulseCheckbox.checked;
                moveImageLayerToTop(id); // Move to top on change
            });

            applyVisualizerToImageCheckbox.addEventListener('change', () => { // New event listener
                newImageLayer.applyVisualizer = applyVisualizerToImageCheckbox.checked;
                drawVisualizer(); // Redraw if visualizer application changes
            });

            startMinInput.addEventListener('input', () => {
                newImageLayer.startTimeMinutes = parseInt(startMinInput.value) || 0;
                drawVisualizer();
            });
            startSecInput.addEventListener('input', () => {
                newImageLayer.startTimeSeconds = parseInt(startSecInput.value) || 0;
                drawVisualizer();
            });
            endMinInput.addEventListener('input', () => {
                newImageLayer.endTimeMinutes = parseInt(endMinInput.value) || 0;
                drawVisualizer();
            });
            endSecInput.addEventListener('input', () => {
                newImageLayer.endTimeSeconds = parseInt(endSecInput.value) || 0;
                drawVisualizer();
            });

            removeBtn.addEventListener('click', () => {
                removeImageLayer(id); // Use id for removal
            });
            copyBtn.addEventListener('click', () => { // Event listener for the new copy button
                copyImageLayer(id);
            });

            imageLayersContainer.appendChild(imageLayerDiv);
            drawVisualizer();
        }

        function copyImageLayer(idToCopy) {
            const originalLayer = imageLayers.find(layer => layer.id === idToCopy);
            if (originalLayer) {
                // Create a shallow copy of the object
                const clonedLayer = { ...originalLayer };
                clonedLayer.id = imageLayerCounter++; // Assign new unique ID
                clonedLayer.img = new Image(); // Create a new Image object
                clonedLayer.img.src = originalLayer.src; // Set its source to the original's
                clonedLayer.isLoaded = originalLayer.isLoaded; // Copy loaded status

                // Manually create and populate the DOM elements for the new layer
                const templateClone = imageLayerTemplate.content.cloneNode(true);
                const imageLayerDiv = templateClone.querySelector('.image-layer-controls');
                imageLayerDiv.dataset.id = clonedLayer.id;

                const imageFileInput = imageLayerDiv.querySelector('.image-file-input');
                const imagePreviewThumbnail = imageLayerDiv.querySelector('.image-preview-thumbnail');
                const imageSizeSlider = imageLayerDiv.querySelector('.image-size-slider');
                const autoImageSizeCheckbox = imageLayerDiv.querySelector('.auto-image-size-checkbox');
                const imagePositionSelect = imageLayerDiv.querySelector('.image-position-select');
                const imagePulseCheckbox = imageLayerDiv.querySelector('.image-pulse-checkbox');
                const applyVisualizerToImageCheckbox = imageLayerDiv.querySelector('.apply-visualizer-to-image-checkbox');
                const removeBtn = imageLayerDiv.querySelector('.btn-remove');
                const copyBtn = imageLayerDiv.querySelector('.btn-copy-image');
                const startMinInput = imageLayerDiv.querySelector('.image-start-min');
                const startSecInput = imageLayerDiv.querySelector('.image-start-sec');
                const endMinInput = imageLayerDiv.querySelector('.image-end-min');
                const endSecInput = imageLayerDiv.querySelector('.image-end-sec');

                // Populate controls with cloned values
                imagePreviewThumbnail.src = clonedLayer.src;
                imageSizeSlider.value = clonedLayer.size;
                autoImageSizeCheckbox.checked = clonedLayer.autoSize;
                imageSizeSlider.disabled = clonedLayer.autoSize;
                imagePositionSelect.value = clonedLayer.position;
                imagePulseCheckbox.checked = clonedLayer.pulse;
                applyVisualizerToImageCheckbox.checked = clonedLayer.applyVisualizer;
                startMinInput.value = clonedLayer.startTimeMinutes;
                startSecInput.value = clonedLayer.startTimeSeconds;
                endMinInput.value = clonedLayer.endTimeMinutes;
                endSecInput.value = clonedLayer.endTimeSeconds;

                // Re-attach event listeners for the new DOM elements
                imageFileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            clonedLayer.src = e.target.result;
                            clonedLayer.img.src = e.target.result;
                            clonedLayer.img.onload = () => {
                                clonedLayer.isLoaded = true;
                                imagePreviewThumbnail.src = clonedLayer.src;
                                drawVisualizer();
                                showMessage(`រូបភាព "${file.name}" ត្រូវបានផ្ទុក។`);
                            };
                            clonedLayer.img.onerror = () => {
                                clonedLayer.isLoaded = false;
                                showMessage('មិនអាចផ្ទុករូបភាពបានទេ។', true);
                            };
                        };
                        reader.readAsDataURL(file);
                    } else {
                        clonedLayer.isLoaded = false;
                        imagePreviewThumbnail.src = '';
                        showMessage('សូមជ្រើសរើសរូបភាព។', true);
                    }
                    moveImageLayerToTop(clonedLayer.id);
                });

                imageSizeSlider.addEventListener('input', () => {
                    clonedLayer.size = parseFloat(imageSizeSlider.value);
                    moveImageLayerToTop(clonedLayer.id);
                });
                autoImageSizeCheckbox.addEventListener('change', () => {
                    clonedLayer.autoSize = autoImageSizeCheckbox.checked;
                    imageSizeSlider.disabled = clonedLayer.autoSize;
                    moveImageLayerToTop(clonedLayer.id);
                });
                imagePositionSelect.addEventListener('change', () => {
                    clonedLayer.position = imagePositionSelect.value;
                    moveImageLayerToTop(clonedLayer.id);
                });
                imagePulseCheckbox.addEventListener('change', () => {
                    clonedLayer.pulse = imagePulseCheckbox.checked;
                    moveImageLayerToTop(clonedLayer.id);
                });
                applyVisualizerToImageCheckbox.addEventListener('change', () => {
                    clonedLayer.applyVisualizer = applyVisualizerToImageCheckbox.checked;
                    drawVisualizer();
                });
                startMinInput.addEventListener('input', () => {
                    clonedLayer.startTimeMinutes = parseInt(startMinInput.value) || 0;
                    drawVisualizer();
                });
                startSecInput.addEventListener('input', () => {
                    clonedLayer.startTimeSeconds = parseInt(startSecInput.value) || 0;
                    drawVisualizer();
                });
                endMinInput.addEventListener('input', () => {
                    clonedLayer.endTimeMinutes = parseInt(endMinInput.value) || 0;
                    drawVisualizer();
                });
                endSecInput.addEventListener('input', () => {
                    clonedLayer.endTimeSeconds = parseInt(endSecInput.value) || 0;
                    drawVisualizer();
                });
                removeBtn.addEventListener('click', () => {
                    removeImageLayer(clonedLayer.id);
                });
                copyBtn.addEventListener('click', () => {
                    copyImageLayer(clonedLayer.id);
                });


                imageLayersContainer.appendChild(imageLayerDiv);
                drawVisualizer(); // Redraw to show new image layer
            } else {
                showMessage('មិនអាចរកឃើញស្រទាប់រូបភាពដើម្បីចម្លងបានទេ។', true);
            }
        }

        function moveImageLayerToTop(idToMove) {
            const index = imageLayers.findIndex(layer => layer.id === idToMove);
            if (index > -1) {
                const [movedLayer] = imageLayers.splice(index, 1);
                imageLayers.push(movedLayer);
                drawVisualizer(); // Redraw to reflect new order
            }
        }

        function removeImageLayer(idToRemove) {
            const elementToRemove = imageLayersContainer.querySelector(`[data-id="${idToRemove}"]`);
            if (elementToRemove) {
                const foundIndex = imageLayers.findIndex(layer => layer.id === idToRemove);
                if (foundIndex > -1) {
                    imageLayers.splice(foundIndex, 1);
                }
                elementToRemove.remove();
                showMessage('រូបភាពត្រូវបានលុប។', false, true);
                drawVisualizer();
            }
        }

        addImageLayerBtn.addEventListener('click', () => {
            createAndAddImageLayer();
        });


        // --- Video Layer Management Functions ---
        let videoLayerCounter = 0;

        function createAndAddVideoLayer(copiedLayer = null) {
            const templateClone = videoLayerTemplate.content.cloneNode(true);
            const videoLayerDiv = templateClone.querySelector('.video-layer-controls');
            const id = videoLayerCounter++;
            videoLayerDiv.dataset.id = id;

            const videoFileInput = videoLayerDiv.querySelector('.video-file-input');
            const videoPreviewThumbnail = videoLayerDiv.querySelector('.video-preview-thumbnail');
            const videoSizeSlider = videoLayerDiv.querySelector('.video-size-slider');
            const autoVideoSizeCheckbox = videoLayerDiv.querySelector('.auto-video-size-checkbox');
            const videoPositionSelect = videoLayerDiv.querySelector('.video-position-select');
            const removeBtn = videoLayerDiv.querySelector('.btn-remove');
            const copyBtn = videoLayerDiv.querySelector('.btn-copy-video');
            const startMinInput = videoLayerDiv.querySelector('.video-start-min');
            const startSecInput = videoLayerDiv.querySelector('.video-start-sec');
            const endMinInput = videoLayerDiv.querySelector('.video-end-min');
            const endSecInput = videoLayerDiv.querySelector('.video-end-sec');

            const newVideoLayer = {
                id: id,
                video: document.createElement('video'), // Create actual video element
                isLoaded: false,
                src: '',
                size: parseFloat(videoSizeSlider.value),
                autoSize: autoVideoSizeCheckbox.checked,
                position: videoPositionSelect.value,
                startTimeMinutes: parseInt(startMinInput.value),
                startTimeSeconds: parseInt(startSecInput.value),
                endTimeMinutes: parseInt(endMinInput.value),
                endTimeSeconds: parseInt(endSecInput.value)
            };

            // Mute and loop the actual video element for canvas drawing
            newVideoLayer.video.muted = true;
            newVideoLayer.video.loop = true;
            newVideoLayer.video.autoplay = true; // Autoplay for canvas drawing
            newVideoLayer.video.preload = 'auto'; // Preload for better performance

            if (copiedLayer) {
                Object.assign(newVideoLayer, JSON.parse(JSON.stringify(copiedLayer)));
                newVideoLayer.id = id;
                newVideoLayer.video = document.createElement('video');
                newVideoLayer.video.muted = true;
                newVideoLayer.video.loop = true;
                newVideoLayer.video.autoplay = true;
                newVideoLayer.video.preload = 'auto';
                newVideoLayer.video.src = copiedLayer.src;
                newVideoLayer.isLoaded = copiedLayer.isLoaded;

                // Update controls to reflect copied values
                videoPreviewThumbnail.src = newVideoLayer.src; // Set preview thumbnail
                videoSizeSlider.value = newVideoLayer.size;
                autoVideoSizeCheckbox.checked = newVideoLayer.autoSize;
                videoSizeSlider.disabled = newVideoLayer.autoSize;
                videoPositionSelect.value = newVideoLayer.position;
                startMinInput.value = newVideoLayer.startTimeMinutes;
                startSecInput.value = newVideoLayer.startTimeSeconds;
                endMinInput.value = newVideoLayer.endTimeMinutes;
                endSecInput.value = newVideoLayer.endTimeSeconds;
            }

            videoLayers.push(newVideoLayer);

            // Event Listeners
            videoFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const fileURL = URL.createObjectURL(file);
                    newVideoLayer.src = fileURL;
                    newVideoLayer.video.src = fileURL;
                    videoPreviewThumbnail.src = fileURL; // Set preview thumbnail

                    newVideoLayer.video.onloadedmetadata = () => {
                        newVideoLayer.isLoaded = true;
                        // Ensure video starts playing for canvas drawing
                        newVideoLayer.video.play().catch(e => console.error("Video autoplay failed:", e));
                        drawVisualizer();
                        showMessage(`វីដេអូ "${file.name}" ត្រូវបានផ្ទុក។`);
                    };
                    newVideoLayer.video.onerror = () => {
                        newVideoLayer.isLoaded = false;
                        showMessage('មិនអាចផ្ទុកវីដេអូបានទេ។', true);
                    };
                } else {
                    newVideoLayer.isLoaded = false;
                    newVideoLayer.src = '';
                    videoPreviewThumbnail.src = '';
                    showMessage('សូមជ្រើសរើសវីដេអូ។', true);
                }
                moveVideoLayerToTop(id);
            });

            videoSizeSlider.addEventListener('input', () => {
                newVideoLayer.size = parseFloat(videoSizeSlider.value);
                moveVideoLayerToTop(id);
            });

            autoVideoSizeCheckbox.addEventListener('change', () => {
                newVideoLayer.autoSize = autoVideoSizeCheckbox.checked;
                videoSizeSlider.disabled = newVideoLayer.autoSize;
                moveVideoLayerToTop(id);
            });

            videoPositionSelect.addEventListener('change', () => {
                newVideoLayer.position = videoPositionSelect.value;
                moveVideoLayerToTop(id);
            });

            startMinInput.addEventListener('input', () => {
                newVideoLayer.startTimeMinutes = parseInt(startMinInput.value) || 0;
                drawVisualizer();
            });
            startSecInput.addEventListener('input', () => {
                newVideoLayer.startTimeSeconds = parseInt(startSecInput.value) || 0;
                drawVisualizer();
            });
            endMinInput.addEventListener('input', () => {
                newVideoLayer.endTimeMinutes = parseInt(endMinInput.value) || 0;
                drawVisualizer();
            });
            endSecInput.addEventListener('input', () => {
                newVideoLayer.endTimeSeconds = parseInt(endSecInput.value) || 0;
                drawVisualizer();
            });

            removeBtn.addEventListener('click', () => {
                removeVideoLayer(id);
            });
            copyBtn.addEventListener('click', () => {
                copyVideoLayer(id);
            });

            videoLayersContainer.appendChild(videoLayerDiv);
            drawVisualizer();
        }

        function copyVideoLayer(idToCopy) {
            const originalLayer = videoLayers.find(layer => layer.id === idToCopy);
            if (originalLayer) {
                const clonedLayer = { ...originalLayer };
                clonedLayer.id = videoLayerCounter++;
                clonedLayer.video = document.createElement('video');
                clonedLayer.video.muted = true;
                clonedLayer.video.loop = true;
                clonedLayer.video.autoplay = true;
                clonedLayer.video.preload = 'auto';
                clonedLayer.video.src = originalLayer.src;
                clonedLayer.isLoaded = originalLayer.isLoaded;

                // Create and append new DOM for the cloned video layer
                const templateClone = videoLayerTemplate.content.cloneNode(true);
                const videoLayerDiv = templateClone.querySelector('.video-layer-controls');
                videoLayerDiv.dataset.id = clonedLayer.id;

                const videoFileInput = videoLayerDiv.querySelector('.video-file-input');
                const videoPreviewThumbnail = videoLayerDiv.querySelector('.video-preview-thumbnail');
                const videoSizeSlider = videoLayerDiv.querySelector('.video-size-slider');
                const autoVideoSizeCheckbox = videoLayerDiv.querySelector('.auto-video-size-checkbox');
                const videoPositionSelect = videoLayerDiv.querySelector('.video-position-select');
                const removeBtn = videoLayerDiv.querySelector('.btn-remove');
                const copyBtn = videoLayerDiv.querySelector('.btn-copy-video');
                const startMinInput = videoLayerDiv.querySelector('.video-start-min');
                const startSecInput = videoLayerDiv.querySelector('.video-start-sec');
                const endMinInput = videoLayerDiv.querySelector('.video-end-min');
                const endSecInput = videoLayerDiv.querySelector('.video-end-sec');

                // Populate controls with cloned values
                videoPreviewThumbnail.src = clonedLayer.src;
                videoSizeSlider.value = clonedLayer.size;
                autoVideoSizeCheckbox.checked = clonedLayer.autoSize;
                videoSizeSlider.disabled = clonedLayer.autoSize;
                videoPositionSelect.value = clonedLayer.position;
                startMinInput.value = clonedLayer.startTimeMinutes;
                startSecInput.value = clonedLayer.startTimeSeconds;
                endMinInput.value = clonedLayer.endTimeMinutes;
                endSecInput.value = clonedLayer.endTimeSeconds;

                // Re-attach event listeners for the new DOM elements
                videoFileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const fileURL = URL.createObjectURL(file);
                        clonedLayer.src = fileURL;
                        clonedLayer.video.src = fileURL;
                        videoPreviewThumbnail.src = fileURL;
                        clonedLayer.video.onloadedmetadata = () => {
                            clonedLayer.isLoaded = true;
                            clonedLayer.video.play().catch(e => console.error("Video autoplay failed:", e));
                            drawVisualizer();
                            showMessage(`វីដេអូ "${file.name}" ត្រូវបានផ្ទុក។`);
                        };
                        clonedLayer.video.onerror = () => {
                            clonedLayer.isLoaded = false;
                            showMessage('មិនអាចផ្ទុកវីដេអូបានទេ។', true);
                        };
                    } else {
                        clonedLayer.isLoaded = false;
                        videoPreviewThumbnail.src = '';
                        showMessage('សូមជ្រើសរើសវីដេអូ។', true);
                    }
                    moveVideoLayerToTop(clonedLayer.id);
                });
                videoSizeSlider.addEventListener('input', () => { clonedLayer.size = parseFloat(videoSizeSlider.value); moveVideoLayerToTop(clonedLayer.id); });
                autoVideoSizeCheckbox.addEventListener('change', () => { clonedLayer.autoSize = autoVideoSizeCheckbox.checked; videoSizeSlider.disabled = clonedLayer.autoSize; moveVideoLayerToTop(clonedLayer.id); });
                videoPositionSelect.addEventListener('change', () => { clonedLayer.position = videoPositionSelect.value; moveVideoLayerToTop(clonedLayer.id); });
                startMinInput.addEventListener('input', () => { clonedLayer.startTimeMinutes = parseInt(startMinInput.value) || 0; drawVisualizer(); });
                startSecInput.addEventListener('input', () => { clonedLayer.startTimeSeconds = parseInt(startSecInput.value) || 0; drawVisualizer(); });
                endMinInput.addEventListener('input', () => { clonedLayer.endTimeMinutes = parseInt(endMinInput.value) || 0; drawVisualizer(); });
                endSecInput.addEventListener('input', () => { clonedLayer.endTimeSeconds = parseInt(endSecInput.value) || 0; drawVisualizer(); });
                removeBtn.addEventListener('click', () => { removeVideoLayer(clonedLayer.id); });
                copyBtn.addEventListener('click', () => { copyVideoLayer(clonedLayer.id); });

                videoLayersContainer.appendChild(videoLayerDiv);
                videoLayers.push(clonedLayer); // Add to data array
                drawVisualizer();
                showMessage('វីដេអូត្រូវបានចម្លង។', false, true);
            } else {
                showMessage('មិនអាចរកឃើញស្រទាប់វីដេអូដើម្បីចម្លងបានទេ។', true);
            }
        }

        function moveVideoLayerToTop(idToMove) {
            const index = videoLayers.findIndex(layer => layer.id === idToMove);
            if (index > -1) {
                const [movedLayer] = videoLayers.splice(index, 1);
                videoLayers.push(movedLayer);
                drawVisualizer(); // Redraw to reflect new order
            }
        }

        function removeVideoLayer(idToRemove) {
            const elementToRemove = videoLayersContainer.querySelector(`[data-id="${idToRemove}"]`);
            if (elementToRemove) {
                const foundIndex = videoLayers.findIndex(layer => layer.id === idToRemove);
                if (foundIndex > -1) {
                    // Pause and reset the video element before removing
                    if (videoLayers[foundIndex].video) {
                        videoLayers[foundIndex].video.pause();
                        videoLayers[foundIndex].video.removeAttribute('src');
                        videoLayers[foundIndex].video.load();
                    }
                    videoLayers.splice(foundIndex, 1);
                }
                elementToRemove.remove();
                showMessage('វីដេអូត្រូវបានលុប។', false, true);
                drawVisualizer();
            }
        }

        addVideoLayerBtn.addEventListener('click', () => {
            createAndAddVideoLayer();
        });

    </script>
</body>
</html>
