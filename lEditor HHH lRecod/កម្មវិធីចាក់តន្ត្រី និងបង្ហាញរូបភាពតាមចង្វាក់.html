<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>កម្មវិធីចាក់តន្ត្រី និងបង្ហាញរូបភាពតាមចង្វាក់</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            padding: 2.5rem; /* Increased padding */
            width: 90%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }
        .canvas-container {
            width: 100%;
            max-width: 600px; /* Max width for the visualizer */
            background-color: #1a202c;
            border-radius: 0.75rem;
            border: 2px solid #4a5568;
            position: relative; /* For aspect ratio padding trick */
            overflow: hidden;
        }
        /* Aspect ratio classes */
        .aspect-ratio-16-9 { padding-bottom: 56.25%; /* 9 / 16 * 100 */ }
        .aspect-ratio-9-16 { padding-bottom: 177.77%; /* 16 / 9 * 100 */ }
        .aspect-ratio-1-1 { padding-bottom: 100%; }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            width: 100%;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
        .btn {
            background-color: #4299e1; /* Blue button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            font-weight: bold;
            border: none;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .btn:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-red {
            background-color: #e53e3e; /* Red button for recording */
        }
        .btn-red:hover {
            background-color: #c53030;
        }
        .btn-green {
            background-color: #38a169; /* Green button for stopping */
        }
        .btn-green:hover {
            background-color: #2f855a;
        }
        .volume-slider, .aspect-ratio-select, .image-size-slider, .visualizer-type-select, .visualizer-intensity-slider, .seek-slider,
        .canvas-filter-select, .text-color-input, .text-size-input, .text-position-select, .background-size-slider, .logo-position-select,
        .background-motion-type-select, .background-motion-speed-slider, .font-url-input, .font-select {
            width: 150px;
            -webkit-appearance: none;
            height: 8px;
            background: #4a5568;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
            padding: 0.5rem; /* Add padding for select */
            border: none;
            color: #e2e8f0;
        }
        .volume-slider:hover, .aspect-ratio-select:hover, .image-size-slider:hover, .visualizer-type-select:hover, .visualizer-intensity-slider:hover, .seek-slider:hover,
        .canvas-filter-select:hover, .text-color-input:hover, .text-size-input:hover, .text-position-select:hover, .background-size-slider:hover, .logo-position-select:hover,
        .background-motion-type-select:hover, .background-motion-speed-slider:hover, .font-url-input:hover, .font-select:hover {
            opacity: 1;
        }
        .volume-slider::-webkit-slider-thumb, .image-size-slider::-webkit-slider-thumb, .visualizer-intensity-slider::-webkit-slider-thumb, .seek-slider::-webkit-slider-thumb, .background-size-slider::-webkit-slider-thumb, .background-motion-speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
        .volume-slider::-moz-range-thumb, .image-size-slider::-moz-range-thumb, .visualizer-intensity-slider::-moz-range-thumb, .seek-slider::-moz-range-thumb, .background-size-slider::-moz-range-thumb, .background-motion-speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
        .aspect-ratio-select, .visualizer-type-select, .canvas-filter-select, .text-position-select, .logo-position-select, .background-motion-type-select, .font-select {
            background-color: #4a5568;
            cursor: pointer;
            width: auto; /* Adjust width based on content */
        }
        .text-color-input {
            height: 38px; /* Match height of select/slider */
            padding: 0.25rem;
            width: 80px; /* Adjust width for color picker */
        }
        .text-size-input {
            width: 100px;
        }
        .text-input, .font-url-input {
            background-color: #4a5568;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            width: 100%;
            max-width: 250px;
        }
        .seek-slider {
            width: 100%; /* Make seek slider full width */
            margin-top: 1rem;
        }
        .time-display {
            font-size: 0.9rem;
            color: #a0aec0;
            margin-top: 0.5rem;
            width: 100%;
            text-align: center;
        }
        .image-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 0.5rem;
            object-fit: contain;
            border: 2px solid #4a5568;
            display: none; /* Hidden by default */
        }
        .message-box {
            background-color: #38a169; /* Green for success */
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            text-align: center;
            display: none; /* Hidden by default */
            width: 100%;
        }
        .message-box.error {
            background-color: #e53e3e; /* Red for error */
        }
        .message-box.info {
            background-color: #4299e1; /* Blue for info */
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-4">កម្មវិធីចាក់តន្ត្រី និងបង្ហាញរូបភាពតាមចង្វាក់</h1>

        <div id="messageBox" class="message-box"></div>

        <div class="controls">
            <div class="file-input-wrapper">
                <button class="btn">ជ្រើសរើសឯកសារតន្ត្រី</button>
                <input type="file" id="audioFile" accept="audio/*">
            </div>
            <div class="file-input-wrapper">
                <button class="btn">ជ្រើសរើសរូបភាព</button>
                <input type="file" id="imageFile" accept="image/*">
            </div>
            <div class="file-input-wrapper">
                <button class="btn">ផ្ទៃខាងក្រោយ</button>
                <input type="file" id="backgroundFile" accept="image/*">
            </div>
            <div class="file-input-wrapper">
                <button class="btn">ជ្រើសរើស Logo</button>
                <input type="file" id="logoFile" accept="image/*">
            </div>
            <button id="playPauseBtn" class="btn">ចាក់/ផ្អាក</button>
            <div class="control-group">
                <label for="volumeSlider" class="text-sm">កម្រិតសំឡេង:</label>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.7" class="volume-slider">
            </div>
        </div>

        <div class="controls mt-4">
            <div class="control-group">
                <label for="aspectRatioSelect" class="text-sm">ទំហំបង្ហាញ:</label>
                <select id="aspectRatioSelect" class="aspect-ratio-select">
                    <option value="16-9">YouTube (16:9)</option>
                    <option value="9-16">TikTok/Reels (9:16)</option>
                    <option value="1-1">Instagram (1:1)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="imageSizeSlider" class="text-sm">ទំហំរូបភាព:</label>
                <input type="range" id="imageSizeSlider" min="0.1" max="2.0" step="0.05" value="1.0" class="image-size-slider">
                <div class="checkbox-group">
                    <input type="checkbox" id="autoImageSizeCheckbox" checked>
                    <label for="autoImageSizeCheckbox" class="text-sm">ស្វ័យប្រវត្តិ</label>
                </div>
            </div>
            <div class="control-group">
                <label for="visualizerTypeSelect" class="text-sm">ប្រភេទចលនា:</label>
                <select id="visualizerTypeSelect" class="visualizer-type-select">
                    <option value="image-bars">រូបភាព + របារ</option>
                    <option value="image-only">រូបភាពតែប៉ុណ្ណោះ</option>
                    <option value="bars-only">របារតែប៉ុណ្ណោះ</option>
                    <option value="circle-pulse">រង្វង់លោត</option>
                    <option value="wave">រលក</option>
                    <option value="radial-bars">របាររង្វង់</option>
                    <option value="particle-swarm">ហ្វូងភាគល្អិត</option>
                    <option value="line-spectrum">បន្ទាត់វិសាលគម</option>
                    <option value="frequency-circle">រង្វង់ប្រេកង់</option>
                    <option value="falling-particles">ភាគល្អិតធ្លាក់</option>
                    <option value="connecting-lines">បន្ទាត់តភ្ជាប់</option>
                    <option value="off">បិទចលនា</option>
                </select>
            </div>
            <div class="control-group">
                <label for="visualizerIntensitySlider" class="text-sm">កម្រិតចលនា:</label>
                <input type="range" id="visualizerIntensitySlider" min="0.0" max="2.0" step="0.1" value="1.0" class="visualizer-intensity-slider">
            </div>
        </div>

        <div class="w-full flex flex-col items-center">
            <input type="range" id="seekSlider" min="0" max="0" value="0" step="0.01" class="seek-slider">
            <div id="timeDisplay" class="time-display">0:00 / 0:00</div>
        </div>

        <div class="controls mt-4">
            <div class="control-group">
                <label for="backgroundSizeSlider" class="text-sm">ទំហំផ្ទៃខាងក្រោយ:</label>
                <input type="range" id="backgroundSizeSlider" min="0.1" max="2.0" step="0.05" value="1.0" class="background-size-slider">
                <div class="checkbox-group">
                    <input type="checkbox" id="autoBackgroundSizeCheckbox" checked>
                    <label for="autoBackgroundSizeCheckbox" class="text-sm">ស្វ័យប្រវត្តិ</label>
                </div>
            </div>
            <div class="control-group">
                <label for="backgroundMotionTypeSelect" class="text-sm">ចលនាផ្ទៃខាងក្រោយ:</label>
                <select id="backgroundMotionTypeSelect" class="background-motion-type-select">
                    <option value="none">គ្មាន</option>
                    <option value="zoom">ពង្រីក/បង្រួម</option>
                    <option value="pan-horizontal">រំកិលផ្ដេក</option>
                    <option value="pan-vertical">រំកិលបញ្ឈរ</option>
                    <option value="rotate">បង្វិល</option>
                </select>
            </div>
            <div class="control-group">
                <label for="backgroundMotionSpeedSlider" class="text-sm">ល្បឿនចលនាផ្ទៃខាងក្រោយ:</label>
                <input type="range" id="backgroundMotionSpeedSlider" min="0.0" max="1.0" step="0.05" value="0.5" class="background-motion-speed-slider">
            </div>
            <div class="control-group">
                <label for="canvasFilterSelect" class="text-sm">តម្រងរូបភាព:</label>
                <select id="canvasFilterSelect" class="canvas-filter-select">
                    <option value="none">គ្មាន</option>
                    <option value="grayscale(100%)">សខ្មៅ</option>
                    <option value="sepia(100%)">សេពៀ</option>
                    <option value="invert(100%)">បញ្ច្រាសពណ៌</option>
                    <option value="blur(5px)">ព្រិល</option>
                </select>
            </div>
            <div class="control-group">
                <label for="customTextInput" class="text-sm">អត្ថបទផ្ទាល់ខ្លួន:</label>
                <input type="text" id="customTextInput" class="text-input" placeholder="បញ្ចូលអត្ថបទ...">
                <div class="flex gap-2">
                    <input type="color" id="textColorInput" value="#ffffff" class="text-color-input">
                    <input type="number" id="textSizeInput" min="10" max="100" value="30" class="text-size-input">
                    <select id="textPositionSelect" class="text-position-select">
                        <option value="bottom-center">ក្រោម-កណ្តាល</option>
                        <option value="top-left">លើ-ឆ្វេង</option>
                        <option value="top-right">លើ-ស្តាំ</option>
                        <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                        <option value="bottom-right">ក្រោម-ស្តាំ</option>
                        <option value="center">កណ្តាល</option>
                    </select>
                </div>
            </div>
            <div class="control-group">
                <label for="logoPositionSelect" class="text-sm">ទីតាំង Logo:</label>
                <select id="logoPositionSelect" class="logo-position-select">
                    <option value="top-left">លើ-ឆ្វេង</option>
                    <option value="top-right">លើ-ស្តាំ</option>
                    <option value="bottom-left">ក្រោម-ឆ្វេង</option>
                    <option value="bottom-right">ក្រោម-ស្តាំ</option>
                    <option value="center">កណ្តាល</option>
                </select>
            </div>
            <div class="control-group">
                <label for="fontUrlInput" class="text-sm">ផ្ទុក Font ពី URL (Google Fonts):</label>
                <input type="text" id="fontUrlInput" class="font-url-input" placeholder="ឧ. https://fonts.googleapis.com/css2?family=Noto+Sans+Khmer&display=swap">
                <button id="loadFontUrlBtn" class="btn">ផ្ទុក Font URL</button>
            </div>
            <div class="control-group">
                <label for="fontFileInput" class="text-sm">ផ្ទុក Font ពីឧបករណ៍ (.ttf, .otf, .woff):</label>
                <input type="file" id="fontFileInput" accept=".ttf,.otf,.woff,.woff2">
                <input type="text" id="customFontNameInput" class="text-input" placeholder="ឈ្មោះ Font (ឧ. MyCustomFont)">
                <button id="loadFontFileBtn" class="btn">ផ្ទុក Font ឯកសារ</button>
            </div>
            <div class="control-group">
                <label for="fontSelect" class="text-sm">ជ្រើសរើស Font:</label>
                <select id="fontSelect" class="font-select">
                    <option value="Inter, sans-serif">Inter (លំនាំដើម)</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="Verdana, sans-serif">Verdana</option>
                    <option value="Times New Roman, serif">Times New Roman</option>
                </select>
            </div>
        </div>

        <div class="controls mt-4">
            <button id="fullscreenBtn" class="btn">ពេញអេក្រង់</button>
            <button id="startRecordBtn" class="btn btn-red">ចាប់ផ្តើមថត</button>
            <button id="stopRecordBtn" class="btn btn-green" disabled>បញ្ឈប់ការថត</button>
            <a id="downloadVideoLink" class="btn hidden" download="visualizer_video.webm">ទាញយកវីដេអូ</a>
        </div>

        <img id="imagePreview" class="image-preview" alt="រូបភាពដែលបានជ្រើសរើស">

        <div id="canvasContainer" class="canvas-container aspect-ratio-16-9">
            <canvas id="visualizerCanvas"></canvas>
        </div>

        <audio id="audioPlayer" controls class="hidden"></audio>
    </div>

    <script>
        // Get DOM elements
        const audioFile = document.getElementById('audioFile');
        const imageFile = document.getElementById('imageFile');
        const backgroundFile = document.getElementById('backgroundFile');
        const logoFile = document.getElementById('logoFile');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const audioPlayer = document.getElementById('audioPlayer');
        const visualizerCanvas = document.getElementById('visualizerCanvas');
        const imagePreview = document.getElementById('imagePreview');
        const messageBox = document.getElementById('messageBox');
        const aspectRatioSelect = document.getElementById('aspectRatioSelect');
        const canvasContainer = document.getElementById('canvasContainer');
        const startRecordBtn = document.getElementById('startRecordBtn');
        const stopRecordBtn = document.getElementById('stopRecordBtn');
        const downloadVideoLink = document.getElementById('downloadVideoLink');
        const imageSizeSlider = document.getElementById('imageSizeSlider');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const visualizerTypeSelect = document.getElementById('visualizerTypeSelect');
        const visualizerIntensitySlider = document.getElementById('visualizerIntensitySlider');
        const seekSlider = document.getElementById('seekSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const autoImageSizeCheckbox = document.getElementById('autoImageSizeCheckbox');
        const autoBackgroundSizeCheckbox = document.getElementById('autoBackgroundSizeCheckbox');
        const canvasFilterSelect = document.getElementById('canvasFilterSelect');
        const customTextInput = document.getElementById('customTextInput');
        const textColorInput = document.getElementById('textColorInput');
        const textSizeInput = document.getElementById('textSizeInput');
        const textPositionSelect = document.getElementById('textPositionSelect');
        const backgroundSizeSlider = document.getElementById('backgroundSizeSlider');
        const logoPositionSelect = document.getElementById('logoPositionSelect');
        const backgroundMotionTypeSelect = document.getElementById('backgroundMotionTypeSelect');
        const backgroundMotionSpeedSlider = document.getElementById('backgroundMotionSpeedSlider');
        const fontUrlInput = document.getElementById('fontUrlInput');
        const loadFontUrlBtn = document.getElementById('loadFontUrlBtn');
        const fontFileInput = document.getElementById('fontFileInput');
        const customFontNameInput = document.getElementById('customFontNameInput');
        const loadFontFileBtn = document.getElementById('loadFontFileBtn');
        const fontSelect = document.getElementById('fontSelect');

        // Canvas context
        const ctx = visualizerCanvas.getContext('2d');

        // Audio context and analyser
        let audioContext;
        let analyser;
        let source;
        let bufferLength;
        let dataArray;
        let animationFrameId;
        let audioDestinationNode;

        // Image objects
        let img = new Image();
        let isImageLoaded = false;
        let bgImg = new Image();
        let isBgImageLoaded = false;
        let logoImg = new Image();
        let isLogoLoaded = false;

        // Media Recorder variables
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        // Global variable for background pan/rotate animation
        let backgroundPanOffset = { x: 0, y: 0 };
        let backgroundRotation = 0;
        let lastFrameTime = 0;

        // For falling particles visualizer
        const particles = [];
        const maxFallingParticles = 100;
        class Particle {
            constructor(canvasWidth, canvasHeight, size, color) {
                this.x = Math.random() * canvasWidth;
                this.y = Math.random() * canvasHeight;
                this.size = size;
                this.color = color;
                this.speedY = 0;
            }

            update(speedFactor) {
                this.y += this.speedY * speedFactor;
                if (this.y > visualizerCanvas.height) {
                    this.y = 0;
                    this.x = Math.random() * visualizerCanvas.width;
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }


        // Function to format time (e.g., 150 seconds -> 2:30)
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        // Function to show messages
        function showMessage(message, isError = false, isInfo = false) {
            messageBox.textContent = message;
            messageBox.className = 'message-box'; // Reset classes
            if (isError) {
                messageBox.classList.add('error');
            } else if (isInfo) {
                messageBox.classList.add('info');
            } else {
                messageBox.classList.add('success'); // Default for success
            }
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 3000); // Hide after 3 seconds
        }

        // Initialize AudioContext when user interacts
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256; // Fast Fourier Transform size
                bufferLength = analyser.frequencyBinCount; // Number of data points
                dataArray = new Uint8Array(bufferLength); // Array to hold frequency data

                // Connect audio player to analyser
                source = audioContext.createMediaElementSource(audioPlayer);
                source.connect(analyser);
                analyser.connect(audioContext.destination); // Connect analyser to speakers
            }
        }

        // Function to load font from URL (e.g., Google Fonts)
        async function loadFontFromUrl(url) {
            if (!url) {
                showMessage('សូមបញ្ចូល URL Font ឱ្យបានត្រឹមត្រូវ។', true);
                return;
            }
            try {
                // Check if the font is already loaded or being loaded
                const existingLink = document.querySelector(`link[href="${url}"]`);
                if (existingLink) {
                    showMessage('Font នេះត្រូវបានផ្ទុកពីមុនមកហើយ។', false, true);
                    return;
                }

                const link = document.createElement('link');
                link.href = url;
                link.rel = 'stylesheet';
                document.head.appendChild(link);

                // Attempt to get font family name from Google Fonts URL
                const match = url.match(/family=([^&:]+)/);
                let fontName = 'Unknown Font';
                if (match && match[1]) {
                    fontName = decodeURIComponent(match[1].replace(/\+/g, ' '));
                }

                // Wait for the font to be loaded
                await document.fonts.load(`1em "${fontName}"`);
                const newOption = new Option(fontName, fontName);
                fontSelect.add(newOption);
                fontSelect.value = fontName; // Select the newly loaded font
                showMessage(`Font "${fontName}" ត្រូវបានផ្ទុកដោយជោគជ័យពី URL។`);
                drawVisualizer(); // Redraw with new font
            } catch (error) {
                showMessage(`បរាជ័យក្នុងការផ្ទុក Font ពី URL: ${error.message}`, true);
                console.error('Font loading error:', error);
            }
        }

        // Function to load font from local file
        async function loadFontFromFile(file, fontName) {
            if (!file) {
                showMessage('សូមជ្រើសរើសឯកសារ Font។', true);
                return;
            }
            if (!fontName || fontName.trim() === '') {
                showMessage('សូមបញ្ចូលឈ្មោះសម្រាប់ Font ផ្ទាល់ខ្លួន។', true);
                return;
            }
            try {
                const font = new FontFace(fontName, `url(${URL.createObjectURL(file)})`);
                await font.load();
                document.fonts.add(font);
                const newOption = new Option(fontName, fontName);
                fontSelect.add(newOption);
                fontSelect.value = fontName; // Select the newly loaded font
                showMessage(`Font "${fontName}" ត្រូវបានផ្ទុកដោយជោគជ័យពីឯកសារ។`);
                drawVisualizer(); // Redraw with new font
            } catch (error) {
                showMessage(`បរាជ័យក្នុងការផ្ទុក Font ពីឯកសារ: ${error.message}`, true);
                console.error('Font loading error:', error);
            }
        }


        // Handle audio file selection
        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                audioPlayer.src = fileURL;
                audioPlayer.load(); // Load the audio
                showMessage(`ឯកសារតន្ត្រី "${file.name}" ត្រូវបានផ្ទុក។`);
                initAudioContext(); // Initialize audio context on file load
                playPauseBtn.textContent = 'ចាក់'; // Reset button text
                if (audioContext.state === 'suspended') {
                    audioContext.resume(); // Resume context if it was suspended
                }
                downloadVideoLink.classList.add('hidden'); // Hide download link on new audio
            } else {
                showMessage('សូមជ្រើសរើសឯកសារតន្ត្រី។', true);
            }
        });

        // Update seek slider max and time display when audio metadata is loaded
        audioPlayer.addEventListener('loadedmetadata', () => {
            seekSlider.max = audioPlayer.duration;
            timeDisplay.textContent = `0:00 / ${formatTime(audioPlayer.duration)}`;
        });

        // Update seek slider and time display as audio plays
        audioPlayer.addEventListener('timeupdate', () => {
            if (!seekSlider.dragging) { // Only update if user isn't dragging the slider
                seekSlider.value = audioPlayer.currentTime;
            }
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
        });

        // Seek slider functionality
        seekSlider.addEventListener('input', () => {
            audioPlayer.currentTime = seekSlider.value;
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
        });

        // Handle image file selection
        imageFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    img.src = e.target.result;
                    img.onload = () => {
                        isImageLoaded = true;
                        imagePreview.src = img.src;
                        imagePreview.style.display = 'block'; // Show image preview
                        showMessage(`រូបភាព "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer(); // Redraw canvas with new image
                    };
                    img.onerror = () => {
                        isImageLoaded = false;
                        showMessage('មិនអាចផ្ទុករូបភាពបានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសរូបភាព។', true);
            }
        });

        // Handle background file selection
        backgroundFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    bgImg.src = e.target.result;
                    bgImg.onload = () => {
                        isBgImageLoaded = true;
                        showMessage(`រូបភាពផ្ទៃខាងក្រោយ "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer(); // Redraw canvas with new background
                    };
                    bgImg.onerror = () => {
                        isBgImageLoaded = false;
                        showMessage('មិនអាចផ្ទុករូបភាពផ្ទៃខាងក្រោយបានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសរូបភាពផ្ទៃខាងក្រោយ។', true);
            }
        });

        // Handle logo file selection
        logoFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    logoImg.src = e.target.result;
                    logoImg.onload = () => {
                        isLogoLoaded = true;
                        showMessage(`ឯកសារ Logo "${file.name}" ត្រូវបានផ្ទុក។`);
                        drawVisualizer(); // Redraw canvas with new logo
                    };
                    logoImg.onerror = () => {
                        isLogoLoaded = false;
                        showMessage('មិនអាចផ្ទុក Logo បានទេ។', true);
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Logo។', true);
            }
        });

        // Play/Pause button functionality
        playPauseBtn.addEventListener('click', () => {
            if (!audioPlayer.src) {
                showMessage('សូមផ្ទុកឯកសារតន្ត្រីជាមុនសិន។', true);
                return;
            }

            initAudioContext(); // Ensure context is initialized and resumed

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    if (audioPlayer.paused) {
                        audioPlayer.play();
                        playPauseBtn.textContent = 'ផ្អាក';
                        drawVisualizer(); // Start visualization
                    } else {
                        audioPlayer.pause();
                        playPauseBtn.textContent = 'ចាក់';
                        cancelAnimationFrame(animationFrameId); // Stop visualization
                    }
                }).catch(e => showMessage(`បរាជ័យក្នុងការបន្ត AudioContext: ${e.message}`, true));
            } else {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                    playPauseBtn.textContent = 'ផ្អាក';
                    drawVisualizer(); // Start visualization
                } else {
                    audioPlayer.pause();
                    playPauseBtn.textContent = 'ចាក់';
                    cancelAnimationFrame(animationFrameId); // Stop visualization
                }
            }
        });

        // Volume control
        volumeSlider.addEventListener('input', () => {
            audioPlayer.volume = volumeSlider.value;
        });

        // Image Size control
        imageSizeSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new image size
        });

        // Auto Image Size checkbox control
        autoImageSizeCheckbox.addEventListener('change', () => {
            imageSizeSlider.disabled = autoImageSizeCheckbox.checked;
            drawVisualizer(); // Redraw canvas with new image sizing mode
        });

        // Background Size control
        backgroundSizeSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new background size
        });

        // Auto Background Size checkbox control
        autoBackgroundSizeCheckbox.addEventListener('change', () => {
            backgroundSizeSlider.disabled = autoBackgroundSizeCheckbox.checked;
            drawVisualizer(); // Redraw canvas with new background sizing mode
        });

        // Background Motion Type control
        backgroundMotionTypeSelect.addEventListener('change', () => {
            // Reset motion state when type changes
            backgroundPanOffset = { x: 0, y: 0 };
            backgroundRotation = 0;
            drawVisualizer(); // Redraw canvas with new motion type
            showMessage(`ចលនាផ្ទៃខាងក្រោយត្រូវបានផ្លាស់ប្តូរទៅជា "${backgroundMotionTypeSelect.options[backgroundMotionTypeSelect.selectedIndex].text}"។`, false, true);
        });

        // Background Motion Speed control
        backgroundMotionSpeedSlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new motion speed
        });

        // Visualizer Intensity control
        visualizerIntensitySlider.addEventListener('input', () => {
            drawVisualizer(); // Redraw canvas with new intensity
        });

        // Aspect Ratio selection
        aspectRatioSelect.addEventListener('change', (event) => {
            const selectedRatio = event.target.value;
            // Remove existing aspect ratio classes
            canvasContainer.classList.remove('aspect-ratio-16-9', 'aspect-ratio-9-16', 'aspect-ratio-1-1');
            // Add the selected aspect ratio class
            canvasContainer.classList.add(`aspect-ratio-${selectedRatio}`);
            // Recalculate canvas size and redraw
            updateCanvasSize();
            showMessage(`ទំហំបង្ហាញត្រូវបានផ្លាស់ប្តូរទៅ ${selectedRatio.replace('-', ':')}។`, false, true);
        });

        // Visualizer Type selection
        visualizerTypeSelect.addEventListener('change', () => {
            // Reset particles for falling particles visualizer when changing type
            if (visualizerTypeSelect.value === 'falling-particles') {
                particles.length = 0; // Clear existing particles
            }
            drawVisualizer(); // Redraw canvas with new visualizer type
            showMessage(`ប្រភេទចលនាត្រូវបានផ្លាស់ប្តូរទៅជា "${visualizerTypeSelect.options[visualizerTypeSelect.selectedIndex].text}"។`, false, true);
        });

        // Canvas Filter selection
        canvasFilterSelect.addEventListener('change', () => {
            drawVisualizer(); // Redraw canvas with new filter
            showMessage(`តម្រងរូបភាពត្រូវបានផ្លាស់ប្តូរទៅជា "${canvasFilterSelect.options[canvasFilterSelect.selectedIndex].text}"។`, false, true);
        });

        // Custom Text input/controls
        customTextInput.addEventListener('input', drawVisualizer);
        textColorInput.addEventListener('input', drawVisualizer);
        textSizeInput.addEventListener('input', drawVisualizer);
        textPositionSelect.addEventListener('change', drawVisualizer);

        // Logo Position selection
        logoPositionSelect.addEventListener('change', drawVisualizer);

        // Font URL loading
        loadFontUrlBtn.addEventListener('click', () => {
            loadFontFromUrl(fontUrlInput.value);
        });

        // Font File loading
        loadFontFileBtn.addEventListener('click', () => {
            if (fontFileInput.files.length > 0) {
                loadFontFromFile(fontFileInput.files[0], customFontNameInput.value);
            } else {
                showMessage('សូមជ្រើសរើសឯកសារ Font ដើម្បីផ្ទុក។', true);
            }
        });

        // Font selection change
        fontSelect.addEventListener('change', drawVisualizer);


        // Fullscreen functionality
        fullscreenBtn.addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
                showMessage('ចេញពីរបៀបពេញអេក្រង់។', false, true);
            } else {
                // Request fullscreen for the canvas container to make the visualizer area fullscreen
                canvasContainer.requestFullscreen().then(() => {
                    showMessage('ចូលទៅរបៀបពេញអេក្រង់។', false, true);
                }).catch(err => {
                    showMessage(`មិនអាចចូលទៅរបៀបពេញអេក្រង់បានទេ: ${err.message}`, true);
                });
            }
        });

        // Update button text and canvas size on fullscreen change
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                fullscreenBtn.textContent = 'ចេញពីពេញអេក្រង់';
            } else {
                fullscreenBtn.textContent = 'ពេញអេក្រង់';
            }
            updateCanvasSize(); // Update canvas size after fullscreen change
        });


        // Function to update canvas size based on its container
        function updateCanvasSize() {
            visualizerCanvas.width = visualizerCanvas.offsetWidth;
            visualizerCanvas.height = visualizerCanvas.offsetHeight;
            drawVisualizer(); // Redraw content after resizing
        }

        // Visualization drawing function
        function drawVisualizer(currentTime) {
            // Request next frame
            animationFrameId = requestAnimationFrame(drawVisualizer);

            // Calculate delta time for smooth animation
            if (!lastFrameTime) lastFrameTime = currentTime;
            const deltaTime = (currentTime - lastFrameTime) / 1000; // in seconds
            lastFrameTime = currentTime;

            if (!analyser || !dataArray) {
                return; // Ensure analyser is initialized
            }

            analyser.getByteFrequencyData(dataArray); // Get frequency data

            const canvasWidth = visualizerCanvas.width;
            const canvasHeight = visualizerCanvas.height;

            // Apply canvas filter first (affects everything drawn after)
            ctx.filter = canvasFilterSelect.value;

            // Clear canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Draw background image if loaded
            if (isBgImageLoaded) {
                ctx.save(); // Save context before transforming background

                const motionType = backgroundMotionTypeSelect.value;
                const motionSpeed = parseFloat(backgroundMotionSpeedSlider.value);

                // Calculate common audio properties (average amplitude) for background motion
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                let average = sum / bufferLength;
                let activeMusicScaleFactor = 1 + ((average / 255) * 0.4 * parseFloat(visualizerIntensitySlider.value));

                let drawWidth, drawHeight, drawX, drawY;

                if (autoBackgroundSizeCheckbox.checked) {
                    // "Cover" behavior for background (auto)
                    const imgAspectRatio = bgImg.width / bgImg.height;
                    const canvasAspectRatio = canvasWidth / canvasHeight;

                    let sx = 0, sy = 0, sWidth = bgImg.width, sHeight = bgImg.height;
                    let dx = 0, dy = 0, dWidth = canvasWidth, dHeight = canvasHeight;

                    if (imgAspectRatio > canvasAspectRatio) {
                        // Image is wider than canvas, need to crop width
                        sWidth = bgImg.height * canvasAspectRatio;
                        sx = (bgImg.width - sWidth) / 2;
                    } else {
                        // Image is taller than canvas, need to crop height
                        sHeight = bgImg.width / canvasAspectRatio;
                        sy = (bgImg.height - sHeight) / 2;
                    }

                    drawWidth = dWidth;
                    drawHeight = dHeight;
                    drawX = dx;
                    drawY = dy;

                    // Apply zoom motion
                    if (motionType === 'zoom') {
                        const zoomFactor = 1 + (activeMusicScaleFactor - 1) * motionSpeed * 2; // More pronounced zoom
                        drawWidth *= zoomFactor;
                        drawHeight *= zoomFactor;
                        drawX = (canvasWidth - drawWidth) / 2;
                        drawY = (canvasHeight - drawHeight) / 2;
                    }

                    // Apply transformations for pan/rotate
                    if (motionType === 'pan-horizontal') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor; // Pixels per second
                        backgroundPanOffset.x = (backgroundPanOffset.x + panSpeed * deltaTime) % drawWidth;
                        ctx.translate(backgroundPanOffset.x, 0);
                    } else if (motionType === 'pan-vertical') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor; // Pixels per second
                        backgroundPanOffset.y = (backgroundPanOffset.y + panSpeed * deltaTime) % drawHeight;
                        ctx.translate(0, backgroundPanOffset.y);
                    } else if (motionType === 'rotate') {
                        const rotationSpeed = Math.PI / 4 * motionSpeed * activeMusicScaleFactor; // Radians per second
                        backgroundRotation = (backgroundRotation + rotationSpeed * deltaTime) % (Math.PI * 2);
                        ctx.translate(canvasWidth / 2, canvasHeight / 2);
                        ctx.rotate(backgroundRotation);
                        ctx.translate(-canvasWidth / 2, -canvasHeight / 2);
                    }

                    ctx.drawImage(bgImg, sx, sy, sWidth, sHeight, drawX, drawY, drawWidth, drawHeight);

                } else {
                    // Manual size control with slider
                    const backgroundScale = parseFloat(backgroundSizeSlider.value);
                    let initialDrawWidth = bgImg.width * backgroundScale;
                    let initialDrawHeight = bgImg.height * backgroundScale;

                    // Apply zoom motion
                    if (motionType === 'zoom') {
                        const zoomFactor = 1 + (activeMusicScaleFactor - 1) * motionSpeed * 2;
                        initialDrawWidth *= zoomFactor;
                        initialDrawHeight *= zoomFactor;
                    }

                    // Center the manually scaled background
                    drawX = (canvasWidth - initialDrawWidth) / 2;
                    drawY = (canvasHeight - initialDrawHeight) / 2;

                    // Apply transformations for pan/rotate
                    if (motionType === 'pan-horizontal') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor;
                        backgroundPanOffset.x = (backgroundPanOffset.x + panSpeed * deltaTime) % initialDrawWidth;
                        ctx.translate(backgroundPanOffset.x, 0);
                    } else if (motionType === 'pan-vertical') {
                        const panSpeed = 50 * motionSpeed * activeMusicScaleFactor;
                        backgroundPanOffset.y = (backgroundPanOffset.y + panSpeed * deltaTime) % initialDrawHeight;
                        ctx.translate(0, backgroundPanOffset.y);
                    } else if (motionType === 'rotate') {
                        const rotationSpeed = Math.PI / 4 * motionSpeed * activeMusicScaleFactor;
                        backgroundRotation = (backgroundRotation + rotationSpeed * deltaTime) % (Math.PI * 2);
                        ctx.translate(canvasWidth / 2, canvasHeight / 2);
                        ctx.rotate(backgroundRotation);
                        ctx.translate(-canvasWidth / 2, -canvasHeight / 2);
                    }

                    ctx.drawImage(bgImg, drawX, drawY, initialDrawWidth, initialDrawHeight);
                }
                ctx.restore(); // Restore context after transforming background
            } else {
                // Fallback to solid background color if no image
                ctx.fillStyle = '#1a202c'; // Dark background for canvas
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }


            const visualizationType = visualizerTypeSelect.value;
            if (visualizationType === 'off') {
                // If visualization is off, just clear canvas and return
                ctx.filter = 'none'; // Reset filter
                return;
            }

            // Calculate common audio properties (average amplitude)
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            let average = sum / bufferLength;

            // Calculate averages for different frequency bands (simulating instrument/voice reaction)
            let bassSum = 0;
            for (let i = 0; i < bufferLength * 0.25; i++) { // Roughly 0-25% for bass
                bassSum += dataArray[i];
            }
            let bassAverage = bassSum / (bufferLength * 0.25);

            let midSum = 0;
            for (let i = bufferLength * 0.25; i < bufferLength * 0.75; i++) { // Roughly 25-75% for mids/vocals
                midSum += dataArray[i];
            }
            let midAverage = midSum / (bufferLength * 0.5);

            let trebleSum = 0;
            for (let i = bufferLength * 0.75; i < bufferLength; i++) { // Roughly 75-100% for treble
                trebleSum += dataArray[i];
            }
            let trebleAverage = trebleSum / (bufferLength * 0.25);


            // Base music scale factor (0.8 to 1.2) - uses overall average
            let baseMusicScaleFactor = 1 + (average / 255) * 0.4;

            // Apply intensity from slider
            const visualizerIntensity = parseFloat(visualizerIntensitySlider.value);
            let activeMusicScaleFactor = 1 + ((baseMusicScaleFactor - 1) * visualizerIntensity);
            let activeBassScaleFactor = 1 + ((bassAverage / 255) * 0.4 * visualizerIntensity);
            let activeMidScaleFactor = 1 + ((midAverage / 255) * 0.4 * visualizerIntensity);
            let activeTrebleScaleFactor = 1 + ((trebleAverage / 255) * 0.4 * visualizerIntensity);


            // Get base image scale from slider
            const baseImageScale = parseFloat(imageSizeSlider.value);

            // --- Drawing Logic based on Visualization Type ---

            // Image related drawing
            if ((visualizationType === 'image-bars' || visualizationType === 'image-only') && isImageLoaded) {
                ctx.save(); // Save current canvas state

                let initialDrawWidth, initialDrawHeight;

                if (autoImageSizeCheckbox.checked) {
                    // "Contain" behavior for main image
                    const imgAspectRatio = img.width / img.height;
                    const canvasAspectRatio = canvasWidth / canvasHeight;

                    if (imgAspectRatio > canvasAspectRatio) {
                        // Image is wider than canvas, fit by width
                        initialDrawWidth = canvasWidth;
                        initialDrawHeight = canvasWidth / imgAspectRatio;
                    } else {
                        // Image is taller than canvas, fit by height
                        initialDrawHeight = canvasHeight;
                        initialDrawWidth = canvasHeight * imgAspectRatio;
                    }
                } else {
                    // Manual size control with slider
                    initialDrawWidth = img.width * baseImageScale;
                    initialDrawHeight = img.height * baseImageScale;

                    // Ensure manual size doesn't exceed canvas dimensions if it's too large
                    const imgAspectRatio = img.width / img.height;
                    if (initialDrawWidth > canvasWidth || initialDrawHeight > canvasHeight) {
                        if (imgAspectRatio > canvasWidth / canvasHeight) {
                            initialDrawWidth = canvasWidth;
                            initialDrawHeight = canvasWidth / imgAspectRatio;
                        } else {
                            initialDrawHeight = canvasHeight;
                            initialDrawWidth = canvasHeight * imgAspectRatio;
                        }
                    }
                }

                // Apply active music scale factor to the adjusted dimensions
                let finalDrawWidth = initialDrawWidth * activeMusicScaleFactor;
                let finalDrawHeight = initialDrawHeight * activeMusicScaleFactor;

                // Ensure image doesn't get too small or too large relative to its initial size
                const minScaleLimit = 0.5; // Minimum scale relative to initial size
                const maxScaleLimit = 2.0; // Maximum scale relative to initial size

                finalDrawWidth = Math.max(initialDrawWidth * minScaleLimit, Math.min(initialDrawWidth * maxScaleLimit, finalDrawWidth));
                finalDrawHeight = Math.max(initialDrawHeight * minScaleLimit, Math.min(initialDrawHeight * maxScaleLimit, finalDrawHeight));

                ctx.translate(canvasWidth / 2, canvasHeight / 2);
                ctx.drawImage(img, -finalDrawWidth / 2, -finalDrawHeight / 2, finalDrawWidth, finalDrawHeight);

                ctx.restore(); // Restore canvas state
            }

            // Bars related drawing
            if (visualizationType === 'image-bars' || visualizationType === 'bars-only') {
                const barWidth = (canvasWidth / bufferLength) * 2.5; // Adjust bar width
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] * activeMusicScaleFactor * 1.5; // Scale height for better visibility, apply intensity

                    ctx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`; // Reddish bars
                    ctx.fillRect(x, canvasHeight - barHeight, barWidth, barHeight);

                    x += barWidth + 1; // Spacing between bars
                }
            }

            // Circle Pulse drawing (reacts to overall average)
            if (visualizationType === 'circle-pulse') {
                ctx.save();
                ctx.beginPath();
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                const baseRadius = Math.min(canvasWidth, canvasHeight) * 0.2; // Base size
                const pulseRadius = baseRadius * activeMusicScaleFactor; // Pulse with music
                ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(66, 153, 225, ${0.5 + (average / 255) * 0.5 * visualizerIntensity})`; // Blue with opacity change
                ctx.fill();
                ctx.closePath();
                ctx.restore();
            }

            // Wave visualization (reacts more to mid-range/vocals)
            if (visualizationType === 'wave') {
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = '#4299e1'; // Blue wave
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';

                const sliceWidth = canvasWidth * 1.0 / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0; // Normalize to 0-2
                    // Use midAverage to influence wave height more for vocal feel
                    const y = canvasHeight / 2 + v * (canvasHeight / 4) * activeMidScaleFactor;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                ctx.lineTo(canvasWidth, canvasHeight / 2);
                ctx.stroke();
                ctx.restore();
            }

            // Radial Bars visualization (reacts to overall average or bass)
            if (visualizationType === 'radial-bars') {
                ctx.save();
                ctx.translate(canvasWidth / 2, canvasHeight / 2); // Move origin to center
                const radius = Math.min(canvasWidth, canvasHeight) * 0.2;
                const barCount = bufferLength / 2; // Use half for a cleaner circle
                const barAngle = (Math.PI * 2) / barCount;

                for (let i = 0; i < barCount; i++) {
                    // Use bassAverage to make radial bars more reactive to low frequencies
                    const barHeight = dataArray[i] * activeBassScaleFactor * 0.8;
                    const angle = i * barAngle;

                    ctx.rotate(barAngle); // Rotate for each bar
                    ctx.fillStyle = `hsl(${i * (360 / barCount)}, 100%, 50%)`; // Hue changes around circle
                    ctx.fillRect(radius, 0, 5, -barHeight); // Draw bar from radius outwards
                }
                ctx.restore();
            }

            // Particle Swarm visualization (reacts to overall intensity)
            if (visualizationType === 'particle-swarm') {
                const particleCount = 50;
                const maxParticleSize = 5;
                const maxSpeed = 3;

                ctx.save();
                ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + (average / 255) * 0.4 * visualizerIntensity})`; // White particles, opacity based on intensity

                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = maxSpeed * activeMusicScaleFactor;
                    const size = maxParticleSize * activeMusicScaleFactor;

                    // Simple particle movement (can be more complex)
                    const x = canvasWidth / 2 + Math.cos(angle) * (average * speed);
                    const y = canvasHeight / 2 + Math.sin(angle) * (average * speed);

                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            // Line Spectrum visualization (reacts to treble/high frequencies)
            if (visualizationType === 'line-spectrum') {
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = `hsl(${trebleAverage * 1.5}, 100%, 70%)`; // Color based on treble
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                const sliceWidth = canvasWidth * 1.0 / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 255.0; // Normalize to 0-1
                    // Use trebleAverage to influence height more for high-frequency feel
                    const y = canvasHeight - (v * canvasHeight * 0.5 * activeTrebleScaleFactor);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                ctx.stroke();
                ctx.restore();
            }

            // New: Frequency Circle visualization
            if (visualizationType === 'frequency-circle') {
                ctx.save();
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                const maxRadius = Math.min(canvasWidth, canvasHeight) * 0.4;

                for (let i = 0; i < bufferLength; i++) {
                    const value = dataArray[i];
                    const radius = maxRadius * (value / 255) * activeMusicScaleFactor;
                    const hue = i * 360 / bufferLength;

                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.restore();
            }

            // New: Falling Particles visualization
            if (visualizationType === 'falling-particles') {
                if (particles.length === 0) {
                    for (let i = 0; i < maxFallingParticles; i++) {
                        particles.push(new Particle(canvasWidth, canvasHeight, Math.random() * 3 + 1, `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`));
                    }
                }

                const particleSpeedFactor = (average / 255) * 5 * visualizerIntensity; // Speed influenced by music intensity

                for (let i = 0; i < particles.length; i++) {
                    particles[i].speedY = (dataArray[Math.floor(i / particles.length * bufferLength)] / 255) * 10 * visualizerIntensity + 1; // Individual speed by frequency
                    particles[i].update(particleSpeedFactor);
                    particles[i].draw(ctx);
                }
            } else {
                particles.length = 0; // Clear particles if not in this mode
            }

            // New: Connecting Lines visualization
            if (visualizationType === 'connecting-lines') {
                ctx.save();
                ctx.strokeStyle = `rgba(66, 153, 225, ${0.5 + (average / 255) * 0.5 * visualizerIntensity})`; // Blueish, opacity by intensity
                ctx.lineWidth = 1;

                const sliceWidth = canvasWidth * 1.0 / bufferLength;
                const points = [];

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 255.0;
                    const x = i * sliceWidth;
                    const y = canvasHeight / 2 + (v - 0.5) * canvasHeight * 0.4 * activeMusicScaleFactor; // Center around middle
                    points.push({ x, y });
                }

                for (let i = 0; i < points.length; i++) {
                    for (let j = i + 1; j < points.length; j++) {
                        const dist = Math.sqrt(Math.pow(points[i].x - points[j].x, 2) + Math.pow(points[i].y - points[j].y, 2));
                        if (dist < 150) { // Only connect points that are close enough
                            ctx.beginPath();
                            ctx.moveTo(points[i].x, points[i].y);
                            ctx.lineTo(points[j].x, points[j].y);
                            ctx.stroke();
                        }
                    }
                }
                ctx.restore();
            }


            // --- Draw Logo (on top of visualizer) ---
            if (isLogoLoaded) {
                ctx.save();
                const logoSize = 50; // Fixed size for logo
                const padding = 10;
                let logoX, logoY;

                switch (logoPositionSelect.value) {
                    case 'top-left':
                        logoX = padding;
                        logoY = padding;
                        break;
                    case 'top-right':
                        logoX = canvasWidth - logoSize - padding;
                        logoY = padding;
                        break;
                    case 'bottom-left':
                        logoX = padding;
                        logoY = canvasHeight - logoSize - padding;
                        break;
                    case 'bottom-right':
                        logoX = canvasWidth - logoSize - padding;
                        logoY = canvasHeight - logoSize - padding;
                        break;
                    case 'center':
                        logoX = (canvasWidth - logoSize) / 2;
                        logoY = (canvasHeight - logoSize) / 2;
                        break;
                    default: // Default to top-left if somehow value is not found
                        logoX = padding;
                        logoY = padding;
                        break;
                }
                ctx.drawImage(logoImg, logoX, logoY, logoSize, logoSize);
                ctx.restore();
            }

            // --- Draw Custom Text (on top of everything) ---
            const text = customTextInput.value;
            if (text) {
                ctx.save();
                ctx.fillStyle = textColorInput.value;
                // Use selected font from dropdown
                ctx.font = `${textSizeInput.value}px "${fontSelect.value.split(',')[0].trim()}", ${fontSelect.value.split(',').slice(1).join(',').trim() || 'sans-serif'}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let textX = canvasWidth / 2;
                let textY = canvasHeight / 2;
                const textPadding = 20; // Padding from edges

                switch (textPositionSelect.value) {
                    case 'top-left':
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        textX = textPadding;
                        textY = textPadding;
                        break;
                    case 'top-right':
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        textX = canvasWidth - textPadding;
                        textY = textPadding;
                        break;
                    case 'bottom-left':
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        textX = textPadding;
                        textY = canvasHeight - textPadding;
                        break;
                    case 'bottom-right':
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        textX = canvasWidth - textPadding;
                        textY = canvasHeight - textPadding;
                        break;
                    case 'bottom-center':
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        textX = canvasWidth / 2;
                        textY = canvasHeight - textPadding;
                        break;
                    case 'center':
                    default:
                        // Default is center, already set
                        break;
                }

                ctx.fillText(text, textX, textY);
                ctx.restore();
            }

            ctx.filter = 'none'; // Reset filter for next frame to avoid accumulation issues
        }

        // Recording functionality
        startRecordBtn.addEventListener('click', () => {
            if (!audioPlayer.src) {
                showMessage('សូមផ្ទុកឯកសារតន្ត្រីជាមុនសិន។', true);
                return;
            }
            if (!isImageLoaded && (visualizerTypeSelect.value === 'image-bars' || visualizerTypeSelect.value === 'image-only')) {
                showMessage('សូមផ្ទុករូបភាពជាមុនសិន ប្រសិនបើអ្នកជ្រើសរើសចលនារូបភាព។', true);
                return;
            }

            // Ensure audio context is running
            initAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Start playing audio if paused
            if (audioPlayer.paused) {
                audioPlayer.play();
                playPauseBtn.textContent = 'ផ្អាក';
            }

            // Start visualization
            drawVisualizer();

            // Create an audio destination for recording if it doesn't exist or is not connected
            if (!audioDestinationNode) {
                audioDestinationNode = audioContext.createMediaStreamDestination();
                // Connect the existing audio source to this new destination for recording
                // This will send audio to both the analyser (for visualization/playback) and the recorder
                source.connect(audioDestinationNode);
            }

            // Capture stream from canvas
            const canvasStream = visualizerCanvas.captureStream(30); // 30 frames per second

            // Get audio track from the audio destination
            const audioTrack = audioDestinationNode.stream.getAudioTracks()[0];

            if (audioTrack) {
                canvasStream.addTrack(audioTrack); // Add audio track to the video stream
            } else {
                showMessage('មិនអាចចាប់យកសម្លេងបានទេ។ ត្រូវប្រាកដថាឯកសារតន្ត្រីត្រូវបានផ្ទុក។', true);
                // Disconnect audioDestinationNode if it was created but no track found
                if (audioDestinationNode) {
                    source.disconnect(audioDestinationNode);
                    audioDestinationNode = null;
                }
                return;
            }

            // Create MediaRecorder with the combined stream
            recordedChunks = [];
            // Updated mimeType to include opus for audio (a common and good audio codec for WebM)
            mediaRecorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm; codecs=vp8,opus' });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                downloadVideoLink.href = url;
                downloadVideoLink.classList.remove('hidden');
                downloadVideoLink.textContent = 'ទាញយកវីដេអូ (WebM)';
                showMessage('ការថតត្រូវបានបញ្ចប់។ អ្នកអាចទាញយកវីដេអូបាន។', false, true);
                isRecording = false;
                startRecordBtn.disabled = false;
                stopRecordBtn.disabled = true;

                // Disconnect audio destination after recording stops
                if (audioDestinationNode) {
                    source.disconnect(audioDestinationNode);
                    audioDestinationNode = null;
                }
            };

            mediaRecorder.start();
            isRecording = true;
            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = false;
            downloadVideoLink.classList.add('hidden'); // Hide download link during recording
            showMessage('កំពុងថតវីដេអូ...', false, true);
        });

        stopRecordBtn.addEventListener('click', () => {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                cancelAnimationFrame(animationFrameId); // Stop visualization
                audioPlayer.pause(); // Pause audio
                playPauseBtn.textContent = 'ចាក់';
                showMessage('បញ្ឈប់ការថត។ កំពុងរៀបចំវីដេអូ...', false, true);
            }
        });

        // Handle window resize to adjust canvas dimensions
        window.addEventListener('resize', () => {
            updateCanvasSize();
        });

        // Ensure initial canvas size is set correctly and aspect ratio applied
        window.onload = () => {
            updateCanvasSize();
            // Initial state for auto size checkboxes
            imageSizeSlider.disabled = autoImageSizeCheckbox.checked;
            backgroundSizeSlider.disabled = autoBackgroundSizeCheckbox.checked; // Disable background slider initially
        };

    </script>
</body>
</html>
